#!/usr/bin/env bash       # Apple Silicon
# 自动切换到 HomeBrew 或 /usr/local 安装的 bash（若存在），保证脚本在较新版本的 bash 中运行。
if [[ -x /opt/homebrew/bin/bash && "$BASH" != "/opt/homebrew/bin/bash" ]]; then
  exec /opt/homebrew/bin/bash "$0" "$@"
elif [[ -x /usr/local/bin/bash && "$BASH" != "/usr/local/bin/bash" ]]; then
  exec /usr/local/bin/bash "$0" "$@"
fi

# 自动执行的批处理：HomeBrew \ MAS \ MacPorts \ TopGrade \ MacUpdater

#设置执行所需的 环境变量！
export PATH="/usr/local/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/opt/local/bin:/opt/local/sbin:$PATH"

# 预先解析 GNU Parallel 的绝对路径。在某些 sudo 环境下 PATH 可能被重置，导致找不到 parallel。
if command -v parallel >/dev/null 2>&1; then
    PARALLEL_BIN="$(command -v parallel)"
else
    # 如果未安装 parallel，保持变量为空。后续逻辑会自动安装或提示。
    PARALLEL_BIN="parallel"
fi
export PARALLEL_BIN

# 动态计算并行下载任务数量：根据 CPU 核心数设定 xargs/parallel 的 -P 参数
CPU_CORES=$(sysctl -n hw.ncpu 2>/dev/null || getconf _NPROCESSORS_ONLN 2>/dev/null || echo 4)
# 如果无法检测或结果非法，则默认设置为 4
if ! echo "$CPU_CORES" | grep -qE '^[0-9]+$' || [ "$CPU_CORES" -lt 1 ]; then
    CPU_CORES=4
fi
# 根据 CPU 核心数决定并行度，最大不超过 32
if [ "$CPU_CORES" -gt 32 ]; then
    PARALLEL_JOBS=32
else
    PARALLEL_JOBS=$CPU_CORES
fi
export PARALLEL_JOBS

# 为了避免某些多语言 Cask 默认下载系统语言版本导致网络不可达，
# 默认根据系统的首选语言自动设置 HomeBrew Cask 的语言选项。
# 当系统语言对应的下载镜像不可用时，可通过修改下方算法或在脚本
# 外部预定义 HOMEBREW_CASK_OPTS 环境变量以覆盖自动检测结果。
#
# 读取 macOS 的首选语言。优先从 AppleLanguages 读取第一个元素，
# 如果不可用，则退回到 AppleLocale。检测结果会简化为 brew 支持的
# IETF 语言标记格式。若无法检测则默认使用 en-US。
if [ -z "$HOMEBREW_CASK_OPTS" ]; then
    __brew_lang=""
    if command -v defaults >/dev/null 2>&1; then
        # 尝试读取 AppleLanguages 的首选项
        __first_lang="$(defaults read -g AppleLanguages 2>/dev/null | awk -F '"' 'NR==2 {print $2}')"
        if [ -n "$__first_lang" ]; then
            __brew_lang="$__first_lang"
        else
            # 如果 AppleLanguages 不可用，则读取 AppleLocale
            __locale="$(defaults read -g AppleLocale 2>/dev/null || defaults read NSGlobalDomain AppleLocale 2>/dev/null)"
            # 去除 @ 符号及其后内容
            __locale="${__locale%%@*}"
            # 将 zh_CN 等下划线形式转换为 zh-CN
            __brew_lang="$(echo "$__locale" | tr '_' '-')"
        fi
    fi
    # 针对常见语言代码进行映射修正
    case "$__brew_lang" in
        zh-Hans*|zh_CN*|zh-CN*)
            __brew_lang="zh-CN"
            ;;
        zh-Hant*|zh_TW*|zh-TW*)
            __brew_lang="zh-TW"
            ;;
        en*|en_US*|en-US*)
            __brew_lang="en-US"
            ;;
        "")
            __brew_lang="en-US"
            ;;
    esac
    export HOMEBREW_CASK_OPTS="--language=$__brew_lang"
    # 同时设置 BREW_CASK_LANGUAGE 变量，便于传参到 brew fetch 等命令
    export BREW_CASK_LANGUAGE="$__brew_lang"
    unset __first_lang __locale __brew_lang
fi


# ================================================================================================
# 参数设置：用户可修改 （Start）
# ================================================================================================

# 设置 ：本脚本拒绝执行的时间范围
STOP_TIME="03:00"       # 拒绝执行 的 结束时间（这个时间后任务正常运行）
DURATION_MINUTES=10     # 拒绝执行结束前 的 时间长度（10分钟，意味着从 2:50 - 3:00 , 本脚本拒绝执行） 注意，单位：分钟（注意，单位不是秒！！！）

# 路径：保存日志文件的路径
# ICLOUD_PATH="$HOME/Library/Mobile Documents/com~apple~CloudDocs"            # 获取 iCloud 云盘路径，
# COMPUTER_NAME=$(scutil --get ComputerName)                                  # 获取 本机名称（并以本机名称作为子文件夹名称）
# LOG_PATH="$ICLOUD_PATH/LOG/$COMPUTER_NAME"                                  # LOG 日志文件 的 保存路径
# mkdir -p "$LOG_PATH"                                                        # 创建目录   # 注意：这里是保存到iCloud，也可以设置别的保存路径


# 路径：保存日志文件的路径
# 根据当前运行环境动态确定 iCloud 云盘路径。若以 root 身份运行（例如通过 sudo 调用），
# 则根据实际登录用户的家目录计算 iCloud 路径，保证日志和备份路径始终保存在真实用户的 iCloud 目录下。
if [[ "$(id -u)" -eq 0 ]]; then
    targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
    targetHome=$(eval echo "~$targetUser")
    ICLOUD_PATH="$targetHome/Library/Mobile Documents/com~apple~CloudDocs"
else
    ICLOUD_PATH="$HOME/Library/Mobile Documents/com~apple~CloudDocs"
fi
# 生成用于标识设备的目录名称。格式为“型号名称-芯片名称-序列号/用户名”。
# 型号名称取自系统信息的 Model Name 并删除空格；芯片名称去掉 Apple 前缀并删除所有空格；序列号读取系统序列号。
MODEL_NAME_RAW=$(system_profiler SPHardwareDataType 2>/dev/null | awk -F: '/Model Name/{print $2; exit}')
MODEL_NAME_CLEAN=$(echo "${MODEL_NAME_RAW}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//;s/[[:space:]]//g')
CPU_BRAND_RAW=$(sysctl -n machdep.cpu.brand_string 2>/dev/null)
CPU_BRAND_TRIM=$(echo "${CPU_BRAND_RAW}" | sed 's/^Apple[[:space:]]*//;s/^[[:space:]]*//;s/[[:space:]]*$//')
CPU_BRAND_CLEAN=$(echo "${CPU_BRAND_TRIM}" | sed 's/[[:space:]]//g')
SERIAL_NUMBER_RAW=$(system_profiler SPHardwareDataType 2>/dev/null | awk -F: '/Serial Number/{print $2; exit}')
SERIAL_NUMBER_CLEAN=$(echo "${SERIAL_NUMBER_RAW}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
# 为了确保无论脚本以哪种方式运行（普通用户/通过 sudo 提权等），日志目录均基于实际登录用户而不是当前有效 UID。
# 如果当前 uid 为 0（root），优先使用 $SUDO_USER（sudo 调用者），否则从控制台获取活跃用户；
# 否则直接使用 $USER 环境变量，若未设置则回退到控制台用户。
if [[ "$(id -u)" -eq 0 ]]; then
    # 以 root 运行时尝试还原到调用 sudo 的用户，若不存在则使用当前控制台登录用户
    USER_NAME="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
else
    # 非 root 情况直接使用 USER 环境变量，若不存在则使用当前控制台登录用户
    USER_NAME="${USER:-$(stat -f '%Su' /dev/console)}"
fi
DEVICE_DIR="${MODEL_NAME_CLEAN}-${CPU_BRAND_CLEAN}-${SERIAL_NUMBER_CLEAN}"
# 清理多余的连字符
DEVICE_DIR=$(echo "$DEVICE_DIR" | sed 's/--*/-/g; s/^-//; s/-$//')
LOG_PATH="$ICLOUD_PATH/LOG/${DEVICE_DIR}/${USER_NAME}"
mkdir -p "$LOG_PATH"                                                        # 创建目录到 iCloud
# 保留原有 COMPUTER_NAME 变量以供其他逻辑使用
COMPUTER_NAME=$(scutil --get ComputerName)


# 用于标记需要手动运行安装器的 cask
MANUAL_INSTALL_CASKS=("paragon-ntfs" "paragon-extfs")


################################################################################
# 新增：初始化下载失败记录和重试参数
#
# 为了在并行下载阶段准确记录下载失败的软件包及其下载链接，本脚本引入以下变量：
#   FAILED_FETCH_FORMULAS_FILE ：记录 formula 下载失败的包名与下载链接
#   FAILED_FETCH_CASKS_FILE    ：记录 cask 下载失败的包名与下载链接
#   DOWNLOAD_MAX_RETRIES       ：每个软件包下载时最大的重试次数，默认 3 次
# 这些文件在脚本运行开始时会被清空，并在并行下载任务中写入。变量需要导出以便
# 在 sudo/parallel 环境中生效。
FAILED_FETCH_FORMULAS_FILE="$LOG_PATH/.failed_fetch_formulas"
FAILED_FETCH_CASKS_FILE="$LOG_PATH/.failed_fetch_casks"
# 清空失败记录文件，确保每次运行独立
: > "$FAILED_FETCH_FORMULAS_FILE"
: > "$FAILED_FETCH_CASKS_FILE"
# 下载失败的最大重试次数（可按需调整）
# 默认尝试五次，对于网络问题或链接不可用时会重试
DOWNLOAD_MAX_RETRIES=5
# 导出变量供子进程使用
export FAILED_FETCH_FORMULAS_FILE FAILED_FETCH_CASKS_FILE DOWNLOAD_MAX_RETRIES

# -------------------------------------------------------------------------------------------------
# 根据当前脚本的执行身份，决定 sudo 命令是否强制使用非交互模式
# 如果脚本以 root 身份运行（例如通过 sudo 调用），则后续内部调用 sudo 时添加 -n 选项，
# 防止在无人值守执行时阻塞等待密码。如果脚本以普通用户身份运行，则允许 sudo 正常提示密码
# 以便在交互式终端中完成相应操作。
if [ "$(id -u)" -eq 0 ]; then
    SUDO_N_FLAG="-n"
else
    SUDO_N_FLAG=""
fi
export SUDO_N_FLAG

# =====================
# 新增：校验失败重试参数（默认 1 次）
#
# 当 HomeBrew 在安装过程中检测到下载后的文件 SHA-256 校验失败时，
# 本脚本会停止后续的重装尝试并直接标记为失败。该变量允许用户配置
# 重新尝试升级的次数（1 表示不重试）。如需尝试多次，可修改此值。
SHA_MISMATCH_MAX_RETRIES=1
export SHA_MISMATCH_MAX_RETRIES
################################################################################


# ================================================================================================
# 参数设置：用户可修改 （End）
# ================================================================================================




# ---------------------------------------
# 参数设置：不建议用户修改
# ---------------------------------------

# 定义：日志文件
LOG_FULL_LAST="$LOG_PATH/--UpdateFull.--Last--.log"
LOG_FILE="$LOG_PATH/Update_Auto.log"
LOG_FULL_FILE="$LOG_PATH/UpdateFull.$(date +%Y-%m).log"
LOG_ERROR_FILE="$LOG_PATH/Update_Error.log"
LOG_MACUPDATER_FILE="$LOG_PATH/Update_MacUpdater.log"

echo -e "" > "$LOG_MACUPDATER_FILE"

# 开启严格模式与统一错误处理。
# 使用 set -Eeuo pipefail 让脚本在遇到未捕获的错误时立即退出，
# 并通过 trap 捕捉 ERR 事件，在出错时输出详细的错误信息到日志文件。
set -u -o pipefail -E
trap 'last_cmd=$BASH_COMMAND; code=$?; line=${BASH_LINENO[0]}; \
     # 只有非零返回码才视为错误，code=0 时忽略
     if [ "$code" -ne 0 ]; then \
         printf "[FATAL] 第 %s 行命令 \"%s\" 失败，退出码=%s\n" "$line" "$last_cmd" "$code" | \
         tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_ERROR_FILE"; \
         # 不退出脚本，继续执行后续任务
     fi' ERR

# 定义：被测试的外网网址（需要翻墙的网址）
TARGET_1="github.com"                                       # 测试 主流开源软件下载库 的连通性
TARGET_2="formulae.brew.sh/api/formula.jws.json"            # 测试 homebrew 的主站 连通性 (brew.sh)
TARGET_3="apps.apple.com/us/app/apple-store/id375380948"    # 测试 Mac App Store 连通性 （本链接是 苹果官方 Apple Store ）
TARGET_4="macupdater.com"                                   # 测试 MacUpdater 连通性
# 如果不能访问上述网站，会导致很多软件都 更新失败。




# ---------------------------------------
# 自定义函数
# ---------------------------------------


# ************************* #
# 定义函数：检查时间范围的函数
# ************************* #

check_time_range() {

    local stop_time="$1"           # 停止时间
    local duration_minutes="$2"    # 执行时长（分钟）
    local LOG_ERROR_FILE="$3"      # 日志文件

    # 计算起始时间并确保格式为 HH:MM
    local stop_time_seconds start_time
    stop_time_seconds=$(date -j -f "%H:%M" "$stop_time" "+%s") # 将停止时间转换为时间戳
    start_time=$(date -j -f "%s" $((stop_time_seconds - duration_minutes * 60)) "+%H:%M") # 计算起始时间，并转为 HH:MM 格式

    # 获取当前时间
    local current_time
    current_time=$(date '+%H:%M')

    # 检查当前时间是否在范围内
    if [[ ( "$current_time" > "$start_time" || "$current_time" == "$start_time" ) && "$current_time" < "$stop_time" ]]; then
        printf "\033[1;31m[STOP]\033[0m  "
        printf "[STOP] "                                                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  > /dev/null 
        echo -e "任务退出（$(date '+%Y-%m-%d %H:%M:%S')）：为避免与预设 定时任务 冲突"      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_ERROR_FILE" 
        printf "\033[1;31m[STOP]\033[0m  "
        printf "[STOP] "                                                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  > /dev/null 
        echo -e "时间范围（停止建立 更新任务）：$start_time - $stop_time"                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_ERROR_FILE" 
        exit
    fi

}


# ************************* #
# 自定义函数：检查连接的函数

# ************************* #
check_connection() {

    local target=$1
    local LOG_FILE=$2

    if curl -I --connect-timeout 5 "$target" > /dev/null 2>&1; then
        printf "\033[1;32m[OK]\033[0m   "  
        printf "[OK]   "                                                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  > /dev/null  
        printf "已连通 [$target] \n"                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"   
        return 0
    else
        printf "\033[1;31m[ERROR]\033[0m " 
        printf "[ERROR] "                                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_FILE"  > /dev/null  
        echo -e "[$target] $(date '+%Y-%m-%d %H:%M:%S') 连接失败，等待10秒后重试 ... "        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_FILE"  
        sleep 10
        return 1
    fi

}


# ************************* #
# 自定义函数：显示进度条
# ************************* #

show_progress() {

    # 可输入的变量
    local scanned=$1
    local unrecognized=$2
    local to_update=$3
    local total=$4

    # 定义进度条长度（注意：折行，会导致刷新异常！！！！！）
    local bar_width=20

    # 防止除以零
    if [ "$total" -eq 0 ]; then
        total=1
    fi

    # 计算百分比
    local percent=$(( scanned * 100 / total ))

    # 生成进度条
    local filled=$(( scanned * bar_width / total ))
    local empty=$(( bar_width - filled ))
    local bar=""
    for ((i=0; i<filled; i++)); do bar+="█"; done
    for ((i=0; i<empty; i++)); do bar+="-"; done

    # 打印进度条到终端（仅当存在交互终端）
    if [ -t 1 ]; then
        printf "\r进度: [%-${bar_width}s] %d%% | 未识别: %d | 需更新: %d | 已扫描: %d/%d" \
            "$bar" "$percent" "$unrecognized" "$to_update" "$scanned" "$total" > /dev/tty
    fi

}


# ************************* #
# 自定义函数：运行命令并处理输出
# ************************* #

run_command_with_show_progress() {

    # 可输入的变量
    local CMD="$1"
    local MODE="$2" # SCAN 或 UPDATE
    local LOCAL_LOG_FILE="$3" # 

    # 初始化进度变量
    local scanned=0
    local unrecognized=0
    local to_update=0

    # 日志记录开始执行的命令
    echo -e "✓  执行命令: $CMD"         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOCAL_LOG_FILE"

    # 执行命令并实时处理输出
    # 通过在管道结尾加上 '|| true' 避免 set -e 与 pipefail 在命令非零退出时导致脚本终止
    eval "$CMD" 2>&1         | tee -a  "$LOCAL_LOG_FILE" | while IFS= read -r line; do
        # 检查是否为 'Scan did stop scanning' 的行
        if [[ "$line" =~ Scan\ did\ stop\ scanning\ \'[^\']+\'\ app\.\.\. ]]; then
            ((scanned++))
            show_progress "$scanned" "$unrecognized" "$to_update" "$TOTAL_APPS"
        fi

        # 记录每一行到日志文件
        echo -e "$line" >> "$LOCAL_LOG_FILE"
    done || true

    # 完成后换行（避免下次输出覆盖进度条，仅当存在交互终端）
    if [ -t 1 ]; then
        echo -e "" > /dev/tty
    fi
    echo -e ""         | tee -a  "$LOCAL_LOG_FILE"

}


# ************************* #
# 自定义函数：恢复 LaunchPad 和 启动台布局
# ************************* #

restore_desktop_layout() {

    PATH_DesktopLayout_SOURCE1="$HOME/Library/Preferences"

    if [ -z "$PARENT_DIR" ]; then
        USER_ID=$(basename "$(dirname "$TMPDIR")")
        PARENT_DIR=$(find /System/Volumes/Data/private/var/folders/ -maxdepth 2 -type d -name "$USER_ID" 2>/dev/null)
    fi

    PATH_DesktopLayout_SOURCE2="$PARENT_DIR/0"

    if [ ! -f "$PATH_DesktopLayout_BACKUP/com.apple.spaces.plist" ] || \
       [ ! -f "$PATH_DesktopLayout_BACKUP/com.apple.dock.plist" ] || \
       [ ! -d "$PATH_DesktopLayout_BACKUP/com.apple.dock.launchpad" ]; then

        printf  "\033[1;34m[Info]\033[0m "
        printf  "[Info] "                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "错误：备份文件不完整，无法恢复 启动台布局"                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    else

        printf  "\033[1;34m[Info]\033[0m "
        printf  "[Info] "                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null  
        echo -e "开始还原 启动台布局 ... "                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        cp -f   "$PATH_DesktopLayout_BACKUP/com.apple.spaces.plist"       "$PATH_DesktopLayout_SOURCE1/com.apple.spaces.plist"
        cp -f   "$PATH_DesktopLayout_BACKUP/com.apple.dock.plist"         "$PATH_DesktopLayout_SOURCE1/com.apple.dock.plist"
        sudo $SUDO_N_FLAG cp -rf "$PATH_DesktopLayout_BACKUP/com.apple.dock.launchpad" "$PATH_DesktopLayout_SOURCE2"
        printf  "\033[1;34m[Info]\033[0m "
        printf  "[Info] "                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null  
        echo -e "正在重启 启动台布局 ... "                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        killall Dock

    fi

}



# ************************* #
# 自定义函数： GUI 会话里弹通知或对话框
# ************************* #

show_sysupdate_popup() {
    local title="MacOS 更新需要手动操作"
    local msg="脚本未执行安装，请在终端手动输入：\nsoftwareupdate --install --all --force --verbose"

    # 检测当前登录的图形用户
    local consoleUser
    consoleUser=$(stat -f '%Su' /dev/console)           # 10.10+ 正式接口  
    local consoleUid
    consoleUid=$(id -u "$consoleUser")

    # AppleScript；display dialog 会阻塞，可改成 display notification
    local osaScript='display alert "'"$title"'" message "'"$msg"'" buttons {"OK"} giving up after 30'

    if [[ $(id -u) -eq 0 ]]; then                       # 以 root 身份运行
        if launchctl asuser "$consoleUid" true &>/dev/null; then
            launchctl asuser "$consoleUid" /usr/bin/osascript -e "$osaScript" &
        else
            sudo -n -u "$consoleUser" /usr/bin/osascript -e "$osaScript" &
        fi
    else                                                # 普通用户
        /usr/bin/osascript -e "$osaScript" &
    fi
}




# ************************* #
# 自定义函数：尝试优雅退出指定的 HomeBrew 应用，若30秒内未退出则强制结束
# ************************* #

attempt_quit_app() {
    local brew_app_id="$1"
    local brew_process_name="$2"

    # ---------- 新增：容错处理 ----------
    # 情况 A：Bundle ID 缺失，但进程名存在 → 退而直接 kill 进程
    if [[ -z "$brew_app_id" && -n "$brew_process_name" ]]; then
        echo "⚠️  未找到 Bundle ID，改用进程名 $brew_process_name 退出…" 
        /usr/bin/pkill -x "$brew_process_name" 2>/dev/null
        return 0
    fi

    # 情况 B：既缺 Bundle ID 又缺进程名 → 无可用信息，退出
    if [[ -z "$brew_app_id" && -z "$brew_process_name" ]]; then
        echo "⚠️  无法退出应用：缺少 应用ID ( brew_app_id = $brew_app_id ) 或 进程名 ( brew_process_name = $brew_process_name ) ... "
        return 1
    fi

    # ---------- 原有的优雅退出逻辑从此继续 ----------

    # 根据当前权限选择 AppleScript 执行方式（降权到实际用户）
    if [[ $(id -u) -eq 0 ]]; then

        local targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"   # 获取实际登录用户
        local consoleUid="$(id -u "$targetUser" 2>/dev/null)"
        
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 osascript 立刻退出进程。 ... "   
        echo -e "✓  注意：在退出 '$brew_process_name' 进程时，如果程序弹窗，阻止程序退出（需用户手动确认退）。本脚本将等待30秒，然后发起 强制退出，并强制关闭本进程所有窗口 ... "   

        if launchctl asuser "$consoleUid" true &>/dev/null; then
            # 以实际登录用户上下文运行 AppleScript，尝试优雅退出应用（30秒超时）
            launchctl asuser "$consoleUid" /usr/bin/osascript \
                -e "with timeout of 30 seconds" \
                -e "tell application id \"$brew_app_id\" to quit" \
                -e "end timeout"
        else
            # 回退：直接以该用户身份运行 AppleScript
            sudo -n -u "$targetUser" /usr/bin/osascript \
                -e "with timeout of 30 seconds" \
                -e "tell application id \"$brew_app_id\" to quit" \
                -e "end timeout"
        fi

    else

        echo -e "✓  当前用户'$USER'，为普通权限，直接运行 osascript 立刻退出进程。 ... "     
        echo -e "✓  注意：在退出 '$brew_process_name' 进程时，如果程序弹窗，阻止程序退出（需用户手动确认退）。本脚本将等待30秒，然后发起 强制退出，并强制关闭本进程所有窗口 ... "       

        # 非 root 情况，直接运行 AppleScript 优雅退出
        /usr/bin/osascript \
            -e "with timeout of 30 seconds" \
            -e "tell application id \"$brew_app_id\" to quit" \
            -e "end timeout"

    fi


    local exit_code=$?

    if [[ $exit_code -ne 0 ]]; then
        # 30秒内未正常退出，执行强制结束
        echo -e "✘  无法正常退出 '$brew_process_name' ，正在尝试 强制退出 !!!  "
        if [[ $(id -u) -eq 0 ]]; then
            # 以普通用户权限发送 kill 信号
            echo -e "...  （已完成30秒等待）Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 pkill 强制退出 '$brew_process_name' 进程 ，以便执行 后续更新 ... "   
            local targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
            sudo -n -u "$targetUser" /usr/bin/pkill -x "$brew_process_name"
        else
            echo -e "...  （已完成30秒等待）当前用户'$USER'，为普通权限，直接运行 pkill 强制退出 '$brew_process_name' 进程 ，以便执行 后续更新 ... "     
            /usr/bin/pkill -x "$brew_process_name"
        fi
    else
        echo -e "✓  已完成退出!!!! 进程 '$brew_process_name' 没有阻塞退出，没有启动30秒等待 !!!  "

    fi

}



# ************************* #
# 自定义函数：统一的错误输出（带着色与日志追加）
# ************************* #

print_error() {
  printf "\033[1;31m[ERROR]\033[0m  "
  printf "[ERROR] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
  echo -e "$*" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
}

# -------------------------------------------------------------------------------
# 辅助函数：run_as_normal_user 和 maybe_run_as_normal_user
# 这些函数在脚本顶层定义，确保在任何地方调用时均已存在。
# run_as_normal_user 会在当前为 root 时降权到真实用户并执行命令，否则直接执行。
# maybe_run_as_normal_user 会根据当前权限自动选择运行 run_as_normal_user 或直接执行命令。
run_as_normal_user() {
  if [ "$(id -u)" -eq 0 ]; then
      local targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
      # 在 root 模式下，使用 sudo 保留环境并降权执行命令，避免重复打印提示
      sudo -n -E -H -u "$targetUser" env PATH="/opt/homebrew/bin:/usr/local/bin:$PATH" HOMEBREW_CASK_OPTS="$HOMEBREW_CASK_OPTS" "$@"
  else
      "$@"
  fi
}
maybe_run_as_normal_user() {
  if [ "$(id -u)" -eq 0 ]; then
      run_as_normal_user "$@"
  else
      "$@"
  fi
}
export -f run_as_normal_user
export -f maybe_run_as_normal_user







# =========================
# Xcode Command Line Tools
# =========================

check_clt_receipt() {
    /usr/sbin/pkgutil --pkg-info=com.apple.pkg.CLTools_Executables >/dev/null 2>&1 \
    || /usr/sbin/pkgutil --pkg-info=com.apple.pkg.DeveloperToolsCLI >/dev/null 2>&1
}

_auto_find_clt_label() {
    /usr/sbin/softwareupdate --list 2>&1 \
    | /usr/bin/grep -Eo 'Label: .*Command Line Tools.*' \
    | /usr/bin/sed 's/^Label: //; q'
}

auto_install_clt() {
    local TMPFLAG="/tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress"
    local LOGA="$LOG_FULL_LAST" LOGB="$LOG_FULL_FILE"

    echo -e "⚙️  Command Line Tools 收据缺失，尝试自动安装 ..." | tee -a "$LOGA" "$LOGB"

    sudo $SUDO_N_FLAG /bin/rm -f "$TMPFLAG" 2>/dev/null || true
    sudo $SUDO_N_FLAG /usr/bin/touch "$TMPFLAG"

    local LABEL; LABEL="$(_auto_find_clt_label)"

    if [ -z "$LABEL" ] && [ -d /Library/Developer/CommandLineTools ] && ! check_clt_receipt; then
        echo -e "↻ 未找到标签，疑似残留安装；清理并重试一次 ..." | tee -a "$LOGA" "$LOGB"
        sudo $SUDO_N_FLAG /bin/rm -rf /Library/Developer/CommandLineTools
        sudo $SUDO_N_FLAG /bin/rm -f "$TMPFLAG" 2>/dev/null || true
        sudo $SUDO_N_FLAG /usr/bin/touch "$TMPFLAG"
        LABEL="$(_auto_find_clt_label)"
    fi

    if [ -n "$LABEL" ]; then
        echo -e "⚙️  安装: $LABEL" | tee -a "$LOGA" "$LOGB"
        if sudo $SUDO_N_FLAG /usr/sbin/softwareupdate --install "$LABEL" --agree-to-license --verbose 2>&1 | tee -a "$LOGA" "$LOGB"; then
            sudo $SUDO_N_FLAG /bin/rm -f "$TMPFLAG" 2>/dev/null || true
            return 0
        fi
    fi

    sudo $SUDO_N_FLAG /bin/rm -f "$TMPFLAG" 2>/dev/null || true
    echo -e "❌ 未找到 Command Line Tools 更新标签。请手动执行：xcode-select --install" \
        | tee -a "$LOGA" "$LOGB" "$LOG_ERROR_FILE"
    return 1
}

ensure_clt_or_skip_macports() {
    if check_clt_receipt; then
        return 0
    fi
    if auto_install_clt && check_clt_receipt; then
        return 0
    fi
    echo -e "⏭️  跳过 MacPorts：尚未检测到有效的 Command Line Tools 收据。" \
        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_ERROR_FILE"
    return 1
}



# =========================
# MacPorts 辅助函数
# =========================

# 判断是否需要迁移：当 Darwin 主版本、CPU 架构或 MacPorts base 版本变化时迁移
get_darwin_major() { /usr/bin/uname -r | /usr/bin/awk -F. '{print $1}'; }
get_arch() { /usr/bin/uname -m; }
get_macports_base_ver() { /opt/local/bin/port version 2>/dev/null | /usr/bin/awk '{print $2}'; }

MP_STATE_DIR="$HOME/.local/state/usercmd"
MP_MIGRATE_TOKEN_FILE="$MP_STATE_DIR/macports.migrate.token"

macports_should_migrate() {
    /bin/mkdir -p "$MP_STATE_DIR" 2>/dev/null || true
    local cur_token="$(get_darwin_major)-$(get_arch)-$(get_macports_base_ver)"
    [ ! -f "$MP_MIGRATE_TOKEN_FILE" ] && { echo "$cur_token" > "$MP_STATE_DIR/.need_migrate.tmp"; return 0; }
    local old_token; old_token="$(/bin/cat "$MP_MIGRATE_TOKEN_FILE" 2>/dev/null || echo "")"
    if [ "$old_token" != "$cur_token" ]; then
        echo "$cur_token" > "$MP_STATE_DIR/.need_migrate.tmp"
        return 0
    fi
    return 1
}

macports_mark_migrated() {
    [ -f "$MP_STATE_DIR/.need_migrate.tmp" ] && /bin/mv -f "$MP_STATE_DIR/.need_migrate.tmp" "$MP_MIGRATE_TOKEN_FILE"
}

# 静默升级过期端口并生成摘要
macports_upgrade_outdated_quiet() {
    printf  "\033[1;34m[Download & Install]\033[0m " 
    printf  "[Download & Install] "                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "MacPorts 下载安装 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    echo -e "【升级摘要】" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 使用 -u 开关可在升级完成后卸载旧版本，以便在完成升级后自动清理老版本；--no-rev-upgrade 禁止在升级之后触发 rev-upgrade 检查
    sudo $SUDO_N_FLAG /opt/local/bin/port -u -N upgrade --no-rev-upgrade outdated 2>&1 \
      | /usr/bin/grep -E '^--->  (Upgrading|Installing|Activating|Deactivating) |^Error:' \
      | /usr/bin/sed -E \
        -e 's/^--->[[:space:]]+Upgrading[[:space:]]+([^[:space:]]+)[[:space:]]+@([^[:space:]]+)[[:space:]]+to[[:space:]]+@([^[:space:]]+).*/• \1  \2  →  \3/' \
        -e 's/^--->[[:space:]]+Installing/• Installing/' \
        -e 's/^--->[[:space:]]+Activating/• Activating/' \
        -e 's/^--->[[:space:]]+Deactivating/• Deactivating/' \
      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
}

macports_rev_upgrade_quiet() {
    # 显示扫描与结果，不落独立文件，只写主日志
    sudo $SUDO_N_FLAG /opt/local/bin/port rev-upgrade 2>&1 \
      | /usr/bin/grep -E '^--->  Scanning binaries for linking errors|^--->  No broken (files|ports) found\.|^Found [0-9]+ broken|^--->  Rebuilding ' \
      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
}


__get_migrate_log_file() {
    local base=""
    [ -n "${LOG_UPDATE_MACUPDATER:-}" ] && base="$LOG_UPDATE_MACUPDATER"
    [ -z "$base" ] && [ -n "${UPDATE_MACUPDATER_LOG:-}" ] && base="$UPDATE_MACUPDATER_LOG"
    [ -z "$base" ] && [ -f "$HOME/Update_MacUpdater.log" ] && base="$HOME/Update_MacUpdater.log"
    [ -z "$base" ] && [ -n "${LOG_FULL_LAST:-}" ] && base="$LOG_FULL_LAST"
    [ -z "$base" ] && [ -n "${LOG_FULL_FILE:-}" ] && base="$LOG_FULL_FILE"
    [ -z "$base" ] && base="$HOME/Update_MacUpdater.log"
    local dir="${base%/*}"; [ "$dir" = "$base" ] && dir="$HOME"
    echo "${dir}/Migrate_MacPorts.log"
}






# -----------------------------------------------
# 检查 & 创建 ：Log日志文件
# -----------------------------------------------

# 重置LOG_FULL_LAST日志文件
cat /dev/null > "$LOG_FULL_LAST"

# 检查LOG_FILE日志文件是否存在
if [ ! -f "$LOG_FILE" ]; then
    # 文件不存在，创建文件
    touch "$LOG_FILE"
fi

# 检查LOG_ERROR_FILE日志文件是否存在
if [ ! -f "$LOG_ERROR_FILE" ]; then
    # 文件不存在，创建文件
    touch "$LOG_ERROR_FILE"
fi

# 检查LOG_FULL_FILE日志文件是否存在
if [ ! -f "$LOG_FULL_FILE" ]; then
    # 文件不存在，创建文件
    touch "$LOG_FULL_FILE"
else
    # 文件存在，检查文件大小
    FILE_SIZE=$(stat -f%z "$LOG_FULL_FILE") # macOS 使用 stat -f%z

    if [ "$FILE_SIZE" -gt 10 ]; then
        # 如果文件大小超过100字节，执行以下操作
        echo -e "" >> "$LOG_FULL_FILE"
        echo -e "" >> "$LOG_FULL_FILE"
        echo -e "" >> "$LOG_FULL_FILE"
        echo -e "" >> "$LOG_FULL_FILE"
        echo -e "" >> "$LOG_FULL_FILE"
        echo -e "" >> "$LOG_FULL_FILE"
    fi
fi

# 初始化 MacUpdater 日志文件
echo -e "MacUpdater 执行日志 - $(date)" > "$LOG_MACUPDATER_FILE"



# ---------------------------------------
# 检测：外网是否能正常访问
# ---------------------------------------

echo $PWD

echo -e ""                                                                              | tee -a "$LOG_ERROR_FILE"
echo -e "-------------------------------------------------------------------"           | tee -a "$LOG_ERROR_FILE" > /dev/null
echo -e "" >> "$LOG_ERROR_FILE"
echo -e "[自动更新]  $(date '+%Y-%m-%d %H:%M:%S')  "                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_ERROR_FILE" 
echo -e "======================================================================="       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
printf  "测试网络（海外 HTTPS 连接） ...  ｜  "                                         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_ERROR_FILE" 
echo -e "当前工作目录 = '$PWD' "                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_ERROR_FILE" 
echo -e ""                                                                              | tee -a "$LOG_ERROR_FILE" > /dev/null

# 轮询检查网络连通性
while true; do

    # 调用检查时间范围函数
    check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

    # 检查 TARGET_1 的连接
    if ! check_connection "$TARGET_1" "$LOG_ERROR_FILE"; then
        continue # 如果连接失败，重新开始循环
    fi

    # 检查 TARGET_2 的连接
    if ! check_connection "$TARGET_2" "$LOG_ERROR_FILE"; then
        continue # 如果连接失败，重新开始循环
    fi

    # 检查 TARGET_3 的连接
    if ! check_connection "$TARGET_3" "$LOG_ERROR_FILE"; then
        continue # 如果连接失败，重新开始循环
    fi

    # 检查 TARGET_4 的连接
    if ! check_connection "$TARGET_4" "$LOG_ERROR_FILE"; then
        continue # 如果连接失败，重新开始循环
    fi

    # 如果N个目标，都成功连接，退出循环
    printf "\033[1;32m[OK]\033[0m   "  
    printf "[OK]   "                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "海外 HTTPS 连接正常 ... ✅ "                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    break

done

echo -e "======================================================================="       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"





# -----------------------------------------------
# 检查 ：软硬件信息
# -----------------------------------------------


echo -e "测试安装环境：$(date '+%Y-%m-%d %H:%M:%S') ... "                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

echo -e "\033[1;36m-----------------------------------------------\033[0m" 
echo -e "\033[1;36m 检查 ：软硬件信息            \033[0m"
echo -e "\033[1;36m-----------------------------------------------\033[0m" 

echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "检查 ：软硬件信息            "                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

# 采集系统软硬件信息

# 获取硬件类型（Model Name）
hardware_type=$(system_profiler SPHardwareDataType | awk -F': ' '/Model Name/{print $2}' | sed 's/^ *//')
# 获取 CPU 的 芯片型号
cpu_chip=$(sysctl -n machdep.cpu.brand_string)
# 获取内存大小
memory_size=$(system_profiler SPHardwareDataType | awk -F': ' '/Memory/{print $2}' | sed 's/^ *//')
# 获取磁盘总容量，只取括号前的值（如 "8 TB"），忽略后面的字节数
disk_capacity=$(system_profiler SPStorageDataType \
        | awk -F': ' '/^ *Capacity/{print $2; exit}' \
        | awk -F'(' '{print $1}' \
        | sed 's/^ *//; s/ *$//')
storage_info="${memory_size} / ${disk_capacity}"
# 获取 OS 的 版本名称 (如 tahoe 26)，仅保留代号部分（如 tahoe）
os_full_name=$(awk '/SOFTWARE LICENSE AGREEMENT FOR macOS/' '/System/Library/CoreServices/Setup Assistant.app/Contents/Resources/en.lproj/OSXSoftwareLicense.rtf' | awk -F 'macOS ' '{print $NF}' | awk '{print substr($0, 0, length($0)-1)}')
os_full_name=$(echo "$os_full_name" | tr '[:upper:]' '[:lower:]')
os_name=$(echo "$os_full_name" | awk '{print $1}')

# 获取操作系统版本号（例如 26.0.1 或 15.0），用于显示但不用于平台键
os_version=""
if command -v sw_vers >/dev/null 2>&1; then
    os_version=$(sw_vers -productVersion 2>/dev/null || echo "")
fi
# 获取硬件序列号
hardware_sn=$(system_profiler SPHardwareDataType | awk -F': ' '/Serial Number/{print $2}' | sed 's/^ *//')
# 获取当前的名称信息，用于显示计算机名称
computer_name=$(scutil --get ComputerName 2>/dev/null || true)
local_host_name=$(scutil --get LocalHostName 2>/dev/null || true)
host_name_output=$(scutil --get HostName 2>/dev/null || true)
host_name=""
if [ -n "$host_name_output" ]; then
    host_name="${host_name_output#HostName*: }"
    if [[ "$host_name" = "not set" ]]; then
        host_name=""
    fi
fi

# 初始化 sync_message 为空
sync_message=""

echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 打印软硬件信息
printf "\033[1;34m[INFO]\033[0m "
printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "硬件类型    = '$hardware_type'" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

printf "\033[1;34m[INFO]\033[0m "
printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "芯片型号    = '$cpu_chip'" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

printf "\033[1;34m[INFO]\033[0m "
printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "存储容量    = '$storage_info'" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

printf "\033[1;34m[INFO]\033[0m "
printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
# 在 OS 行末尾附加版本号信息，以便显示但不影响平台键
if [ -n "$os_version" ]; then
    # 显示代号和版本号，避免影响平台键
    echo -e "OS 版本     = '$os_name / v$os_version' " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
else
    echo -e "OS 版本     = '$os_name'" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
fi

printf "\033[1;34m[INFO]\033[0m "
printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "硬件序列号  = '$hardware_sn'" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 计算机名称显示（检查是否一致）
if [ -n "$host_name" ] && [ "$computer_name" = "$host_name" ] && [ "$local_host_name" = "$host_name" ]; then
    printf "\033[1;34m[INFO]\033[0m "
    printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "计算机名称  = '$host_name'  ( HostName \ ComputerName \ LocalHostName )" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
else
    if [ -n "$host_name" ]; then
        if [ "$computer_name" != "$host_name" ]; then
            printf "\033[1;34m[INFO]\033[0m "
            printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
            echo -e "计算机名称  = '$computer_name'   （HostName = '$host_name'）" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        fi
        if [ "$local_host_name" != "$host_name" ]; then
            printf "\033[1;34m[INFO]\033[0m "
            printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
            echo -e "本地主机名称= '$local_host_name'   （HostName = '$host_name'）" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        fi
        if [ "$computer_name" != "$host_name" ] || [ "$local_host_name" != "$host_name" ]; then
            sudo $SUDO_N_FLAG scutil --set ComputerName "$host_name" > /dev/null 2>&1
            sudo $SUDO_N_FLAG scutil --set LocalHostName "$host_name" > /dev/null 2>&1
            sync_message="主机名称 已同步"
        fi
    else
        echo -e "\033[1;34m[WARN] ⚠️ HostName 未设置，无法同步 ComputerName 与 LocalHostName。请运行：sudo scutil --set HostName \"$local_host_name\" 后再执行脚本。 \033[0m" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        echo -e "[WARN] ⚠️ HostName 未设置，无法同步 ComputerName 与 LocalHostName。请运行：sudo scutil --set HostName \"$local_host_name\" 后再执行脚本。" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    fi
fi

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 打印软硬件检测完成 OK
echo -e "\033[1;36m[OK] 硬件检测 已完成\033[0m "
echo -e "[OK] 硬件检测 已完成" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

# 如果进行了主机名同步，则打印 OK 消息
if [ -n "$sync_message" ]; then
    echo -e "\033[1;36m[OK] $sync_message\033[0m "
    echo -e "[OK] $sync_message" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
fi

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# -----------------------------------------------
# 检查 ：工作目录（权限） 是否 正确分配
# -----------------------------------------------

echo -e "\033[1;36m-----------------------------------------------\033[0m" 
echo -e "\033[1;36m 检查 ：工作目录 & 权限            \033[0m"
echo -e "\033[1;36m-----------------------------------------------\033[0m" 

echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "检查 ：工作目录 & 权限            "                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

printf "\033[1;34m[INFO]\033[0m "
printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "根目录      = '$HOME'  (当前用户)" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

printf "\033[1;34m[INFO]\033[0m "
printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "工作目录    = '$(pwd)'  (当前脚本)" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

printf "\033[1;34m[INFO]\033[0m "
printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "当前用户    = '$USER'" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"


echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 切换工作目录
current_dir=$(pwd)
if [ "$HOME" != "$current_dir" ]; then
    cd "$HOME"
    echo -e "\033[1;36m[OK] 工作目录 已切换为 : '$(pwd)' \033[0m "
    echo -e "[OK] 工作目录 已切换为 : '$(pwd)' " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
else
    echo -e "\033[1;36m[OK] 工作目录 无需切换 \033[0m "
    echo -e "[OK] 工作目录 无需切换 " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
fi

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"



# -----------------------------------------------
# 检查 1 ：HomeBrew 是否安装（并更新）
# -----------------------------------------------

echo -e "\033[1;36m-----------------------------------------------\033[0m" 
echo -e "\033[1;36m 检测 “HomeBrew与系统架构” 是否匹配         \033[0m"
echo -e "\033[1;36m-----------------------------------------------\033[0m" 

echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "检测 “HomeBrew与系统架构” 是否匹配"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

# 检测系统架构

architecture=$(uname -m)

if [ "$architecture" = "arm64" ]; then

    # 检查 HomeBrew 是否已安装
    if ! command -v brew > /dev/null 2>&1 ; then

        printf  "\033[1;34m[INFO]\033[0m "
        printf  "[INFO] "                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "未检测到 HomeBrew，开始安装 HomeBrew ... "                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/HomeBrew/install/HEAD/install.sh)"
        
        # 添加 HomeBrew 到环境变量
        echo -e 'eval "$(/opt/homebrew/bin/brew shellenv)"' >> ~/.zprofile
        eval "$(/opt/homebrew/bin/brew shellenv)"
        
        printf  "\033[1;34m[INFO]\033[0m "
        printf  "[INFO] "                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "HomeBrew 安装完成。"                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        echo -e ""                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        exit 1

    fi

    # 获取 HomeBrew 的 安装路径
    brew_path=$(brew --prefix)
    printf  "\033[1;34m[INFO]\033[0m "
    printf  "[INFO] "                                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "HomeBrew目录 = '$brew_path'"                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 获取 CPU 的 处理器指令集
    cpu_isa=$(uname -m)
    printf  "\033[1;34m[INFO]\033[0m "
    printf  "[INFO] "                                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "CPU   指令集 = '$cpu_isa'"                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    if [[ $cpu_isa == "arm64" && $brew_path == "/opt/homebrew" ]]; then

        echo -e "\033[1;36m[OK] HomeBrew 无需更改  \033[0m"
        echo -e "[OK] HomeBrew 无需更改  "                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        # 更新 HomeBrew
        echo -e ""                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        echo -e ""                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

        echo -e "\033[1;36m-----------------------------------------------\033[0m" 
        echo -e "\033[1;36m 更新 HomeBrew 工具 \033[0m"
        echo -e "\033[1;36m-----------------------------------------------\033[0m" 

        echo -e "-------------------------------------------"                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "更新 HomeBrew 工具 "                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "-------------------------------------------"                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

        echo -e ""                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

        # 检查是否以 root 身份运行
        # 初始化退出码变量，用于统计 HomeBrew 更新和 analytics 操作的执行结果
        brew_update_rc=0
        brew_analytics_rc=0
        if [ "$(id -u)" -eq 0 ]; then
            # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
            targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
            echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 HomeBrew 自更新 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            # 以目标用户身份执行 HomeBrew 命令：更新索引
            sudo -n -H -u "$targetUser" brew update --force 2>&1 |
                tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            brew_update_rc=${PIPESTATUS[0]}
            # 关闭匿名使用统计，提升隐私
            echo -e "✓  设置 HomeBrew analytics off" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            sudo -n -H -u "$targetUser" brew analytics off 2>&1 |
                tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            brew_analytics_rc=${PIPESTATUS[0]}
           ## 执行 brew doctor 进行环境自检，不影响整体退出码
           #echo -e "✓  执行 brew doctor 自检" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
           #sudo -H -u "$targetUser" brew doctor || true                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        else
            echo -e "✓   当前用户'$USER'，为普通权限，直接运行 HomeBrew 自更新 ... "             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            brew update --force 2>&1 |
                tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            brew_update_rc=${PIPESTATUS[0]}
            # 关闭匿名使用统计，提升隐私
            echo -e "✓  设置 HomeBrew analytics off" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            brew analytics off 2>&1 |
                tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            brew_analytics_rc=${PIPESTATUS[0]}
           ## 执行 brew doctor 进行环境自检，不影响整体退出码
           #echo -e "✓  执行 brew doctor 自检" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
           #brew doctor || true                                                         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        fi

        echo -e ""  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

        # 根据更新和 analytics 的退出码输出总结信息
        if [ $brew_update_rc -eq 0 ] && [ $brew_analytics_rc -eq 0 ]; then
            echo -e '\033[1;36m[OK] 更新 HomeBrew 工具 已完成\033[0m '
            echo -e '[OK] 更新 HomeBrew 工具 已完成' | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        else
            echo -e '\033[1;31m[ERROR] 更新 HomeBrew 工具 失败 ❌\033[0m '
            echo -e '[ERROR] 更新 HomeBrew 工具 失败 ❌' | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        fi

       #exit 1

     elif [[ $cpu_isa == "arm64" && $brew_path == "/usr/local" ]]; then

        printf  "\033[1;31m[ERROR]\033[0m "
        printf  "[ERROR] "                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "检测到当前 HomeBrew 为 x86_64 版本，准备切换为 ARM 版本  ❌"           | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        
        # exit 1   # 调试使用！！！

        # 提示用户确认卸载 x86_64 版本的 HomeBrew
        #read -p "此操作将卸载 x86_64 版本的 HomeBrew，并安装 ARM 版本。是否继续？(y/N): " confirm
        #if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        #    print_info "取消操作。"
        #    exit 1
        #fi

        # 卸载 x86_64 版本的 HomeBrew
        echo -e "✓   正在卸载 x86_64 版本的 HomeBrew ... "                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/HomeBrew/install/HEAD/uninstall.sh)"                         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        
        # 安装 ARM 版本的 HomeBrew
        echo -e "✓   正在安装 ARM 版本的 HomeBrew ... "                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 非交互式安装
        NONINTERACTIVE=1 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/HomeBrew/install/HEAD/install.sh)"         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        
        # 添加 HomeBrew 到环境变量
        echo -e 'eval "$(/opt/homebrew/bin/brew shellenv)"' >> ~/.zprofile
        eval "$(/opt/homebrew/bin/brew shellenv)"
        
        echo -e "✓  ARM 版本的 HomeBrew 安装完成。"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

        # 获取 HomeBrew 的安装路径
        brew_newpath=$(which brew)
        echo -e "✓  检测到 HomeBrew 安装路径: $brew_newpath"                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        echo -e ""                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

        if [[ $brew_newpath == /opt/homebrew/* ]]; then
            printf  "\033[1;32m[OK]\033[0m "
            printf  "[OK]   "                                                           | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
            echo -e "验证结果：当前 HomeBrew 为 ARM 版本。"                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
           #echo -e ""                                                                  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        elif [[ $brew_newpath == /usr/local/* ]]; then
            printf  "\033[1;31m[ERROR]\033[0m "
            printf  "[ERROR] "                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
            echo -e "验证结果：检测到当前 HomeBrew 为 x86_64 版本。退出"                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
           #echo -e ""                                                                  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        else
            printf  "\033[1;31m[ERROR]\033[0m "
            printf  "[ERROR] "                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
            echo -e "验证结果：检测未知版本。退出"                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
           #echo -e ""                                                                  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        fi

    else

        print_error "未知的 HomeBrew 安装路径: $brew_path"                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
       #echo -e ""                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    fi

else

    printf "当前系统不是 ARM 架构 (Apple Silicon)，本脚本暂不支持。"                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
   #echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    exit 1 

fi

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 





# ------------------------------------------------
# 检查 2 ：其他HomeBrew工具 是否安装（并更新）
# ------------------------------------------------

# 调用检查时间范围函数
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

# 使用安全方式检查四个必备的 HomeBrew 工具（jq、coreutils、parallel、aria2）是否已安装。
# 当脚本以 root 身份运行时降权执行 brew list 以获取正确的安装列表；否则直接执行 brew list。
need_install_other_tools=false
brew_list_output=""
if [ "$(id -u)" -eq 0 ]; then
    targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
    brew_list_output=$(sudo -n -E -H -u "$targetUser" env PATH="/opt/homebrew/bin:/usr/local/bin:$PATH" brew list 2>/dev/null || true)
else
    brew_list_output=$(brew list 2>/dev/null || true)
fi
for tool in jq coreutils parallel aria2; do
    if ! echo "$brew_list_output" | grep -q "^${tool}$"; then
        need_install_other_tools=true
        break
    fi
done
if [ "$need_install_other_tools" = true ]; then
    echo -e ""                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    echo -e "\033[1;36m-----------------------------------------------\033[0m"
    echo -e "\033[1;36m 安装 其他必备工具 \033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m"

    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "安装 其他必备工具 "                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
fi

# 定义辅助函数：根据安装列表决定是否执行 brew install
install_if_missing() {
    local pkg="$1"
    local list="$2"
    if echo "$list" | grep -q "^${pkg}$"; then
        return 0
    fi
    # 输出安装提示
    printf  "\033[1;34m[INFO]\033[0m "
    echo -e "[安装] $pkg ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 根据权限执行安装
    if [ "$(id -u)" -eq 0 ]; then
        targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        sudo -n -E -H -u "$targetUser" env PATH="/opt/homebrew/bin:/usr/local/bin:$PATH" brew install "$pkg" 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    else
        brew install "$pkg" 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    fi
    echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
}

# 逐个检查并安装工具
install_if_missing "aria2" "$brew_list_output"
install_if_missing "parallel" "$brew_list_output"
install_if_missing "coreutils" "$brew_list_output"
install_if_missing "jq" "$brew_list_output"

# 检查并安装 buo/cask-upgrade tap
taps_output=""
if [ "$(id -u)" -eq 0 ]; then
    taps_output=$(sudo -n -E -H -u "$targetUser" env PATH="/opt/homebrew/bin:/usr/local/bin:$PATH" brew tap 2>/dev/null || true)
else
    taps_output=$(brew tap 2>/dev/null || true)
fi
if ! echo "$taps_output" | grep -q '^buo/cask-upgrade$'; then
    printf  "\033[1;34m[INFO]\033[0m "
    echo -e "[安装] buo/cask-upgrad ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    if [ "$(id -u)" -eq 0 ]; then
        sudo -n -E -H -u "$targetUser" env PATH="/opt/homebrew/bin:/usr/local/bin:$PATH" brew tap buo/cask-upgrade 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    else
        brew tap buo/cask-upgrade 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    fi
    echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
fi



# -----------------------------------------------
# 检查 3 ：MAS 是否安装（并更新）
# -----------------------------------------------

# 调用检查时间范围函数
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

# 判断 mas 是否已安装：在 root 环境降权执行 brew list --formula
mas_installed=false
{
    mas_list_output=""
    if [ "$(id -u)" -eq 0 ]; then
        mas_targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        mas_list_output=$(sudo -n -E -H -u "$mas_targetUser" env PATH="/opt/homebrew/bin:/usr/local/bin:$PATH" brew list --formula 2>/dev/null || true)
    else
        mas_list_output=$(brew list --formula 2>/dev/null || true)
    fi
    if echo "$mas_list_output" | grep -q '^mas$'; then
        mas_installed=true
    fi
}

if [ "$mas_installed" = true ]; then

    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "\033[1;36m 更新 MAS 工具 \033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 

    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "更新 MAS 工具"                                                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    # 检查是否以 root 身份运行
    mas_update_rc=0
    if [ "$(id -u)" -eq 0 ]; then
        # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
        targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 MAS 自更新 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 以目标用户身份执行 HomeBrew 命令
        sudo -n -H -u "$targetUser" brew upgrade mas 2>&1 |
            tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        mas_update_rc=${PIPESTATUS[0]}
    else
        echo -e "✓  当前用户'$USER'，为普通权限，直接运行 MAS 自更新 ... "            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        brew upgrade mas 2>&1 |
            tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        mas_update_rc=${PIPESTATUS[0]}
    fi

    echo -e  "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 输出 MAS 更新结果：只有当更新命令返回 0 时标记为成功
    if [ $mas_update_rc -eq 0 ]; then
        # 打印绿色 [OK] 提示（彩色输出仅在控制台显示）
        echo -e  '\033[1;36m[OK] 更新 MAS 工具 已完成\033[0m '
        # 在日志中记录 [OK] 状态但不重复显示到控制台
        echo -e  '[OK] 更新 MAS 工具 已完成' | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    else
        # 打印红色 [ERROR] 提示（彩色输出仅在控制台显示）
        echo -e  '\033[1;31m[ERROR] 更新 MAS 工具 失败 ❌\033[0m '
        # 在日志中记录 [ERROR] 状态但不重复显示到控制台
        echo -e  '[ERROR] 更新 MAS 工具 失败 ❌' | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    fi

else

    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "\033[1;36m MAS 未安装，开始安装 \033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "MAS 未安装，开始安装"                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

    # 检查是否以 root 身份运行
    if [ "$(id -u)" -eq 0 ]; then
        # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
        targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 MAS 安装 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 以目标用户身份执行 HomeBrew 命令
        sudo -n -H -u "$targetUser" bash -c 'brew reinstall --force mas 2>&1'              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    else
        echo -e "✓  当前用户'$USER'，为普通权限，直接运行 MAS 安装 ... "                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        brew reinstall --force mas 2>&1                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    fi

    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    if [ $? -eq 0 ]; then
        echo -e "MAS 安装成功。"                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    else
        echo -e "MAS 安装失败。"                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    fi

fi

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 





# -----------------------------------------------
# 检查 4 ：MacPorts 是否安装（并更新）
# -----------------------------------------------

# 调用检查时间范围函数
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

if command -v /opt/local/bin/port >/dev/null 2>&1; then

    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "\033[1;36m 更新 MacPorts 工具 \033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "-------------------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "更新 MacPorts 工具  "       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "-------------------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e ""                         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 保证 CLT 收据存在，否则跳过 MacPorts 更新
    macports_update_rc=0
    if ensure_clt_or_skip_macports; then
        echo -e "✓  使用Root权限(sudo命令), 运行 MacPorts 自更新 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # MacPorts 基础更新：仅运行自更新以更新 MacPorts base 和 ports 树
        sudo $SUDO_N_FLAG /opt/local/bin/port selfupdate 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        macports_update_rc=${PIPESTATUS[0]}
    fi
    # 输出 MacPorts 更新结果（即便没有执行更新，也视为成功）。

    echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 仅当自更新命令返回 0 时视为成功，其余情况标记为错误。
    if [ $macports_update_rc -eq 0 ]; then
        # 打印绿色 [OK] 提示
        echo -e '\033[1;36m[OK] 更新 MacPorts 工具 已完成\033[0m '
        # 在日志中记录 [OK]
        echo -e '[OK] 更新 MacPorts 工具 已完成' | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    else
        # 打印红色 [ERROR] 提示
        echo -e  '\033[1;31m[ERROR] 更新 MacPorts 工具 失败 ❌\033[0m '
        # 在日志中记录 [ERROR]
        echo -e  '[ERROR] 更新 MacPorts 工具 失败 ❌' | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    fi

else
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "\033[1;36m MacPorts 未安装，开始安装 \033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "-------------------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "MacPorts 未安装，开始安装  "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "-------------------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null


    if ensure_clt_or_skip_macports; then
        macos_version=$(sw_vers -productVersion)
        major_version=${macos_version%%.*}

        license_file="/System/Library/CoreServices/Setup Assistant.app/Contents/Resources/en.lproj/OSXSoftwareLicense.rtf"
        raw_codename=$(awk -F 'macOS ' '/SOFTWARE LICENSE AGREEMENT FOR macOS/ {print $NF}' "$license_file" \
                        | sed -E 's/[[:punct:]]*$//' | sed -E 's/[0-9].*$//' | tr '[:upper:]' '[:lower:]' | xargs)
        codename_camel=$(echo "$raw_codename" | awk '{for(i=1;i<=NF;i++){printf toupper(substr($i,1,1)) substr($i,2)}}')

        latest_version=$(curl -s https://api.github.com/repos/macports/macports-base/releases/latest \
                         | sed -n 's/.*\"tag_name\": \"v\\([0-9.]*\\)\".*/\\1/p')
        [ -z "$latest_version" ] && latest_version="2.11.5"

        pkg_name="MacPorts-${latest_version}-${major_version}-${codename_camel}.pkg"
        pkg_url="https://github.com/macports/macports-base/releases/download/v${latest_version}/${pkg_name}"
        echo "准备安装 MacPorts，下载地址：$pkg_url"

        curl -L -o /tmp/macports.pkg "$pkg_url" && \
        sudo $SUDO_N_FLAG /usr/sbin/installer -pkg /tmp/macports.pkg -target / && \
        /bin/rm -f /tmp/macports.pkg
    fi

fi


echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 







# -----------------------------------------------
# 检查 5 ：TopGrade 是否安装（并更新）
# -----------------------------------------------


# 调用检查时间范围函数
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

# 判断 TopGrade 是否已安装：在 root 环境降权执行 brew list --formula
topgrade_installed=false
{
    tg_list_output=""
    if [ "$(id -u)" -eq 0 ]; then
        tg_targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        tg_list_output=$(sudo -n -E -H -u "$tg_targetUser" env PATH="/opt/homebrew/bin:/usr/local/bin:$PATH" brew list --formula 2>/dev/null || true)
    else
        tg_list_output=$(brew list --formula 2>/dev/null || true)
    fi
    if echo "$tg_list_output" | grep -q '^topgrade$'; then
        topgrade_installed=true
    fi
}

if [ "$topgrade_installed" = true ]; then

    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "\033[1;36m 更新 TopGrade 工具 \033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "更新 TopGrade 工具"                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    # 检查是否以 root 身份运行
    topgrade_update_rc=0
    if [ "$(id -u)" -eq 0 ]; then
        # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
        targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 TopGrade 自更新 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 以目标用户身份执行 HomeBrew 命令
        sudo -n -H -u "$targetUser" brew upgrade --greedy --force topgrade 2>&1 |
            tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        topgrade_update_rc=${PIPESTATUS[0]}
    else
        echo -e "✓  当前用户'$USER'，为普通权限，直接运行 TopGrade 自更新 ... "       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        brew upgrade --greedy --force topgrade 2>&1 |
            tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        topgrade_update_rc=${PIPESTATUS[0]}
    fi
    
    echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    
    # 输出 TopGrade 更新结果：成功或失败
    if [ $topgrade_update_rc -eq 0 ]; then
        # 打印绿色 [OK] 提示
        echo -e '\033[1;36m[OK] 更新 TopGrade 工具 已完成\033[0m '
        # 在日志中记录 [OK] 状态
        echo -e '[OK] 更新 TopGrade 工具 已完成' | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    else
        # 打印红色 [ERROR] 提示
        echo -e '\033[1;31m[ERROR] 更新 TopGrade 工具 失败 ❌\033[0m '
        # 在日志中记录 [ERROR] 状态
        echo -e '[ERROR] 更新 TopGrade 工具 失败 ❌' | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    fi

else

    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "\033[1;36m TopGrade 未安装，开始安装 \033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "TopGrade 未安装，开始安装"                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    # 检查是否以 root 身份运行
    if [ "$(id -u)" -eq 0 ]; then
        # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
        targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 topgrade 安装 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 以目标用户身份执行 HomeBrew 命令
        sudo -n -H -u "$targetUser" bash -c 'brew reinstall --force topgrade 2>&1'         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    else
        echo -e "✓  当前用户'$USER'，为普通权限，直接运行 topgrade 安装 ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        brew reinstall --force topgrade 2>&1                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    fi
    
    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    if [ $? -eq 0 ]; then
        echo -e "✅ TopGrade 安装成功。"                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        echo -e ""                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    else
        echo -e "❌ TopGrade 安装失败。"                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    fi

fi

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 




# ------------------------------------------------
# 检查 6 ：MacUpdater 是否安装（并更新）
# ------------------------------------------------


# 调用检查时间范围函数
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

# 判断 MacUpdater 是否已安装：在 root 环境降权执行 brew list --cask
macupdater_installed=false
{
    mu_list_output=""
    if [ "$(id -u)" -eq 0 ]; then
        mu_targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        mu_list_output=$(sudo -n -E -H -u "$mu_targetUser" env PATH="/opt/homebrew/bin:/usr/local/bin:$PATH" brew list --cask 2>/dev/null || true)
    else
        mu_list_output=$(brew list --cask 2>/dev/null || true)
    fi
    if echo "$mu_list_output" | grep -q '^macupdater$'; then
        macupdater_installed=true
    fi
}

if [ "$macupdater_installed" = true ]; then
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "\033[1;36m 更新 MacUpdater 工具 \033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "更新 MacUpdater 工具"                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
    # 检查是否以 root 身份运行
    macupdater_update_rc=0
    if [ "$(id -u)" -eq 0 ]; then
        # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
        targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 MacUpdater 自更新 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 以目标用户身份执行 HomeBrew 命令，并显式传递语言配置
        sudo -n -H -u "$targetUser" env HOMEBREW_CASK_OPTS="$HOMEBREW_CASK_OPTS" brew upgrade --greedy --cask macupdater 2>&1 |
            tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        macupdater_update_rc=${PIPESTATUS[0]}
    else
        echo -e "✓  当前用户'$USER'，为普通权限，直接运行 MacUpdater 自更新 ... "     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        env HOMEBREW_CASK_OPTS="$HOMEBREW_CASK_OPTS" brew upgrade --greedy --cask macupdater 2>&1 |
            tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        macupdater_update_rc=${PIPESTATUS[0]}
    fi

    echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 输出 MacUpdater 更新结果：成功或失败
    if [ $macupdater_update_rc -eq 0 ]; then
        # 打印绿色 [OK] 提示
        echo -e '\033[1;36m[OK] 更新 MacUpdater 工具 已完成\033[0m '
        # 在日志中记录 [OK] 状态
        echo -e '[OK] 更新 MacUpdater 工具 已完成' | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    else
        # 打印红色 [ERROR] 提示
        echo -e '\033[1;31m[ERROR] 更新 MacUpdater 工具 失败 ❌\033[0m '
        # 在日志中记录 [ERROR] 状态
        echo -e '[ERROR] 更新 MacUpdater 工具 失败 ❌' | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    fi

else

    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "\033[1;36m MacUpdater 未安装，开始安装 \033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "MacUpdater 未安装，开始安装 "                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    
    # 检查是否以 root 身份运行
    if [ "$(id -u)" -eq 0 ]; then
        # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
        targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 MacUpdater 安装 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 以目标用户身份执行 HomeBrew 命令
        # 显式传递语言配置，避免 sudo 环境丢失 HOMEBREW_CASK_OPTS
        sudo -n -H -u "$targetUser" env HOMEBREW_CASK_OPTS="$HOMEBREW_CASK_OPTS" brew reinstall --cask --force macupdater 2>&1       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    else
        echo -e "✓  当前用户'$USER'，为普通权限，直接运行 MacUpdater 安装 ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        env HOMEBREW_CASK_OPTS="$HOMEBREW_CASK_OPTS" brew reinstall --cask --force macupdater 2>&1                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    fi
    
    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    if [ $? -eq 0 ]; then
        echo -e "✅ MacUpdater 安装成功。"                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        echo -e ""                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    else
        echo -e "❌ MacUpdater 安装失败。"                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    fi
fi

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
#echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 



# ----------------------------------
# 记录：开始时间
# ----------------------------------

# 等待3秒，开始执行
#sleep 3  

# 记录当前时间戳（到$LOG_FILE）
echo -e "-------------------------------------------------"                             | tee -a "$LOG_FILE"  > /dev/null
echo -e "开始更新 APP: $(date)"                                                         | tee -a "$LOG_FILE"  > /dev/null


# 记录当前时间戳（到$$LOG_FULL_FILE），
echo -e  ""                                                                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

echo -e "\033[1;34m-----------------------------------------------\033[0m" 
echo -e "\033[1;34m 开始更新 APP: $(date)                         \033[0m"
echo -e "\033[1;34m-----------------------------------------------\033[0m" 
echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "开始更新 APP: $(date)"                                                         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

echo -e  ""                                                                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e  ""                                                                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"




# 此后，开始升级第三方APP！！！！！！此前都是在，检测环境 和更新 升级程序本身。



# -----------------------------------------------
# 在更新操作前：备份桌启动台布局（LaunchPad）
# -----------------------------------------------

echo -e "\033[1;32m-----------------------------------------------\033[0m" 
echo -e "\033[1;32m 备份 启动台布局（LaunchPad）                    \033[0m"
echo -e "\033[1;32m-----------------------------------------------\033[0m" 

echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "备份 启动台布局（LaunchPad）"                                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null


echo -e ""                                                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

# 备份 LaunchPad 和 启动台布局

if [ "$(id -u)" -eq 0 ]; then

    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 获取启动台布局 所需的 \$targetUser 与 路径 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 获取目标普通用户（优先用 SUDO_USER，否则取当前控制台登录用户）
    targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
    targetHome=$(eval echo -e "~$targetUser")    # 目标用户的 $HOME
    USER_NAME="$targetUser"
    HOME="$targetHome"                        # 覆盖当前shell的HOME

    # 获取目标用户的 TMPDIR 路径（使用 getconf）
userTmpDir=$(sudo -n -H -u "$targetUser" getconf DARWIN_USER_TEMP_DIR)
    userTmpDir="${userTmpDir%/}"                        # 移除末尾斜杠，标准化路径

else

    echo -e "✓  当前用户'$USER'，为普通权限，直接运行 获取 启动台布局 所需的 \$TMPDIR \$TMPDIR ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    USER_NAME="$USER"
    userTmpDir="$TMPDIR"

fi

# 记录目标用户及其TMPDIR路径到日志
echo -e "活跃用户 = $USER_NAME " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e "用户路径 = $userTmpDir" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# USER_ID=$(basename "$(dirname "$userTmpDir")")      # 提取TMPDIR路径中的随机目录ID
# PARENT_DIR=$(find /System/Volumes/Data/private/var/folders/ -maxdepth 2 -type d -name "$USER_ID" -print -quit 2>/dev/null)
# BACKUP_PATH="$ICLOUD_PATH/BACKUP/$COMPUTER_NAME/$USER_NAME"
# BACKUP_DATE=$(date +%Y-%m-%d)
# PATH_DesktopLayout_BACKUP="$BACKUP_PATH/DesktopLayout/$BACKUP_DATE"

USER_ID=$(basename "$(dirname "$userTmpDir")")      # 提取TMPDIR路径中的随机目录ID
PARENT_DIR=$(find /System/Volumes/Data/private/var/folders/ -maxdepth 2 -type d -name "$USER_ID" -print -quit 2>/dev/null)
# 根据新的目录规则生成 BACKUP 路径。以设备标识目录（型号名称-芯片名称-序列号）为基础，并包含用户名目录。
BACKUP_BASE="$ICLOUD_PATH/BACKUP/${DEVICE_DIR}"
# 如果 BACKUP_BASE 末尾已包含用户名，则不再追加；否则追加用户名目录。
if [[ "$BACKUP_BASE" == */"$USER_NAME" ]]; then
    BACKUP_PATH="$BACKUP_BASE"
else
    BACKUP_PATH="$BACKUP_BASE/$USER_NAME"
fi
BACKUP_DATE=$(date +%Y-%m-%d)
PATH_DesktopLayout_BACKUP="$BACKUP_PATH/DesktopLayout/$BACKUP_DATE"


# LaunchPad plist 位于 Library/Preferences
PATH_DesktopLayout_plist_SOURCE="$HOME/Library/Preferences"
# LaunchPad DB 位于 PARENT_DIR/0/com.apple.dock.launchpad/db/db
PATH_DesktopLayout_db_SOURCE="$PARENT_DIR/0"

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

printf  "\033[1;34m[Info]\033[0m "
printf  "[Info] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "启动台布局 备份路径：'$PATH_DesktopLayout_BACKUP'"                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

printf  "\033[1;34m[Info]\033[0m "
printf  "[Info] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "启动台布局 恢复路径: '$PATH_DesktopLayout_db_SOURCE'"                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

mkdir -p "$PATH_DesktopLayout_BACKUP"
errorFlag=0  # 初始化错误标志

# 备份 com.apple.spaces.plist
cp -rf "$PATH_DesktopLayout_plist_SOURCE/com.apple.spaces.plist" "$PATH_DesktopLayout_BACKUP/"
if [ $? -ne 0 ]; then
    echo -e "\033[1;33m[Warn]   com.apple.spaces.plist 备份失败 ⚠️ \033[0m"
    echo -e "[Warn]   com.apple.spaces.plist 备份失败 ⚠️ " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    errorFlag=1
fi

# 备份 com.apple.dock.plist
cp -rf "$PATH_DesktopLayout_plist_SOURCE/com.apple.dock.plist" "$PATH_DesktopLayout_BACKUP/"
if [ $? -ne 0 ]; then
    echo -e "\033[1;33m[Warn]   com.apple.dock.plist 备份失败 ⚠️ \033[0m"
    echo -e "[Warn]   com.apple.dock.plist 备份失败 ⚠️ " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    errorFlag=1
fi

# 备份 LaunchPad 数据库目录
sudo $SUDO_N_FLAG cp -rf "$PATH_DesktopLayout_db_SOURCE/com.apple.dock.launchpad" "$PATH_DesktopLayout_BACKUP/"
if [ $? -ne 0 ]; then
    echo -e "\033[1;33m[Warn]   com.apple.dock.launchpad 目录备份失败 ⚠️ \033[0m"
    echo -e "[Warn]   com.apple.dock.launchpad 目录备份失败 ⚠️ " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    errorFlag=1
fi

# 设置权限（如有需要也可检查 chmod 的返回码）
cd "$PATH_DesktopLayout_BACKUP"
    # 对 LaunchPad 数据目录设置权限。若脚本以 root 身份运行，则附加
    # SUDO_N_FLAG（-n）以避免在后台执行时等待输入；若为普通用户，则不传递 -n
    sudo $SUDO_N_FLAG chmod -R 755 "./com.apple.dock.launchpad"

echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 根据 errorFlag 输出最终结果
if [ $errorFlag -eq 0 ]; then
    echo -e "\033[1;32m[OK] 备份 启动台布局  运行已完成 ✅ \033[0m"
    echo -e "[OK]   备份 启动台布局  运行已完成 ✅ " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
else
    echo -e "\033[1;33m[Warn] 备份 启动台布局  运行已完成，但部分项目失败 ⚠️ \033[0m"
    echo -e "[Warn]   启动台布局 备份完成，但部分项目失败 ⚠️ " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
fi

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 










# ----------------------------------
# 开始执行：HomeBrew
# ----------------------------------

export HOMEBREW_NO_INTERACTIVE=1

echo -e "\033[1;32m-----------------------------------------------\033[0m" 
echo -e "\033[1;32m 运行 HomeBrew                             \033[0m"
echo -e "\033[1;32m-----------------------------------------------\033[0m" 

echo -e "-------------------------------------------"                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "运行 HomeBrew"                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------"                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null


# 等待3秒，开始执行
#sleep 3  

# 调用检查时间范围函数
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

echo -e ""                                                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

printf  "\033[1;34m[List]\033[0m "
printf  "[List] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "HomeBrew 应用列表 ... "                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
#( brew upgrade --debug --verbose --greedy )

# 检查是否以 root 身份运行
if [ "$(id -u)" -eq 0 ]; then

    # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
    targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 brew list ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 4️⃣ 所有项目（公式 + Cask）
brew_formula_count=$(sudo -n -H -u "$targetUser" bash -lc 'brew list --formula -1 | wc -l' )
brew_cask_count=$(sudo -n -H -u "$targetUser" bash -lc 'brew list --cask -1 | wc -l' )

else

    echo -e "✓  当前用户'$USER'，为普通权限，直接运行 brew list ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    # 所有项目（公式 + Cask）
    brew_formula_count=$(brew list --formula -1 | wc -l)
    brew_cask_count=$(brew list --cask -1 | wc -l)

fi


# 计算 APP 数量（假设 brew_installed_apps 是 brew list 的正常输出）
brew_cask_count=$((( brew_cask_count * 2 ) /2 ))
brew_formula_count=$((( brew_formula_count *2 ) /2 ))
brew_app_count=$(( brew_formula_count + brew_cask_count ))
echo -e "✅  APP 数量（ HomeBrew Formula ）：$brew_formula_count  "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e "✅  APP 数量（ HomeBrew Cask    ）：$brew_cask_count  "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e "✅  APP 数量（ HomeBrew         ）：$brew_app_count  "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"


echo -e ""                                                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 


printf  "\033[1;34m[Scan]\033[0m "
printf  "[Scan] "                                                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "HomeBrew 扫描更新 ... "                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

if [ "$(id -u)" -eq 0 ]; then
  targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
  echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 brew outdated --greedy ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
  brew_outdated=$(
    sudo -n -H -u "$targetUser" bash -lc 'brew outdated --greedy' 2>/dev/null | awk '{print $1}'
  )
  brew_outdated_formulas=$(
    sudo -n -H -u "$targetUser" bash -lc 'brew outdated --formula --greedy' 2>/dev/null | awk '{print $1}'
  )
  brew_outdated_casks=$(
    sudo -n -H -u "$targetUser" bash -lc 'brew outdated --cask --greedy' 2>/dev/null | awk '{print $1}'
  )
else
  echo -e "✓  当前用户'$USER'，为普通权限，直接运行 brew outdated --greedy ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
  brew_outdated=$(
    brew outdated --greedy 2>/dev/null | awk '{print $1}'
  )
  brew_outdated_formulas=$(
    brew outdated --formula --greedy 2>/dev/null | awk '{print $1}'
  )
  brew_outdated_casks=$(
    brew outdated --cask --greedy 2>/dev/null | awk '{print $1}'
  )
fi

# 兼容 bash 3.2：逐行构建数组（避免 read -a 只读到第一行）
packages_brew=()
while IFS= read -r pkg; do
  [[ -n "$pkg" ]] && packages_brew+=("$pkg")
done <<< "$brew_outdated"

packages_brew_formulas=()
while IFS= read -r pkg; do
  [[ -n "$pkg" ]] && packages_brew_formulas+=("$pkg")
done <<< "$brew_outdated_formulas"

packages_brew_casks=()
while IFS= read -r pkg; do
  [[ -n "$pkg" ]] && packages_brew_casks+=("$pkg")
done <<< "$brew_outdated_casks"

# 分类打印（先判定 cask，再判定 formula）
for pkg in "${packages_brew[@]}"; do
  if printf '%s\n' "${packages_brew_casks[@]}"     | grep -qxF -- "$pkg"; then
    echo -e "✅  检测到新版本 [cask]    : $pkg"   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
  elif printf '%s\n' "${packages_brew_formulas[@]}" | grep -qxF -- "$pkg"; then
    echo -e "✅  检测到新版本 [formula] : $pkg" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
  else
    echo -e "✅  检测到新版本 [unknown] : $pkg" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
  fi
done



# 在获取 brew_outdated 列表并组装 packages_brew_formulas/casks 之后添加：
updated_list=()   # 初始化数组，用于保存每个更新项的结果

# 如果有需要更新的 HomeBrew 软件包，则执行下载
if [ ${#packages_brew[@]} -ne 0 ]; then

    echo -e ""                                                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 第 2 步：并行下载（提高下载速度）
    printf "\033[1;34m[Download]\033[0m "
    printf "[Download] "                                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "开始下载：HomeBrew Formula / Cask（ 并行 ） ... "                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 构造平台键：Apple Silicon 带前缀，Intel 不带前缀
    platform_key=""
    if [ -n "$os_name" ]; then
      if [ "$cpu_isa" = "arm64" ]; then
        platform_key="${cpu_isa}_${os_name}"   # 例如 "arm64_sonoma"
      else
        platform_key="$os_name"            # 例如 "sonoma"
      fi
    fi



    # 筛选需要下载的 formula 软件包：如果缓存中已有完整的新版本则跳过
    packages_to_fetch_formulas=()
    for pkg_brew_formula in "${packages_brew_formulas[@]}"; do

        [[ -z "$pkg_brew_formula" ]] && continue  # 跳过空名称项（以防万一）

        #brew_cache_path=$(brew --cache --formula "$pkg_brew_formula")
        # 获取 HomeBrew 缓存包路径（在 Root 权限下通过目标用户环境获取正确路径）
        if [ "$(id -u)" -eq 0 ]; then
            targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
            brew_cache_path=$(sudo -n -H -u "$targetUser" /bin/bash -lc "brew --cache --formula \"$pkg_brew_formula\"" 2>/dev/null)
        else
            brew_cache_path=$(brew --cache --formula "$pkg_brew_formula")
        fi
        #echo -e "brew_cache_path = $brew_cache_path"                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        
        if [ -f "$brew_cache_path" ]; then
            ################################################################
            # 修正：brew --cache 可能返回 bottle_manifest.json 路径，这不是实际瓶子文件
            # manifest 与真正的 .bottle.tar.gz 文件的 SHA256 不一致，导致误判
            # 如果检测到 manifest 文件，则尝试在同目录寻找匹配包名的 .bottle*.tar.gz 文件
            ################################################################
            if [[ "$brew_cache_path" == *.bottle_manifest.json ]]; then
                cache_dir="$(dirname "$brew_cache_path")"
                # 使用通配符查找匹配的瓶子文件
                candidate=""
                for f in "$cache_dir"/*"${pkg_brew_formula}"*.bottle*.tar.gz; do
                    # 只取第一个匹配
                    candidate="$f"
                    break
                done
                if [ -n "$candidate" ] && [ -f "$candidate" ]; then
                    brew_cache_path="$candidate"
                fi
            fi
            local_sha=$(shasum -a 256 "$brew_cache_path" | awk '{print $1}')
            ############################################
            # 计算 brew_expected_sha —— 自动降权 + 双日志输出
            ############################################
            if [ "$(id -u)" -eq 0 ]; then
                # 1. 解析目标普通用户（Lingon 经 sudo 调用时 SUDO_USER 存在）
                targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"

                # 2. 日志提示
                echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_formula 的 SHA256 查询 ... " \
                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

                # 3. 在目标用户登录环境中执行 brew info 获取 JSON
                json=$(sudo -n -H -u "$targetUser" /bin/bash -lc "brew info --json=v2 \"$pkg_brew_formula\"" 2>/dev/null)
            else
                # ------- 已是普通用户 -------
                echo -e "✓  当前用户'$USER'，为普通权限，直接运行 $pkg_brew_formula 的 SHA256 查询 ... " \
                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

                # 在当前用户环境中执行 brew info 获取 JSON
                json=$(brew info --json=v2 "$pkg_brew_formula" 2>/dev/null)
            fi

            # 提取对应的 SHA256（优先当前平台的 bottle，其次通用 bottle，最后源码 checksum）
            brew_expected_sha=""
            if [ -n "$json" ]; then
                if [ -n "$platform_key" ]; then
                    brew_expected_sha=$(/usr/bin/plutil -extract "formulae.0.bottle.stable.files.${platform_key}.sha256" \
                                 raw -o - - <<< "$json" 2>/dev/null)
                fi
                if [ -z "$brew_expected_sha" ]; then
                    brew_expected_sha=$(/usr/bin/plutil -extract "formulae.0.bottle.stable.files.all.sha256" \
                                 raw -o - - <<< "$json" 2>/dev/null)
                fi
                if [ -z "$brew_expected_sha" ]; then
                    brew_expected_sha=$(/usr/bin/plutil -extract "formulae.0.urls.stable.checksum" \
                                 raw -o - - <<< "$json" 2>/dev/null)
                fi
            fi

            if [ -n "$brew_expected_sha" ] && [ "$local_sha" = "$brew_expected_sha" ]; then
                echo -e "✅  [已缓存] 最新版 ｜ SHA256 ：$brew_expected_sha ｜ [formula] ：$pkg_brew_formula  "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                continue  # 略过重新下载
            else
                echo -e "⚠️  [SHA256异常] $pkg_brew_formula [formula]" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                echo -e "   -  已下载包 ：$local_sha "    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                echo -e "   -  homebrew ：$brew_expected_sha " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            fi
        fi

        packages_to_fetch_formulas+=("$pkg_brew_formula")

    done


    # 筛选需要下载的 cask 软件包：如果缓存中已有完整的新版本则跳过
    packages_to_fetch_casks=()
    for pkg_brew_cask in "${packages_brew_casks[@]}"; do

        [[ -z "$pkg_brew_cask" ]] && continue  # 跳过空名称项

        #brew_cache_path=$(brew --cache --cask "$pkg_brew_cask")
        # 获取 HomeBrew 缓存包路径（在 Root 权限下通过目标用户环境获取正确路径）
        if [ "$(id -u)" -eq 0 ]; then
            targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
            brew_cache_path=$(sudo -n -H -u "$targetUser" /bin/bash -lc "brew --cache --cask \"$pkg_brew_cask\"" 2>/dev/null)
        else
            brew_cache_path=$(brew --cache --cask "$pkg_brew_cask")
        fi
        #echo -e "brew_cache_path = $brew_cache_path"                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

        if [ -f "$brew_cache_path" ]; then
            local_sha=$(shasum -a 256 "$brew_cache_path" | awk '{print $1}')
            ############################################
            # 计算 brew_expected_sha —— 自动降权 + 双日志输出
            ############################################
            if [ "$(id -u)" -eq 0 ]; then
                # 1. 解析目标普通用户（Lingon 经 sudo 调用时 SUDO_USER 存在）
                targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"

                # 2. 日志提示
                echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_cask 的 SHA256 查询 ... " \
                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

                # 3. 在目标用户登录环境中执行 brew info 获取 JSON
                json=$(sudo -n -H -u "$targetUser" /bin/bash -lc "brew info --json=v2 \"$pkg_brew_cask\"" 2>/dev/null)
            else
                # ------- 已是普通用户 -------
                echo -e "✓  当前用户'$USER'，为普通权限，直接运行 $pkg_brew_cask 的 SHA256 查询 ... "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

                # 在当前用户环境中执行 brew info 获取 JSON
                json=$(brew info --json=v2 "$pkg_brew_cask" 2>/dev/null)
            fi

            # 提取 cask 的 SHA256（某些 cask 可能无 SHA 信息，例如 :latest 或 auto_updates）
            brew_expected_sha=""
            if [ -n "$json" ]; then
                brew_expected_sha=$(/usr/bin/plutil -extract "casks.0.sha256" raw -o - - <<< "$json" 2>/dev/null)
            fi

            # 处理 cask 的 SHA256: 如果为 null/no_check 或为空，则认为无需校验
            if [[ "$brew_expected_sha" == "null" || -z "$brew_expected_sha" || "$brew_expected_sha" == "no_check" ]]; then
                echo -e "✅  [已缓存] 无校验版 ｜ [cask] ：：$pkg_brew_cask " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                continue
            fi
            if [ "$local_sha" = "$brew_expected_sha" ]; then
                echo -e "✅  [已缓存] 最新版 ｜ SHA256 ：$brew_expected_sha ｜    [cask] ：$pkg_brew_cask  "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                continue
            fi
        fi

        packages_to_fetch_casks+=("$pkg_brew_cask")

    done



    # 并行下载需要更新的 formula 和 cask（使用 --retry 自动校验缓存有效性） 注意，与 下面的 parallel 方案 二选一。建议使用Parallel，因为速度更快。
    # printf '%s\n' "${packages_to_fetch_formulas[@]}" | xargs -n1 -P16 brew fetch --formula --retry         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # printf '%s\n' "${packages_to_fetch_casks[@]}"    | xargs -n1 -P8 brew fetch --cask --retry             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 确保 GNU Parallel 已安装（macOS 可通过 HomeBrew 安装）
    if ! command -v parallel &>/dev/null; then

          # 安装 GNU Parallel 并行执行工具 [oai_citation:3‡formulae.brew.sh](https://formulae.brew.sh/formula/parallel#:~:text=Install%20command%3A)
          # 检查是否以 root 身份运行
          if [ "$(id -u)" -eq 0 ]; then
              # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
              targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
              echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 parallel 安装 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
              # 以目标用户身份执行 HomeBrew 命令
              sudo -n -H -u "$targetUser" bash -c 'brew reinstall --force parallel 2>&1'         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
          else
              echo -e "✓  当前用户'$USER'，为普通权限，直接运行 parallel 安装 ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
              brew reinstall --force parallel 2>&1                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
          fi

    fi

    # run_as_normal_user 和 maybe_run_as_normal_user 的定义已移动到脚本的顶层，避免在使用前未定义。
    export LOG_FULL_LAST LOG_FULL_FILE   # 让 sudo -E 能继承日志路径

    # -----------------------------------------------------------------------------
    # 新增：定义下载函数用于并行下载 formula 和 cask，支持重试并记录失败链接
    #
    # 这两个函数会被 GNU parallel 调用以下载对应的软件包。当下载失败时，会按
    # DOWNLOAD_MAX_RETRIES 指定的次数进行重试，并在最终失败时把包名和
    # 下载链接追加写入失败记录文件，供后续安装阶段判断是否跳过升级。
    fetch_brew_formula() {
        local pkg="$1"
        local success=0
        local tmpfile
        tmpfile=$(mktemp)
        # 下载失败重试次数与校验失败重试次数
        local max_download_retry=${DOWNLOAD_MAX_RETRIES:-5}
        local max_sha_retry=${SHA_MISMATCH_MAX_RETRIES:-1}
        local download_attempt=0
        local sha_attempt=0
        # 循环尝试：根据错误类型分别重试
        while true; do
            download_attempt=$((download_attempt + 1))
            brew fetch --formula --retry "$pkg" 2>&1 \
                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" \
                | tee "$tmpfile"
            fetch_exit=${PIPESTATUS[0]}
            if [ $fetch_exit -ne 0 ]; then
                # 下载失败
                if [ $download_attempt -lt $max_download_retry ]; then
                    sleep 1
                    continue
                else
                    # 达到下载重试上限
                    success=0
                    break
                fi
            fi
            # 下载成功后，校验 SHA
            local brew_cache_path=""
            local brew_expected_sha=""
            local registry_sha=""
            local json=""
            if [ "$(id -u)" -eq 0 ]; then
                local targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
                brew_cache_path=$(sudo -n -H -u "$targetUser" /bin/bash -lc "brew --cache --formula \"$pkg\"" 2>/dev/null)
                json=$(sudo -n -H -u "$targetUser" /bin/bash -lc "brew info --json=v2 \"$pkg\"" 2>/dev/null)
            else
                brew_cache_path=$(brew --cache --formula "$pkg")
                json=$(brew info --json=v2 "$pkg" 2>/dev/null)
            fi
            if [ -n "$brew_cache_path" ] && [ -f "$brew_cache_path" ]; then
                ################################################################
                # 修正：brew --cache 可能返回的是 bottle_manifest.json 文件
                # manifest 的 SHA 与真正的瓶子文件不同，需查找对应的 .bottle*.tar.gz
                ################################################################
                if [[ "$brew_cache_path" == *.bottle_manifest.json ]]; then
                    cache_dir="$(dirname "$brew_cache_path")"
                    candidate=""
                    for f in "$cache_dir"/*"${pkg}"*.bottle*.tar.gz; do
                        candidate="$f"
                        break
                    done
                    if [ -n "$candidate" ] && [ -f "$candidate" ]; then
                        brew_cache_path="$candidate"
                    fi
                fi
                local local_sha
                local_sha=$(shasum -a 256 "$brew_cache_path" | awk '{print $1}')
                # 解析 brew_expected_sha 来自 formula JSON
                if [ -n "$json" ]; then
                    if [ -n "$platform_key" ]; then
                        brew_expected_sha=$(/usr/bin/plutil -extract "formulae.0.bottle.stable.files.${platform_key}.sha256" raw -o - - <<< "$json" 2>/dev/null || true)
                    fi
                    if [ -z "$brew_expected_sha" ]; then
                        brew_expected_sha=$(/usr/bin/plutil -extract "formulae.0.bottle.stable.files.all.sha256" raw -o - - <<< "$json" 2>/dev/null || true)
                    fi
                    if [ -z "$brew_expected_sha" ]; then
                        brew_expected_sha=$(/usr/bin/plutil -extract "formulae.0.urls.stable.checksum" raw -o - - <<< "$json" 2>/dev/null || true)
                    fi
                fi
                # 从 brew fetch 输出中获取 GHCR blob 的 sha256 digest
                registry_sha=$(grep -oE 'blobs/sha256:[0-9a-f]+' "$tmpfile" | tail -n1 | sed 's/.*blobs\/sha256://')
                # -------- 校验逻辑 --------
                # 1) JSON 命中且一致 → 成功
                if [ -n "$brew_expected_sha" ] && [ "$local_sha" = "$brew_expected_sha" ]; then
                    success=1
                    break
                fi
                # 2) 如果 registry sha 存在且一致 → 成功（JSON 可能延迟）
                if [ -n "$registry_sha" ] && [ "$local_sha" = "$registry_sha" ]; then
                    echo -e "[INFO] $pkg 校验通过（使用 registry 校验；formula API 可能延迟）" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    success=1
                    break
                fi
                # 3) 若二者均不匹配，重试或报警
                sha_attempt=$((sha_attempt + 1))
                if [ $sha_attempt -lt $max_sha_retry ]; then
                    rm -f "$brew_cache_path"
                    sleep 1
                    continue
                fi
                # 三方值输出，供排查
                [ -z "$brew_expected_sha" ] && brew_expected_sha="(未获取)"
                [ -z "$registry_sha" ] && registry_sha="(未获取)"
                echo -e "      expected(formula)=$brew_expected_sha" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                echo -e "      expected(registry)=$registry_sha"     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                echo -e "      local=$local_sha"                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                success=2
                break
            else
                success=1
                break
            fi
        done
        if [ $success -eq 1 ]; then
            echo -e "✅  下载成功 [formula] ：$pkg " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        elif [ $success -eq 2 ]; then
            echo -e "⚠️  下载成功 [formula] ：$pkg (警告：校验码不匹配)" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        else
            echo -e "❌  下载失败 [formula] ：$pkg " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            # 提取最后出现的 URL（若无则为空）
            url=$(grep -oE 'https?://[^[:space:]]+' "$tmpfile" | tail -n1 || true)
            echo "$pkg|$url" >> "$FAILED_FETCH_FORMULAS_FILE"
        fi
        rm -f "$tmpfile"
    }
    export -f fetch_brew_formula

    fetch_brew_cask() {
        local pkg="$1"
        local success=0
        local tmpfile
        # 提前声明用于跨迭代的校验码变量
        local local_sha=""
        local brew_expected_sha=""
        tmpfile=$(mktemp)
        # 下载失败重试次数与校验失败重试次数
        local max_download_retry=${DOWNLOAD_MAX_RETRIES:-5}
        local max_sha_retry=${SHA_MISMATCH_MAX_RETRIES:-1}
        local download_attempt=0
        local sha_attempt=0
        while true; do
            download_attempt=$((download_attempt + 1))
            # 调用 brew fetch 下载 cask 时不再传递 --language 选项。
            # brew fetch 不支持 --language，同时如果通过 HOMEBREW_CASK_OPTS 传入语言选项
            # 会导致 "invalid option: --language" 错误。为避免此问题，在下载阶段显式
            # 清空 HOMEBREW_CASK_OPTS 环境变量，保证 brew fetch 只接受必要参数。
            env HOMEBREW_CASK_OPTS="" brew fetch --cask --retry "$pkg" 2>&1 \
                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" \
                | tee "$tmpfile"
            fetch_exit=${PIPESTATUS[0]}
            if [ $fetch_exit -ne 0 ]; then
                if [ $download_attempt -lt $max_download_retry ]; then
                    sleep 1
                    continue
                else
                    success=0
                    break
                fi
            fi
            # 下载成功后校验 SHA
            local brew_cache_path=""
            # brew_expected_sha 在循环外已声明，用于记录上一次迭代的期望值
            local json=""
            if [ "$(id -u)" -eq 0 ]; then
                local targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
                brew_cache_path=$(sudo -n -H -u "$targetUser" /bin/bash -lc "brew --cache --cask \"$pkg\"" 2>/dev/null)
                json=$(sudo -n -H -u "$targetUser" /bin/bash -lc "brew info --json=v2 \"$pkg\"" 2>/dev/null)
            else
                brew_cache_path=$(brew --cache --cask "$pkg")
                json=$(brew info --json=v2 "$pkg" 2>/dev/null)
            fi
            if [ -n "$brew_cache_path" ] && [ -f "$brew_cache_path" ]; then
                local_sha=$(shasum -a 256 "$brew_cache_path" | awk '{print $1}')
                if [ -n "$json" ]; then
                    brew_expected_sha=$(/usr/bin/plutil -extract "casks.0.sha256" raw -o - - <<< "$json" 2>/dev/null)
                fi
                # 如果期望校验码为 null/no_check，则认为无需校验并视为成功
                if [[ -n "$brew_expected_sha" && "$brew_expected_sha" != "null" && "$brew_expected_sha" != "no_check" && "$local_sha" != "$brew_expected_sha" ]]; then
                    sha_attempt=$((sha_attempt + 1))
                    if [ $sha_attempt -lt $max_sha_retry ]; then
                        rm -f "$brew_cache_path"
                        sleep 1
                        continue
                    fi
                    success=2
                    break
                else
                    success=1
                    break
                fi
            else
                success=1
                break
            fi
        done
        if [ $success -eq 1 ]; then
            echo -e "✅  下载成功 [cask] ：$pkg " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        elif [ $success -eq 2 ]; then
            # 打印本地和期望校验码，便于排查
            echo -e "⚠️  下载成功 [cask] ：$pkg (警告：校验码不匹配)\n    本地 SHA256: ${local_sha:-未知}\n    期望 SHA256: ${brew_expected_sha:-未知}" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        else
            echo -e "❌  下载失败 [cask] ：$pkg " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            url=$(grep -oE 'https?://[^[:space:]]+' "$tmpfile" | tail -n1 || true)
            echo "$pkg|$url" >> "$FAILED_FETCH_CASKS_FILE"
        fi
        rm -f "$tmpfile"
    }
    export -f fetch_brew_cask
    # -----------------------------------------------------------------------------


    # ---------------- ① 并行下载 formula/cask ----------------
    # 采用临时函数文件配合 GNU parallel 的 :::: 文件输入方式。在 root 环境下通过 run_as_normal_user 调用 parallel，避免 sudo 环境丢失函数定义。
    total_formula_count=${#packages_to_fetch_formulas[@]}
    total_cask_count=${#packages_to_fetch_casks[@]}
    if [ $total_formula_count -gt 0 ] || [ $total_cask_count -gt 0 ]; then
      # 将下载函数定义写入临时文件
      # 在 /tmp 下创建函数定义文件，避免目录权限限制导致普通用户无法读取
      functions_file=$(mktemp "/tmp/brew_functions.XXXXXX")
      {
        # 为并行下载注入必要的函数定义，同时定义 platform_key 变量供函数使用
        # platform_key 已在前文计算（如 arm64_sonoma）
        echo "platform_key='${platform_key}'"
        declare -f fetch_brew_formula
        declare -f fetch_brew_cask
      } > "$functions_file"
      # 默认 mktemp 创建的文件权限为 600（仅 root 可读），在 root 模式下需要让普通用户可以读取
      chmod 644 "$functions_file"
      # 如果存在 formula 或 cask 需要下载，准备文件列表
      if [ $total_formula_count -gt 0 ]; then
        formula_list_file=$(mktemp)
        printf '%s\n' "${packages_to_fetch_formulas[@]}" > "$formula_list_file"
      fi
      if [ $total_cask_count -gt 0 ]; then
        cask_list_file=$(mktemp)
        printf '%s\n' "${packages_to_fetch_casks[@]}" > "$cask_list_file"
      fi
      # 根据是否 root 选择执行方式
      if [ "$(id -u)" -eq 0 ]; then
        # 在 root 模式下，通过 xargs 并行调用 brew fetch，不依赖自定义函数。
        targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        # 提示降权信息
        printf '\033[1;34m[INFO]\033[0m '
        printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 并行下载（parallel download）安装包" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 使用 xargs -P 在 sudo 环境下并行执行 brew fetch。为每个包创建一个小的脚本，用于执行下载并记录失败。
        if [ $total_formula_count -gt 0 ]; then
          # 在 /tmp 下创建并行下载脚本，避免目录权限导致普通用户无法读取
          xargs_formula_script=$(mktemp "/tmp/brew_xargs_formula.XXXXXX")
          cat > "$xargs_formula_script" <<'EOF'
#!/bin/bash
pkg="$1"
targetUser="$2"
functions_file="$3"
env_PATH="$4"
env_CASK_OPTS="$5"
# 直接在目标用户环境中调用函数，不在此处追加日志或处理失败；日志和失败处理由 fetch_brew_formula 自身负责
sudo -n -E -H -u "$targetUser" env PATH="$env_PATH" HOMEBREW_CASK_OPTS="$env_CASK_OPTS" bash -lc "source \"${functions_file}\"; fetch_brew_formula \"${pkg}\""
EOF
          chmod +x "$xargs_formula_script"
          # 并行执行每个下载任务，并传递必要的环境变量，包括 functions_file 路径
          printf '%s\n' "${packages_to_fetch_formulas[@]}" | xargs -n1 -P"$PARALLEL_JOBS" -I {} bash "$xargs_formula_script" "{}" "$targetUser" "$functions_file" "$PATH" "$HOMEBREW_CASK_OPTS"
          rm -f "$xargs_formula_script"
        fi
        if [ $total_cask_count -gt 0 ]; then
          # 在 /tmp 下创建并行下载脚本，避免目录权限导致普通用户无法读取
          xargs_cask_script=$(mktemp "/tmp/brew_xargs_cask.XXXXXX")
          cat > "$xargs_cask_script" <<'EOF'
#!/bin/bash
pkg="$1"
targetUser="$2"
functions_file="$3"
env_PATH="$4"
env_CASK_OPTS="$5"
# 直接在目标用户环境中调用函数，由 fetch_brew_cask 自身处理日志和失败
sudo -n -E -H -u "$targetUser" env PATH="$env_PATH" HOMEBREW_CASK_OPTS="$env_CASK_OPTS" bash -lc "source \"${functions_file}\"; fetch_brew_cask \"${pkg}\""
EOF
          chmod +x "$xargs_cask_script"
          printf '%s\n' "${packages_to_fetch_casks[@]}" | xargs -n1 -P"$PARALLEL_JOBS" -I {} bash "$xargs_cask_script" "{}" "$targetUser" "$functions_file" "$PATH" "$HOMEBREW_CASK_OPTS"
          rm -f "$xargs_cask_script"
        fi
      else
        # 非 root 时，不使用临时函数文件，直接调用导出的函数进行并行下载。
        # fetch_brew_formula 与 fetch_brew_cask 已在前文通过 export -f 导出，可直接供 GNU parallel 调用。
        if [ $total_formula_count -gt 0 ]; then
          "$PARALLEL_BIN" --will-cite --line-buffer --unsafe -j"$PARALLEL_JOBS" fetch_brew_formula ::: "${packages_to_fetch_formulas[@]}"
        fi
        if [ $total_cask_count -gt 0 ]; then
          "$PARALLEL_BIN" --will-cite --line-buffer --unsafe -j"$PARALLEL_JOBS" fetch_brew_cask ::: "${packages_to_fetch_casks[@]}"
        fi
      fi
      # 清理临时文件
      rm -f "$functions_file"
      # 使用参数展开的默认值以避免 set -u 下未定义变量导致报错
      [ -n "${formula_list_file:-}" ] && rm -f "$formula_list_file"
      [ -n "${cask_list_file:-}" ] && rm -f "$cask_list_file"
    fi

    # 下载阶段结束后，汇总成功与失败的数量并高亮输出
    if [ $total_formula_count -gt 0 ] || [ $total_cask_count -gt 0 ]; then
        # 统计失败的数量（文件按行记录失败的软件名|url），不存在文件则视为 0
        failed_formula=0
        failed_cask=0
        if [ -n "$FAILED_FETCH_FORMULAS_FILE" ] && [ -f "$FAILED_FETCH_FORMULAS_FILE" ]; then
            failed_formula=$(wc -l < "$FAILED_FETCH_FORMULAS_FILE" 2>/dev/null || echo 0)
        fi
        if [ -n "$FAILED_FETCH_CASKS_FILE" ] && [ -f "$FAILED_FETCH_CASKS_FILE" ]; then
            failed_cask=$(wc -l < "$FAILED_FETCH_CASKS_FILE" 2>/dev/null || echo 0)
        fi
        success_formula=$(( total_formula_count - failed_formula ))
        success_cask=$(( total_cask_count - failed_cask ))
        # 输出成功统计 [INFO]
        echo -e "------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        printf "\033[1;34m[INFO]\033[0m "
        printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "下载完成 [formula]：$success_formula/$total_formula_count" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        printf "\033[1;34m[INFO]\033[0m "
        printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "下载完成 [cask]   ：$success_cask/$total_cask_count" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 输出失败软件列表 [WARNING]
        if [ "$failed_formula" -gt 0 ]; then
            printf "\033[1;33m[WARNING]\033[0m "
            printf "[WARNING] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
            # 读取失败文件的包名部分，按空格连接
            formula_fail_list=$(cut -d'|' -f1 < "$FAILED_FETCH_FORMULAS_FILE" | xargs)
            echo -e "未完成的 formula 列表：$formula_fail_list" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        fi
        if [ "$failed_cask" -gt 0 ]; then
            printf "\033[1;33m[WARNING]\033[0m "
            printf "[WARNING] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
            cask_fail_list=$(cut -d'|' -f1 < "$FAILED_FETCH_CASKS_FILE" | xargs)
            echo -e "未完成的 cask    列表：$cask_fail_list" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        fi
    fi

    # echo -e "✅ 所有下载任务 已完成/已退出"                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    # brew doctor  2>&1                                                                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # exit 1                                                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"          # 用于调试 ！！



    brew_formula_upgrade_exit=false
    brew_formula_reinstall_exit=false
    brew_formula_reinstall_force_exit=false

    # 第 3 步：串行安装（HomeBrew Formula）
    if [ ${#packages_brew_formulas[@]} -ne 0 ] ; then
        echo -e ""                                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        printf "\033[1;34m[Install]\033[0m "
        printf "[Install] "                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "开始更新：HomeBrew Formula（ 串行 ） ... "                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

        # 循环逐个处理每个过期的 HomeBrew Formula
        for pkg_brew_formula in "${packages_brew_formulas[@]}"; do

            # 如果在并行下载阶段检测到该 formula 下载失败，则直接跳过升级
            if [[ -n "$FAILED_FETCH_FORMULAS_FILE" && -f "$FAILED_FETCH_FORMULAS_FILE" ]]; then
                fail_line=$(grep -F "${pkg_brew_formula}|" "$FAILED_FETCH_FORMULAS_FILE" || true)
                if [[ -n "$fail_line" ]]; then
                    fail_url=$(echo "$fail_line" | cut -d'|' -f2-)
                    echo -e "❌  更新失败 [formula] : $pkg_brew_formula (下载失败：$fail_url)" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    updated_list+=("failure|formula|$pkg_brew_formula|fetch_failed:$fail_url")
                    echo -e "--------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    continue
                fi
            fi

            brew_formula_tmpfile=$(mktemp)

            # ---------- 尝试升级 ----------
            # 检查是否以 root 身份运行
            if [ "$(id -u)" -eq 0 ]; then
                # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
                targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
                echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_formula 升级 ( brew upgrade $pkg_brew_formula --verbose --debug ) ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
                # 以目标用户身份执行 HomeBrew 命令
                sudo -n -H -u "$targetUser" bash -c "brew upgrade $pkg_brew_formula 2>&1" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$brew_formula_tmpfile"
            else
                echo -e "✓  当前用户'$USER'，为普通权限，直接运行 $pkg_brew_formula 升级 ( brew upgrade $pkg_brew_formula --verbose --debug ) ... "                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
                brew upgrade "$pkg_brew_formula" 2>&1                                                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$brew_formula_tmpfile" 
            fi

            brew_formula_upgrade_exit=${PIPESTATUS[0]}        # 取 brew upgrade 的退出码
            brew_formula_final_exit=$brew_formula_upgrade_exit             # 先假定最终状态 = 升级状态
            brew_formula_relink_exit=false

            # ---------- 新增：SHA-256 校验失败检测 ----------
            # 如果此次升级失败且输出中含有 SHA-256 mismatch，则提取期望和实际校验码并停止后续尝试
            # 允许用户通过 SHA_MISMATCH_MAX_RETRIES 配置尝试次数（默认为 1）
            if [ "$brew_formula_upgrade_exit" -ne 0 ]; then
                # 查找关键字（兼容大小写）
                if grep -qiE 'sha[- ]?256 mismatch' "$brew_formula_tmpfile"; then
                    # 抽取期望和实际校验码（若有）
                    sha_expected=$(grep -i 'Expected:' "$brew_formula_tmpfile" | head -n1 | sed -E 's/.*Expected:[[:space:]]*//I')
                    sha_actual=$(grep -i 'Actual:' "$brew_formula_tmpfile" | head -n1 | sed -E 's/.*Actual:[[:space:]]*//I')
                    # 输出警告并停止重试
                    echo -e "⚠️  检测到 SHA-256 校验失败 [formula] $pkg_brew_formula ，停止后续尝试。实际校验码: ${sha_actual:-未知} ，期望校验码: ${sha_expected:-未知}" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    # 记录失败状态，方法为 sha256_mismatch:actual:expected
                    updated_list+=("failure|formula|$pkg_brew_formula|sha256_mismatch:${sha_actual:-unknown}:${sha_expected:-unknown}")
                    echo -e "--------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    rm -f "$brew_formula_tmpfile"
                    continue   # 跳过后续链接或重装步骤
                fi
            fi

            # ---------- 若升级失败则尝试重装 ----------
            if [ $brew_formula_upgrade_exit -ne 0 ] ; then

                # 第二次尝试升级：通过 brew link 修复 formula APP 链接 （检查输出中是否包含符号链接冲突提示）
                if grep -q "not symlinked" "$brew_formula_tmpfile" || grep -q "Could not symlink" "$brew_formula_tmpfile"; then

                    echo "⚠️ 检测到 $pkg_brew_formula 升级后，符号链接冲突，尝试执行 'brew link --overwrite $pkg_brew_formula' ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    # 检查是否以 root 身份运行
                    if [ "$(id -u)" -eq 0 ]; then
                        # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
                        targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
                        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_formula 重装 ( brew link --overwrite $pkg_brew_formula )  ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        # 以目标用户身份执行 HomeBrew 命令
                        sudo -n -H -u "$targetUser" bash -c "brew link --overwrite $pkg_brew_formula 2>&1"                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    else
                        echo -e "✓  当前用户'$USER'，为普通权限，直接运行 $pkg_brew_formula 重装 ( brew link --overwrite $pkg_brew_formula ) ... "                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        brew link --overwrite "$pkg_brew_formula" 2>&1                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    fi

                    #brew link --overwrite "$pkg_brew_formula" 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    brew_formula_relink_exit=${PIPESTATUS[0]} 

                    # ---------- 根据最终状态输出结果 ----------
                    if [ $brew_formula_relink_exit -eq 0 ]; then
                        echo "✅  更新成功 [formula] ：$pkg_brew_formula ( 已更新 & 符号链接 ) " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        # 记录成功状态（将$pkg_brew_formula加入成功列表），并跳过后续的重装尝试
                        if [ $brew_formula_upgrade_exit -ne 0 ]; then
                            if [ $brew_formula_relink_exit -eq 0 ]; then
                                brew_formula_method="relink"
                            fi
                        else
                            brew_formula_method="upgrade"
                        fi     
                        #updated_list+=("success|formula|$pkg_brew_formula|$brew_formula_method")
                        if [ $brew_formula_final_exit -eq 0 ] ; then
                            updated_list+=("success|formula|$pkg_brew_formula|$brew_formula_method")
                        else
                            updated_list+=("failure|formula|$pkg_brew_formula|$brew_formula_method")
                        fi
                        echo -e "--------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        rm -f "$brew_formula_tmpfile"
                        continue   # 进入下一个 formula 处理
                    else
                        echo -e "⚠️  符号链接 失败 [formula] $pkg_brew_formula ，继续尝试 重新安装 ( brew reinstall $pkg_brew_formula --verbose --debug ) ... "                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    fi

                    # 若强制链接仍失败，下面会继续执行重装逻辑
                fi

                # 第三次尝试升级：通过 brew reinstall  升级 formula APP
                echo -e "⚠️ upgrade 失败，尝试 重装 ( brew reinstall $pkg_brew_formula --verbose --debug ) ... "                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                # 检查是否以 root 身份运行
                if [ "$(id -u)" -eq 0 ]; then
                    # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
                    targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
                    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_formula 重装 ( brew reinstall $pkg_brew_formula --verbose --debug )  ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    # 以目标用户身份执行 HomeBrew 命令
                    sudo -n -H -u "$targetUser" bash -c "brew reinstall $pkg_brew_formula 2>&1"                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                else
                    echo -e "✓  当前用户'$USER'，为普通权限，直接运行 $pkg_brew_formula 重装 ( brew reinstall $pkg_brew_formula --verbose --debug ) ... "                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    brew reinstall "$pkg_brew_formula" 2>&1                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                fi

                brew_formula_reinstall_exit=${PIPESTATUS[0]}  # 取 brew reinstall 的退出码
                brew_formula_final_exit=$brew_formula_reinstall_exit

                # 第四次尝试升级：通过 brew reinstall --force 升级 formula APP
                if [ $brew_formula_reinstall_exit -ne 0 ]; then
                    echo -e "⚠️ reinstall 失败，尝试 强制重装 ( brew reinstall --force $pkg_brew_formula --verbose --debug ) ... "                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    # 检查是否以 root 身份运行
                    if [ "$(id -u)" -eq 0 ]; then
                        # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
                        targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
                        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_formula 强制重装 ( brew reinstall --force $pkg_brew_formula --verbose --debug )  ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        # 以目标用户身份执行 HomeBrew 命令
                        sudo -n -H -u "$targetUser" bash -c "brew reinstall --force $pkg_brew_formula 2>&1"                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    else
                        echo -e "✓  当前用户'$USER'，为普通权限，直接运行 $pkg_brew_formula 强制重装 ( brew reinstall --force $pkg_brew_formula --verbose --debug ) ... "                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        brew reinstall --force "$pkg_brew_formula" 2>&1                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    fi
                    brew_formula_reinstall_force_exit=${PIPESTATUS[0]}  # 取 brew reinstall 的退出码
                    brew_formula_final_exit=$brew_formula_reinstall_force_exit
                fi
            fi

            # ---------- 根据最终状态输出结果 ----------
            if [ $brew_formula_final_exit -eq 0 ] ; then
                echo -e "✅  更新成功 [formula] ：$pkg_brew_formula "                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            else
                echo -e "❌  更新失败 [formula] ：$pkg_brew_formula "                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            fi

            #brew_formula_method=$([ $brew_formula_upgrade_exit -ne 0 ] && echo "reinstall" || echo "upgrade")
            if [ $brew_formula_upgrade_exit -ne 0 ]; then
                if [ $brew_formula_reinstall_exit -eq 0 ]; then
                    brew_formula_method="reinstall"
                    brew_formula_reinstall_exit=0
                elif [ $brew_formula_reinstall_force_exit -eq 0 ]; then
                    brew_formula_method="reinstall_force"
                    brew_formula_reinstall_exit=0
                fi
            else
                brew_formula_method="upgrade"
            fi    

            #updated_list+=("success|cask|$pkg_brew_formula|$brew_formula_method")
            if [ $brew_formula_final_exit -eq 0 ] ; then
                updated_list+=("success|formula|$pkg_brew_formula|$brew_formula_method")
            else
                updated_list+=("failure|formula|$pkg_brew_formula|$brew_formula_method")
            fi

            echo -e "--------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            rm -f "$brew_formula_tmpfile"

        done

    else

        echo -e ""                                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        printf "\033[1;34m[Install]\033[0m "
        printf "[Install] "                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "无需更新：HomeBrew Formula ... "                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        #echo -e ""                                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    fi






    brew_cask_upgrade_exit=false
    brew_cask_reinstall_exit=false
    brew_cask_reinstall_force_exit=false

    # 第 4 步：串行安装（HomeBrew Cask）
    if [ ${#packages_brew_casks[@]} -ne 0 ] ; then
        echo -e ""                                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        printf  "\033[1;34m[Install]\033[0m "
        printf  "[Install] "                                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "开始更新：HomeBrew Cask（ 串行 ） ... "                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

        # 存储需要关闭和重启的应用程序
        #brew_cask_apps_to_restart=()

        # 逐个安装 每个待更新的 cask app
        for pkg_brew_cask in "${packages_brew_casks[@]}"; do

            # 如果在并行下载阶段检测到该 cask 下载失败，则直接跳过升级
            if [[ -n "$FAILED_FETCH_CASKS_FILE" && -f "$FAILED_FETCH_CASKS_FILE" ]]; then
                fail_line=$(grep -F "${pkg_brew_cask}|" "$FAILED_FETCH_CASKS_FILE" || true)
                if [[ -n "$fail_line" ]]; then
                    fail_url=$(echo "$fail_line" | cut -d'|' -f2-)
                    echo -e "❌  更新失败 [cask]   : $pkg_brew_cask (下载失败：$fail_url)" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    updated_list+=("failure|cask|$pkg_brew_cask|fetch_failed:$fail_url")
                    echo -e "--------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    continue
                fi
            fi

            # 新增：为 cask 升级输出创建临时文件，避免变量未定义导致 tee 报错
            brew_cask_tmpfile=$(mktemp)

            # 初始化每个 cask 应用的状态变量
            brew_cask_app_name=""
            brew_cask_exec_name=""
            brew_cask_process_name=""
            brew_cask_app_id=""
            brew_cask_was_running=false

            # ------- 判断当前用户权限：Root 或 普通用户 -------
            if [[ $(id -u) -eq 0 ]]; then
                # 1) 如果是 root，降权至目标普通用户执行 brew info
                targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
                echo -e "✓  Root权限降权至普通权限 ($targetUser) 后，查询 cask 信息..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                # 使用 run_as_normal_user 保留 PATH/HOMEBREW_CASK_OPTS 环境并降权执行 brew info
                brew_cask_info_output=$(run_as_normal_user brew info --cask "$pkg_brew_cask" 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE")
            else
                # 2) 如果已是普通用户，直接执行 brew info
                echo -e "✓  当前用户 '$USER' 为普通权限，直接查询 cask 信息..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                brew_cask_info_output=$(brew info --cask "$pkg_brew_cask" 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE")
            fi


            #exit 1                                                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"          # 用于调试 ！！

            # ---------- 升级 cask 应用 ----------   

            # 第一次尝试升级：通过 brew upgrade 升级 APP
            if [ "$(id -u)" -eq 0 ]; then
              # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
              targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
              echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_cask 升级 ( brew upgrade --cask --greedy $pkg_brew_cask --verbose --debug ) ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
              # 使用辅助函数 run_as_normal_user 保留环境并执行 brew upgrade
              run_as_normal_user brew upgrade --cask --greedy "$pkg_brew_cask" 2>&1         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$brew_cask_tmpfile"
            else
              echo -e "✓  当前用户'$USER'，为普通权限，直接运行 $pkg_brew_cask 升级 ( brew upgrade --cask --greedy $pkg_brew_cask --verbose --debug ) ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
              brew upgrade --cask --greedy "$pkg_brew_cask" 2>&1                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$brew_cask_tmpfile"
            fi

            brew_cask_upgrade_exit=${PIPESTATUS[0]}        # 取 brew upgrade 的退出码
            brew_cask_final_exit=$brew_cask_upgrade_exit             # 先假定最终状态 = 升级状态

            # ---------- 新增：SHA-256 校验失败检测 ----------
            # 当首次升级失败且输出包含 SHA-256 mismatch 时，直接记录失败并跳过后续重装
            if [ "$brew_cask_upgrade_exit" -ne 0 ]; then
                if grep -qiE 'sha[- ]?256 mismatch' "$brew_cask_tmpfile"; then
                    sha_expected=$(grep -i 'Expected:' "$brew_cask_tmpfile" | head -n1 | sed -E 's/.*Expected:[[:space:]]*//I')
                    sha_actual=$(grep -i 'Actual:' "$brew_cask_tmpfile" | head -n1 | sed -E 's/.*Actual:[[:space:]]*//I')
                    echo -e "⚠️  检测到 SHA-256 校验失败 [cask]   $pkg_brew_cask ，停止后续尝试。实际校验码: ${sha_actual:-未知} ，期望校验码: ${sha_expected:-未知}" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    updated_list+=("failure|cask|$pkg_brew_cask|sha256_mismatch:${sha_actual:-unknown}:${sha_expected:-unknown}")
                    echo -e "--------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    rm -f "$brew_cask_tmpfile"
                    continue   # 跳过后续重装
                fi
            fi

            # ---------- 若升级失败则尝试重装 ----------
            if [ $brew_cask_upgrade_exit -ne 0 ] ; then

                # 注意：⚠️ cask不需要 重新链接 ！

                # 第二次尝试升级：通过 brew reinstall 升级 APP  
                echo -e "⚠️ upgrade 失败，尝试重装 ( brew reinstall --cask $pkg_brew_cask --verbose --debug ) ... "                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                # 检查是否以 root 身份运行
                if [ "$(id -u)" -eq 0 ]; then
                    # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
                    targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
                    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_cask 重装 ( brew reinstall --cask $pkg_brew_cask --verbose --debug ) ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    # 使用辅助函数 run_as_normal_user 保留环境并执行 brew reinstall
                    run_as_normal_user brew reinstall --cask  "$pkg_brew_cask" 2>&1       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                else
                    echo -e "✓  当前用户'$USER'，为普通权限，直接运行 $pkg_brew_cask 重装 ( brew reinstall --cask $pkg_brew_cask --verbose --debug ) ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
                    brew reinstall --cask "$pkg_brew_cask" 2>&1                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                fi
   
                brew_cask_reinstall_exit=${PIPESTATUS[0]}    # 获取 brew reinstall 的退出码  
                brew_cask_final_exit=$brew_cask_reinstall_exit       # 将最终状态更新为 reinstall 的状态  



                # 如果第二次尝试仍然失败。尝试关闭线程，然后开始尝试 第三次更升级，通过 brew reinstall --force 强制升级 APP。  
                if [ $brew_cask_reinstall_exit -ne 0 ]; then

                    # 尝试从输出中提取应用的 .app 行（如果存在）
                    brew_cask_app_line=$(echo "$brew_cask_info_output" | grep -m1 '\.app (App)')
                    if [[ -n "$brew_cask_app_line" ]]; then
                        # 提取应用程序包名（去掉“.app (App)”标记和多余空格）
                        brew_cask_app_name=$(echo "$brew_cask_app_line" | sed -e 's/\.app (App)//' -e 's/^[[:space:]]*//')
                    fi

                    if [[ -n "$brew_cask_app_name" ]]; then
                            echo -e "✓  检测到应用名称 = '$brew_cask_app_name.app' ，通过命令 ( brew info $pkg_brew_cask ) 输出的 Artifacts 字段。应用名称用来，关闭进程。已防止阻碍后续更新 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    fi

                    # 如果未找到 .app 信息且检测到 .pkg 安装包，则解析 .pkg 获取应用名称和进程名
                    if [[ -z "$brew_cask_app_line" && $(echo "$brew_cask_info_output" | grep -c '\.pkg (Pkg)') -gt 0 ]]; then

                        echo -e "✘  未能从 brew info $pkg_brew_cask 中，提取到安装后的 应用名称（*.app） ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

                        # 提取即将安装的版本号（优先从 brew info 第一行获取）
                        brew_cask_new_version="$(echo "$brew_cask_info_output" | awk -F'[: ]+' 'NR==1{print $3}')"
                        if [[ -z "$brew_cask_new_version" ]]; then
                            brew_cask_new_version="$(brew info --cask --json=v2 "$pkg_brew_cask" 2>/dev/null | grep -m1 '"version"' | sed -E 's/.*"version": *"([^"]+)".*/\1/')"
                        fi
                        # 构造 .pkg 文件路径（HomeBrew Cask 默认安装路径）
                        brew_cask_pkg_line="$(echo "$brew_cask_info_output" | grep -m1 '\.pkg (Pkg)')"
                        brew_cask_pkg_file_name="$(echo "$brew_cask_pkg_line" | awk '{print $1}')"
                        brew_cask_pkg_path="/opt/homebrew/Caskroom/$pkg_brew_cask/$brew_cask_new_version/$brew_cask_pkg_file_name"

                        echo -e "✓  准备通过 解压缩 $brew_cask_pkg_file_name.pkg 安装包，寻找安装包内的 *.app 文件（安装后的的APP名称） ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        echo -e "✓  解析到 pkg 安装包 的 本地路径：$brew_cask_pkg_path ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

                        if [[ -f "$brew_cask_pkg_path" ]]; then
                            # 创建临时目录并展开 .pkg 文件
                            brew_cask_tmp_dir="$("/usr/bin/mktemp" -d)"
                            /usr/sbin/pkgutil --expand "$brew_cask_pkg_path" "$brew_cask_tmp_dir"
                            # 利用 lsbom 列出安装清单中的 .app 路径列表
                            brew_cask_app_paths="$(find "$brew_cask_tmp_dir" -name '*.bom' -exec /usr/bin/lsbom -f {} \; | sed -n 's#^\(.*\.app\)/Contents/.*#\1#p' | sort -u)"
                            # 遍历 .pkg 安装包含的应用路径（使用 while 逐行读取，支持路径中含空格）
                            while IFS= read -r app_rel_path; do
                                full_app_path="/$app_rel_path"   # .pkg 安装路径是系统根目录起始
                                if [[ -d "$full_app_path" ]]; then
                                    # 读取应用的 Info.plist 获取可执行文件名和 Bundle ID
                                    brew_cask_exec_name="$(/usr/bin/defaults read "$full_app_path/Contents/Info.plist" CFBundleExecutable 2>/dev/null)"
                                    brew_cask_bundle_id="$(/usr/bin/defaults read "$full_app_path/Contents/Info.plist" CFBundleIdentifier 2>/dev/null)"
                                    if [[ -n "$brew_cask_exec_name" ]]; then
                                        brew_cask_app_name="$full_app_path"    # 保存应用程序路径
                                        brew_cask_process_name="$brew_cask_exec_name"    # 对应进程名（用于 pkill/killall）
                                        brew_cask_app_id="$brew_cask_bundle_id"          # 应用 Bundle ID（用于 AppleScript 定位）
                                        echo -e "✓  检测到 .pkg 将安装应用：$full_app_path，进程名：$brew_cask_process_name" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                                        # 如检测到该进程正在运行则尝试关闭
                                        #if pgrep -ix "$brew_cask_process_name" > /dev/null; then
                                        #    echo -e "✓  检测到 $brew_cask_process_name 正在运行，正在尝试退出 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                                        #    ( /usr/bin/osascript -e "tell application id \"$brew_cask_app_id\" to quit" || /usr/bin/pkill -x "$brew_cask_process_name" ) 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                                        #    sleep 5   # 等待进程退出完成
                                        #    brew_cask_was_running=true
                                        #fi
                                        # 检测到目标应用正在运行则尝试关闭（优雅退出 + 超时强杀）
                                        if pgrep -ix "$brew_cask_process_name" > /dev/null; then
                                            echo -e "✓  检测到 '$brew_cask_process_name' (pkg) 正在运行，正在尝试退出 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                                            attempt_quit_app "$brew_cask_app_id" "$brew_cask_process_name" 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                                            brew_cask_was_running=true   # 标记应用本来是运行状态（供后续决定是否重启）
                                        fi

                                        break   # 已找到目标应用，退出循环
                                    fi
                                fi
                            done <<< "$brew_cask_app_paths"
                            # 清理临时文件
                            /bin/rm -rf "$brew_cask_tmp_dir"
                        fi
                        # 有的时候，由于pkg内部还会套多个pkg，故对pkg第一次解压缩后，可能拿不到.app文件名。此时就会获取不到应用名称。
                        # 对于这种情况，建议直接使用 brew info 的 Name 字段作为候选
                        # 如果仍未从 .pkg 中提取到应用名，则使用 brew info 的 Name 字段作为候选
                        if [[ -z "$brew_cask_exec_name" ]]; then
                            echo -e "✘  未能从 $pkg_brew_cask 的 pkg 安装包 $brew_cask_pkg_line 中，提取到安装后的 应用名称（*.app）..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                            echo -e "✘  由于 pkg 内嵌套多个 pkg 。此时就会 获取不到 应用名称 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                            brew_cask_name_line="$(echo "$brew_cask_info_output" | awk '/^==> Name$/{getline; print}')"
                            echo -e "✓  使用 brew info $pkg_brew_cask 的 Name 字段 $brew_cask_name_line ，作为安装后的 应用名称（$brew_cask_name_line.app），查询并关闭 相应进程 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                            brew_cask_app_name="$brew_cask_name_line"
                            [[ "$brew_cask_app_name" =~ Pro\ DC$ ]] && brew_cask_app_name="${brew_cask_app_name// Pro DC/}"   # 去除特殊后缀（如 "Pro DC"）
                            brew_cask_process_name="$brew_cask_app_name"
                        fi
                    fi

                    # 根据提取的应用名/进程名，尝试关闭正在运行的应用以便升级

                    # 如 brew_cask_app_id 为空（非 .pkg 安装），尝试查找已安装的 .app 路径并读取 Info.plist 获取 Bundle ID 和 可执行文件名
                    if [[ -n "$brew_cask_app_name" && -z "$brew_cask_app_id" ]]; then
                        # 搜索常见安装路径 /Applications 和 ~/Applications 下的 .app
                        if [[ -d "/Applications/$brew_cask_app_name.app" ]]; then
                            full_app_path="/Applications/$brew_cask_app_name.app"
                        elif [[ -d "$HOME/Applications/$brew_cask_app_name.app" ]]; then
                            full_app_path="$HOME/Applications/$brew_cask_app_name.app"
                        else
                            # 若上述路径未找到，检查 HomeBrew Caskroom 目录
                            if [[ -d "/opt/homebrew/Caskroom/$pkg_brew_cask" ]]; then
                                full_app_path=$(find "/opt/homebrew/Caskroom/$pkg_brew_cask" -maxdepth 4 -type d -name "$brew_cask_app_name.app" -print -quit)
                            fi
                            if [[ -z "$full_app_path" && -d "/usr/local/Caskroom/$pkg_brew_cask" ]]; then
                                full_app_path=$(find "/usr/local/Caskroom/$pkg_brew_cask" -maxdepth 4 -type d -name "$brew_cask_app_name.app" -print -quit)
                            fi
                        fi

                        # 如果找到已安装的 .app，读取其 Info.plist 获取进程名和 Bundle ID
                        if [[ -n "$full_app_path" && -d "$full_app_path" ]]; then
                            brew_cask_exec_name=$(/usr/bin/defaults read "$full_app_path/Contents/Info.plist" CFBundleExecutable 2>/dev/null)
                            brew_cask_bundle_id=$(/usr/bin/defaults read "$full_app_path/Contents/Info.plist" CFBundleIdentifier 2>/dev/null)
                            if [[ -n "$brew_cask_exec_name" ]]; then
                                brew_cask_process_name="$brew_cask_exec_name"
                                brew_cask_app_id="$brew_cask_bundle_id"
                                echo -e "✓  当前APP的，应用名：'$brew_cask_app_name' ; 路径名：'$full_app_path' ; 进程名：'$brew_cask_process_name' " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                            fi
                        fi
                    fi

                    # 如仍未设置进程名（非 .pkg 安装且未找到 Info），则使用应用名称作为进程名
                    [[ -z "$brew_cask_process_name" ]] && brew_cask_process_name="$brew_cask_app_name"

                    if pgrep -ix "$brew_cask_process_name" > /dev/null; then
                        echo -e "✓  检测到 $brew_cask_process_name (app) 正在运行。开始尝试退出 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        attempt_quit_app "$brew_cask_app_id" "$brew_cask_process_name" 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        brew_cask_was_running=true   # 标记应用原本处于运行状态（更新后需重启）
                        echo -e "✓  退出 '$brew_cask_process_name' 进程 已完成 ... " 
                    else
                        echo -e "✓  直接升级！！！ $brew_cask_app_name 未运行" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    fi

                fi


                # 第三次尝试升级：再次尝试关闭阻碍更新的进程，并通过 brew reinstall --force 升级 APP
                if [ $brew_cask_reinstall_exit -ne 0 ]; then
                      # 若重装失败且检测到应用仍在运行，强制关闭后再重试一次
                      if pgrep -ix "$brew_cask_app_name" > /dev/null; then
                          brew_cask_pid=$(pgrep -f "$brew_cask_app_name")
                          echo -e "⚠️ 检测到 $brew_cask_app_name ( PID = $brew_cask_pid ) 仍在运行，尝试强制关闭，然后再次尝试 reinstall 覆盖安装 ... "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                          if [ -n "$brew_cask_pid" ]; then
                              kill -9 "$brew_cask_pid"
                          fi
                      else
                          echo -e "✓  $brew_cask_app_name 未发现其运行，准备尝试 reinstall --force 强制覆盖安装 !!! "          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                      fi
       
                      # 检查是否以 root 身份运行
                      if [ "$(id -u)" -eq 0 ]; then
                          echo -e "⚠️ upgrade 失败，尝试 强制覆盖安装 ( brew reinstall --cask --force $pkg_brew_cask --verbose --debug ) ... "                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                          # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
                          targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
                          echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_cask 强制覆盖安装 ( brew reinstall --cask --force $pkg_brew_cask --verbose --debug ) ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                          # 使用辅助函数 run_as_normal_user 保留环境并执行 brew reinstall --force
                          run_as_normal_user brew reinstall --cask --force "$pkg_brew_cask" 2>&1       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                      else
                          echo -e "✓  当前用户'$USER'，为普通权限，直接运行 $pkg_brew_cask 强制覆盖安装 ( brew reinstall --cask --force $pkg_brew_cask --verbose --debug ) ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
                          brew reinstall --cask --force "$pkg_brew_cask" 2>&1                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                      fi
       
                      #brew reinstall --cask --force "$pkg_brew_cask" 2>&1                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
       
                      brew_cask_reinstall_force_exit=${PIPESTATUS[0]}
                      brew_cask_final_exit=$brew_cask_reinstall_force_exit       # 将最终状态更新为 reinstall 的状态  
                fi


                # 第四次尝试升级 ：对于需要手动更新的app，单独处理 （ 如：paragon-ntfs、paragon-extfs ）
                if [[ " ${MANUAL_INSTALL_CASKS[*]} " == *" $pkg_brew_cask "* ]]; then
                  echo -e "⚠️  $pkg_brew_cask 需要手动安装，尝试运行其安装器..."

                  # 根据 HomeBrew 前缀确定 Caskroom 路径（Intel 在 /usr/local/Caskroom）
                  caskroom_base=$(brew --prefix)/Caskroom

                  # 查找 FSInstaller.app 的最新版本路径
                  manual_installer_app=$(find "$caskroom_base/$pkg_brew_cask" -maxdepth 3 -type d -name "FSInstaller.app" | sort -r | head -n 1)

                  if [[ -n "$manual_installer_app" ]]; then
                    # 为避免 Gatekeeper 静默阻止，先移除隔离标记
                    if [[ $(id -u) -eq 0 ]]; then
                      targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
                      # 使用非交互模式的 sudo 调用，避免在后台运行时等待密码
                      sudo -n -u "$targetUser" xattr -dr com.apple.quarantine "$manual_installer_app"
                      # 以图形界面方式启动安装器并等待安装器退出
                      sudo -n -u "$targetUser" open -n -W "$manual_installer_app"
                    else
                      xattr -dr com.apple.quarantine "$manual_installer_app"
                      open -n -W "$manual_installer_app"
                    fi
                  else
                    echo -e "❌ 未找到 $pkg_brew_cask 的安装器，请手动在 Finder 中运行 FSInstaller.app"
                  fi

                  # 安装器执行完后，系统会提示“来自 Paragon Software 的系统软件已被阻止”时
                  # 需要用户前往系统设置 → 隐私与安全性 → 允许，并根据提示重启。
                fi

            fi  

            # ---------- 重新启动 APP（如果在本次升级中被关闭） ----------   

            # 如果之前关闭了应用，更新完成后重新打开 
            if [[ "$brew_cask_was_running" = true && -n "$brew_cask_app_name" ]]; then  
              echo -e "✓  重新启动此前关闭的应用：$brew_cask_app_name ... "                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
              open -a "$brew_cask_app_name.app" 2>&1                                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            fi

            # ---------- 本APP 的 升级结果 ----------  
            if [ $brew_cask_final_exit -eq 0 ]; then
                echo -e "✅  更新成功 [cask]   : $pkg_brew_cask "                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            else
                echo -e "❌  更新失败 [cask]   : $pkg_brew_cask "                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            fi

            #brew_cask_method=$([ $brew_cask_upgrade_exit -ne 0 ] && echo "reinstall" || echo "upgrade")
            if [ $brew_cask_upgrade_exit -ne 0 ]; then
                if [ $brew_cask_reinstall_exit -eq 0 ]; then
                    brew_cask_method="reinstall"
                    brew_cask_reinstall_exit=0
                elif [ $brew_cask_reinstall_force_exit -eq 0 ]; then
                    brew_cask_method="reinstall_force"
                    brew_cask_reinstall_exit=0
                fi
            else
                brew_cask_method="upgrade"
            fi                

            #updated_list+=("success|cask|$pkg_brew_cask|$brew_cask_method")
            if [ $brew_cask_final_exit -eq 0 ] ; then
                updated_list+=("success|cask|$pkg_brew_cask|$brew_cask_method")
            else
                updated_list+=("failure|cask|$pkg_brew_cask|$brew_cask_method")
            fi

            echo -e "--------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

            rm -f "$brew_cask_tmpfile"  # 清理临时文件

        done

        echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    else  

        echo -e ""                                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        printf  "\033[1;34m[Install]\033[0m "   
        printf  "[Install] "                                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  > /dev/null
        echo -e "无需更新：HomeBrew Cask ... "                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    fi    




 #  brew upgrade --greedy --debug --force                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE""  ###### 仅作为Debug使用！！！

else    

    echo -e "✓  未检测到新版本 ：HomeBrew Formula ... "                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    echo -e "✓  未检测到新版本 ：HomeBrew Cask ... "                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    echo -e ""                                                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    printf  "\033[1;34m[Download & Install]\033[0m "    
    printf  "[Download & Install] "                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "HomeBrew 下载安装 ... "                                         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    echo -e "✓  所有APP已经是 最新版本 ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    echo -e ""                                                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

fi


# 第 5 步： 清洁
printf  "\033[1;34m[Clean]\033[0m "
printf  "[Clean] "                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "HomeBrew 清理残留 ... "                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"


# 检查是否以 root 身份运行
if [ "$(id -u)" -eq 0 ]; then
    # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
    targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 brew cleanup ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 使用辅助函数 run_as_normal_user 保留环境并执行 brew cleanup / cleanup -s / autoremove / missing
    run_as_normal_user brew cleanup --prune=all 2>&1       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 使用 -s 参数彻底清理下载缓存，包括最新版本的下载文件
    run_as_normal_user brew cleanup -s 2>&1                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 自动移除不再依赖的“孤儿”包
    run_as_normal_user brew autoremove 2>&1                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 列出缺失依赖，仅提示，不影响退出码
    run_as_normal_user brew missing || true                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
else
    echo -e "✓  当前用户'$USER'，为普通权限，直接运行 brew cleanup ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    brew cleanup --prune=all 2>&1                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 使用 -s 参数彻底清理下载缓存，包括最新版本的下载文件
    brew cleanup -s 2>&1                                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    brew autoremove 2>&1                                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 列出缺失依赖，仅提示，不影响退出码
    brew missing || true                                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
fi


echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"


# 第 6 步： 显示结果
printf "\033[1;34m[Final]\033[0m "
printf "[Final] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "HomeBrew 更新结果 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

if [ ${#packages_brew[@]} -eq 0 ]; then
    # 没有任何软件需要更新的情况
    echo -e "✓  没有APP被更新 !!! " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
else
    # 逐条输出更新结果
    for entry in "${updated_list[@]}"; do
        IFS='|' read -r status type name brew_method <<< "$entry"
        # 每次循环重置，避免上一条的 reinstall 提示“串味”
        brew_warning_cmd=""
        # 根据状态选择符号和文字
        if [ "$status" = "success" ]; then
            symbol="✅"
            status_text="成功"
        else
            symbol="❌"
            status_text="失败"
        fi
        # 根据类型调整对齐格式
        if [ "$type" = "cask" ]; then
            type_display="[cask]"
            spacing="   "      # cask 比 formula 短3个字母，补3个空格对齐
        else
            type_display="[formula]"
            spacing=""
        fi
        # 构造基础输出行（符号、结果、类型、名称）
        line="$symbol  更新$status_text $type_display$spacing : $name"
        # 如果是失败且 brew_method 为 fetch_failed:<URL>，则追加下载失败原因
        # 处理 SHA-256 校验失败的情况
        if [ "$status" = "failure" ] && [[ "$brew_method" == sha256_mismatch:* ]]; then
            # brew_method 格式: sha256_mismatch:actual:expected
            tmp="${brew_method#sha256_mismatch:}"
            sha_actual="${tmp%%:*}"
            sha_expected="${tmp#*:}"
            line="$symbol  更新$status_text $type_display$spacing : $name (SHA-256校验失败：实际: $sha_actual, 期望: $sha_expected)"
        # 如果是失败且 brew_method 为 fetch_failed:<URL>，则追加下载失败原因
        elif [ "$status" = "failure" ] && [[ "$brew_method" == fetch_failed:* ]]; then
            fail_url="${brew_method#fetch_failed:}"
            line="$symbol  更新$status_text $type_display$spacing : $name (下载失败：$fail_url)"
        fi
        # 若通过重装更新，则附加警告标记和具体命令
        if [ "$status" = "success" ]; then
            if [ "$brew_method" = "reinstall_force" ]; then
                # 强制重装成功的情况
                brew_warning_cmd="brew reinstall --cask --force $name"
                [ "$type" != "cask" ] && brew_warning_cmd="brew reinstall --force $name"
            elif [ "$brew_method" = "reinstall" ]; then
                # 普通重装成功的情况
                brew_warning_cmd="brew reinstall --cask $name"
                [ "$type" != "cask" ] && brew_warning_cmd="brew reinstall $name"
            fi
            [ -n "$brew_warning_cmd" ] && line="$line   ( ⚠️ 更新方式 ：$brew_warning_cmd )"
        fi
        # 输出该行到屏幕和日志
        echo -e "$line" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    done
fi


echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"


# 检查是否以 root 身份运行
#if [ "$(id -u)" -eq 0 ]; then
#else
#fi

echo -e "\033[1;32m[OK] HomeBrew Upgrade  运行已完成  ✅ \033[1;32m"   
echo -e "[OK]  HomeBrew Upgrade  运行已完成  ✅ "                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

#exit 1                                                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"          # 用于调试 ！！









# ----------------------------------
# 开始执行：MAS
# ----------------------------------

export MAS_NO_INTERACTIVE=1

# 配置 MAS 最大重试次数和重试间隔（可根据需要调整或通过环境变量设置）
MAS_MAX_RETRIES=3                                                                       # 最多重试3次（超时重试次数，可配置）
MAS_RETRY_DELAY=5                                                                       # 每次重试之间等待5秒

echo -e "\033[1;32m-----------------------------------------------\033[0m" 
echo -e "\033[1;32m 运行 MAS                                   \033[0m"
echo -e "\033[1;32m-----------------------------------------------\033[0m" 

echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "运行 MAS"                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
  

# 等待3秒，开始执行
#sleep 3  

# 调用检查时间范围函数（假设此函数已定义）
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"


# 尝试扫描 Mac App Store 更新，显示未更新APP列表，带重试机制

mas_attempt=1
mas_success=false

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

printf  "\033[1;34m[List] \033[0m"
printf  "[List] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "MAS 应用列表 ... "                                                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

# 自动获取当前登录用户
currentUser=$(stat -f%Su /dev/console)

# 如无用户登录则跳过 MAS 更新，但不终止整个脚本
if [ -z "$currentUser" ] || [ "$currentUser" = "loginwindow" ]; then
    echo -e "未检测到登录用户，跳过 MAS 更新。"       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
else

# 如果是 root 运行，则切换到登录用户运行 mas list
if [ "$(id -u)" -eq 0 ]; then
    targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 mas list... "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    uid=$(id -u "$currentUser")
    # 使用非交互模式的 sudo 以避免在后台运行时等待密码
    mas_installed_apps=$(launchctl asuser "$uid" sudo -n -u "$currentUser" /opt/homebrew/bin/mas list)
    #mas_app_count=$(launchctl asuser "$uid" sudo -u "$currentUser" /opt/homebrew/bin/mas list | wc -l)
else
    echo -e "✓  当前用户'$USER'，为普通权限，直接运行 mas list ... "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 非 root 直接运行 mas list
    mas_installed_apps=$(/opt/homebrew/bin/mas list)
    #mas_app_count=$(/opt/homebrew/bin/mas list | wc -l)
fi

if [ -z "$mas_installed_apps" ]; then
    mas_app_count=0
else
    mas_app_count=$(echo "$mas_installed_apps" | wc -l)
fi

# 统计 App 数量并输出结果
mas_app_count=$((mas_app_count+0))
echo -e "✅  APP 数量（ Mac App Store ）：$mas_app_count  "                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"


echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

printf  "\033[1;34m[Scan] \033[0m"
printf  "[Scan] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "MAS 扫描更新 ... "                                                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

while [ $mas_attempt -le $MAS_MAX_RETRIES ]; do
   #mas_output=$(mas outdated 2>&1)                                                     # 执行 mas 查询更新（捕获输出和错误）
    if [[ $(id -u) -eq 0 ]]; then
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 mas outdated ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        mas_output=$(sudo -n -H -u "$targetUser" /bin/bash -lc 'mas outdated' 2>/dev/null )
    else
        echo -e "✓  当前用户'$USER'，为普通权限，直接运行 mas outdated ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  
        mas_output=$( /bin/bash -lc 'mas outdated' 2>/dev/null )
    fi
    mas_status=$?   

    # 把扫描结果写日志并存变量
    #echo -e "$mas_output"                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    outdated_mas_apps="$mas_output"

    if [ $mas_status -eq 0 ]; then
        # 扫描成功，输出结果并标记成功
        echo -e "$mas_output"                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        # 使用 sed 去掉应用ID和版本号，只保留应用名
        mas_app_names=$(echo "$mas_output" | sed -E 's/^[0-9]+[[:space:]]+//; s/ *\([^)]*\)//g; s/ *->.*//g')
        #echo -e "✅  检测到新版本 : $mas_app_names" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        while IFS= read -r app_line; do
            [[ -n "$app_line" ]] && echo -e "✅  检测到新版本 : $app_line" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        done <<< "$mas_app_names"
        mas_success=true
        break
    else
        # 扫描失败，检查是否超时错误
        if echo -e "$mas_output" | grep -q "The request timed out"; then
            echo -e "⚠️ 第${mas_attempt}次 MAS 扫描超时，重试中 ... "                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        else
            echo -e "❌ mas 扫描更新失败：$mas_output"                                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
            break   # 遇到非超时错误，跳出循环不再重试
        fi
        mas_attempt=$((mas_attempt+1))
        sleep $MAS_RETRY_DELAY 2>&1                                                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"          # 等待一段时间再重试
    fi
done

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

printf  "\033[1;34m[Download & Install]\033[0m "
printf  "[Download & Install] "                                                         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "MAS 下载安装 ... "                                                           | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 根据扫描结果决定是否进行安装更新
if [ "$mas_success" = true ]; then
    # 开始执行：MAS 更新（并捕获输出）
    # 获取过时应用程序的ID
    mas_app_ids=$(echo -e "$outdated_mas_apps" | awk '{print $1}'  | grep -E '^[0-9]+$')
    
    echo -e "✓  开始扫描，待更新的APP，是否正在运行 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    #echo -e "mas_app_ids = $mas_app_ids "      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  # 测试！

    # 存储需要关闭和重启的应用程序
    mas_apps_to_restart=()

    # 检查并关闭正在运行的应用程序
    for mas_id in $mas_app_ids; do
        # 从已安装应用列表中提取应用名称，去掉ID和可能的版本号
        mas_app_name=$(echo -e "$mas_installed_apps" | grep "^$mas_id" | awk '{$1=""; print substr($0,2)}' | sed 's/ ([0-9].*)$//')
        #echo -e "mas_app_name = $mas_app_name "     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" # 测试！
        
        # 检测进程正在运行，如果运行则尝试关闭
        if [ -n "$mas_app_name" ]; then
            # 使用 osascript 检查应用是否正在运行
            if osascript -e "tell application \"System Events\" to (name of processes) contains \"$mas_app_name\"" | grep -q "true"; then
                echo -e "✓  检测到 $mas_app_name 正在运行，正在尝试关闭 ... "                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
                # 安全关闭应用程序
                osascript -e "tell application \"$mas_app_name\" to quit"
                # 等待应用完全关闭（最多10秒）
                for i in {1..10}; do
                    if ! osascript -e "tell application \"System Events\" to (name of processes) contains \"$mas_app_name\"" | grep -q "true"; then
                        break
                    fi
                    sleep 1
                done
                # 如果应用仍未关闭，尝试强制关闭
                if osascript -e "tell application \"System Events\" to (name of processes) contains \"$mas_app_name\"" | grep -q "true"; then
                    echo -e "✘  无法正常关闭 $mas_app_name ，正在尝试强制关闭 ... "                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
                    # 获取应用程序的PID
                    mas_pid=$(pgrep -f "$mas_app_name")
                    if [ -n "$mas_pid" ]; then
                        kill -9 $mas_pid
                        echo -e "✓  已强制关闭 $mas_app_name (PID: $mas_pid)"                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
                    else
                        echo -e "✘  无法获取 $mas_app_name 的PID，跳过强制关闭"                         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
                    fi
                fi
                # 再次检查应用是否已关闭成功
                if osascript -e "tell application \"System Events\" to (name of processes) contains \"$mas_app_name\"" | grep -q "true"; then
                    echo -e "✘  无法关闭 $mas_app_name ，稍后 将跳过重启该应用。"                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                else
                    # 已成功关闭的应用加入重启列表
                    mas_apps_to_restart+=("$mas_app_name")
                    echo -e "✓  已关闭 $mas_app_name ，稍后 将重新启动该应用。"                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                fi
            fi
        fi
    done
    
    echo -e "✓  所有 待更新的 MAS APP ，均已停止运行 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    if [[ $(id -u) -eq 0 ]]; then
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 mas upgrade ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        mas_output=$(sudo -n -H -u "$targetUser" /bin/bash -lc 'mas upgrade' 2>/dev/null )
    else
        echo -e "✓  当前用户'$USER'，为普通权限，直接运行 mas upgrade ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  
        mas_output=$( /bin/bash -lc 'mas upgrade' 2>/dev/null )
    fi
    
    echo -e "$mas_output"                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # （3）根据升级结果打印“更新成功”或“已最新”提示
    if echo "$mas_output" | grep -q "Installed"; then
        # 解析 mas upgrade 输出，提取已更新的应用名称列表
        updated_mas_app_names=$(echo "$mas_output"  | grep -E "Installed"  | sed -E 's/^==> Installed //; s/ *\([^)]*\)//g')
        # 遍历每个已更新应用名称，输出日志
        while IFS= read -r app_line; do
            [[ -n "$app_line" ]] && echo -e "✅  更新成功    : $app_line"  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        done <<< "$updated_mas_app_names"
    else
        echo -e "✓  应用已是最新版本，无需更新。" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    fi

    # 重新启动之前关闭的应用程序
    for mas_app in "${mas_apps_to_restart[@]}"; do
        echo -e "✓ 正在重新启动 $mas_app ... "                                                  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        open -a "$mas_app"  2>&1                                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        sleep 1  # 短暂延迟以确保应用启动
    done

    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    # 检查是否以 root 身份运行
    #if [ "$(id -u)" -eq 0 ]; then
    #else
    #fi

    echo -e "\033[1;32m[OK] Mac App Store Upgrade  运行已完成已完成 ，APP 已重启 ✅ \033[1;32m"   
    echo -e "[OK]  Mac App Store Upgrade  运行已完成已完成 ，APP 已重启 ✅ "                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

else

    echo -e "❌ mas 多次尝试仍超时，已跳过 Mac App Store （MAS）应用更新"

fi


fi
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"     





# ----------------------------------
# 开始执行：MacPorts
# ----------------------------------

export MacPorts_NO_INTERACTIVE=1


echo -e "\033[1;32m-----------------------------------------------\033[0m"
echo -e "\033[1;32m 运行 MacPorts                              \033[0m"
echo -e "\033[1;32m-----------------------------------------------\033[0m"

echo -e "-------------------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "运行 MacPorts"                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 拒绝执行时间窗口
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

# （1）仅在确实发生“重大变化”时执行一次 migrate
# 若 CLT 未就绪，跳过

if ! ensure_clt_or_skip_macports; then
    echo -e "⏭️  MacPorts 步骤被跳过（缺少 CLT）" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
else
    printf "\033[1;34m[Migrate]\033[0m "
    printf "[Migrate] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null 
    echo "MacPorts 扫描迁移 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    if macports_should_migrate; then
        echo -e "✓  使用Root权限(sudo命令), 运行 port migrate ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        MIGRATE_LOG="$(__get_migrate_log_file)"
        /bin/mkdir -p "${MIGRATE_LOG%/*}" 2>/dev/null || true
        if yes | sudo $SUDO_N_FLAG /opt/local/bin/port -q migrate 2>&1 \
            | /usr/bin/tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$MIGRATE_LOG" > /dev/null; then
            macports_mark_migrated
            echo -e "✓ 迁移完成" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        else
            echo -e "❌ 迁移失败（请检查日志）" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_ERROR_FILE"
        fi
    else
        echo -e "✓ 无需迁移（已处于当前 Darwin/架构/base）" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    fi

    echo "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    printf "\033[1;34m[Scan]\033[0m "
    printf "[Scan] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null 
    echo "MacPorts 扫描更新 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    echo -e "✓  使用Root权限(sudo命令), 运行 port outdated ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    outdated_list="$(sudo $SUDO_N_FLAG /opt/local/bin/port -q outdated -N 2>/dev/null || true)"

    if [ -z "$outdated_list" ]; then
        echo -e "✓  无需升级任何端口 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        echo "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    else
        echo -e "【过期端口】" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        echo "$outdated_list" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        echo "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

        # （3）升级：终端只打印摘要…完整构建日志写文件
        macports_upgrade_outdated_quiet

        # （4）清理（不依赖当前目录）
        printf "\033[1;34m[Clean]\033[0m "
        printf "[Clean] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo "MacPorts 清理残留 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        echo -e "✓  使用Root权限(sudo命令), 运行 port reclaim ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 官方 reclaim 命令会删除日志、旧档和 distfiles，并尝试卸载非活动版本
        sudo $SUDO_N_FLAG /opt/local/bin/port -q reclaim
        
        # 卸载仍然处于非活动状态的端口（如果 reclaim 未能完全删除）
        printf "\033[1;34m[Uninstall]\033[0m "
        printf "[Uninstall] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo "MacPorts 卸载非活动旧版本 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        echo -e "✓  使用Root权限(sudo命令), 运行 port uninstall inactive ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        sudo $SUDO_N_FLAG /opt/local/bin/port uninstall inactive
        
        # 删除无人依赖的叶子端口
        printf "\033[1;34m[Leaves]\033[0m "
        printf "[Leaves] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo "MacPorts 移除无人依赖的叶子端口 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        echo -e "✓  使用Root权限(sudo命令), 运行 port uninstall leaves ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        sudo $SUDO_N_FLAG /opt/local/bin/port echo leaves | xargs sudo $SUDO_N_FLAG /opt/local/bin/port uninstall

        echo "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    fi

    # （5）链接自检（摘要）
    printf "\033[1;34m[Verify]\033[0m "
    printf "[Verify] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo "MacPorts 验证结果 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    echo -e "✓  重新检测 是否有过期端口 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    echo -e "✓  使用Root权限(sudo命令), 运行 port rev-upgrade ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    macports_rev_upgrade_quiet

    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
    echo -e "\033[1;32m[OK] MacPorts Upgrade  运行已完成  ✅\033[0m"
    echo -e "[OK]  MacPorts Upgrade  运行已完成  ✅"                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
fi


echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 


# ----------------------------------
# MacOS System Update
# ----------------------------------

# 移除无效的 SoftwareUpdate_NO_INTERACTIVE 环境变量（并不被软件识别）
# export SoftwareUpdate_NO_INTERACTIVE=1

echo -e "\033[1;32m-----------------------------------------------\033[0m"  
echo -e "\033[1;32m 运行 MacOS System Update                   \033[0m"  
echo -e "\033[1;32m-----------------------------------------------\033[0m"  

echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "运行 MacOS System Update"                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 等待3秒，开始执行 
#sleep 3     

# 调用检查时间范围函数  
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE" 

# 自动执行：SoftwareUpdate （并捕获输出）   
printf "\033[1;34m[Scan]\033[0m "  
printf "[Scan] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null  
echo -e "MacOS 扫描检测 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  

# Run the update scan and capture output (stderr included), logging it as well
    # 调用 softwareupdate 扫描可用更新。
    # 使用 sudo，并根据脚本以 root 运行与否附加 -n 选项，
    # 防止在无人值守情况下等待密码；普通用户运行则保持交互。
    MacOSSystemUpdate_output=$(sudo $SUDO_N_FLAG softwareupdate --list 2>&1)
echo -e "$MacOSSystemUpdate_output" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  
echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  

# Check scan output for "No new software available."
if echo "$MacOSSystemUpdate_output" | grep -F -q "No new software available."; then  
    # No updates available – skip download/install, output "no update needed"
    printf "\033[1;34m[Download & Install]\033[0m "  
    printf "[Download & Install] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null  
    echo -e "MacOS 下载安装 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    echo -e "✓  当前没有需要安装的 MacOS 系统更新 !!!" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
else  
    # Updates are available – proceed with download (and prompt for install)
    printf "\033[1;34m[Download]\033[0m "  
    printf "[Download] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null  
    echo -e "MacOS 下载更新包 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  
    # 下载所有可用更新包，但不自动安装（去除无效的 --agree-to-license 参数）
        # 使用 sudo 调用下载并根据 root 状态附加 -n 选项。
        sudo $SUDO_N_FLAG softwareupdate --download --all --verbose 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    printf "\033[1;34m[Install]\033[0m "  
    printf "[Install] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null  
    echo -e "MacOS 安装更新 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  
    #sudo softwareupdate --install --all --force --agree-to-license --verbose  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  
    #macos_system_update_ec=${PIPESTATUS[0]}
    ## 分析更新结果并输出提示
    #if [[ $macos_system_update_ec -eq 0 ]] && ! grep -qiE "failed|error" "$LOG_FULL_LAST"; then
    #    echo "✅  更新成功 ：MacOS ${OLD_VER} -> ${TARGET_VER}  （ 请重启电脑‼️‼️ ）" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    #else
    #    echo "❌  更新失败 ：MacOS ${OLD_VER} -> ${TARGET_VER}" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    #fi

    echo -e "⚠️【检测到系统更新】！！如需仅下载更新包，可手动运行：softwareupdate --download --all 。若需安装，请手动运行： softwareupdate --install --all --force --verbose " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    show_sysupdate_popup          # <<< 新增：弹 GUI 提示 
fi   

echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"    # blank line for separation  

targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"  

# 检查是否以 root 身份运行 (Check if running as root)
#if [ "$(id -u)" -eq 0 ]; then  
#else  
#fi  

echo -e "\033[1;32m[OK] MacOS System Update  运行已完成  ✅ \033[1;32m"  
echo -e "[OK]  MacOS System Update  运行已完成  ✅ " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null  

echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  
echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  



# ----------------------------------
# 开始执行：TopGrade
# ----------------------------------

export TopGrade_NO_INTERACTIVE=1


echo -e "\033[1;32m-----------------------------------------------\033[0m"  
echo -e "\033[1;32m 运行 TopGrade                              \033[0m"  
echo -e "\033[1;32m-----------------------------------------------\033[0m"  

echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "运行 TopGrade"                                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 等待3秒，开始执行
#sleep 3  

# 调用检查时间范围函数
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
if [[ $(id -u) -eq 0 ]]; then
    #—— root 环境：切换到桌面用户执行 ——#
    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 topgrade 进行升级 ... "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    topgrade_output=$(sudo -n -H -u "$targetUser"  /bin/bash -c 'topgrade --disable brew_formula --disable brew_cask --disable mas --disable system --disable macports --disable node --disable pnpm --disable powershell --disable tldr --disable tlmgr --disable ruby_gems --disable gem --cleanup' 2>&1)
    printf "%s\n" "$topgrade_output"        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

else
    #—— 非 root 环境：直接执行 ——#
    echo -e "✓  当前用户'$USER'，为普通权限，直接运行 topgrade 进行升级 ... "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    topgrade --disable brew_formula --disable brew_cask --disable mas --disable system --disable macports --disable node --disable pnpm --disable powershell --disable tldr --disable tlmgr --disable ruby_gems --disable gem --cleanup 2>&1   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

fi


echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

echo -e "\033[1;32m[OK] TopGrade Upgrade  运行已完成  ✅ \033[1;32m"   
echo -e "[OK]  TopGrade Upgrade  运行已完成  ✅ "                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 



# ----------------------------------
# 开始执行： MacUpdater
# ----------------------------------

MacUpdater_ENABLE="true"
export MacUpdater_NO_INTERACTIVE=1

echo -e "\033[1;32m-----------------------------------------------\033[0m" 
echo -e "\033[1;32m 运行 MacUpdater                            \033[0m"
echo -e "\033[1;32m-----------------------------------------------\033[0m" 

echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "运行 MacUpdater"                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 等待3秒，开始执行
#sleep 3  

# 调用检查时间范围函数
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

# echo -e "应用列表 ... " | tee -a "$LOG_FULL_FILE"
# TOTAL_APPS=$("/Applications/MacUpdater.app/Contents/Resources/macupdater_client" list | wc -l)
# echo -e "APP 数量（全部总计）: $TOTAL_APPS" | tee -a "$LOG_FULL_FILE"
# run_command_with_show_progress "\"$MACUPDATER_CLIENT\" scan" "SCAN"  "$LOG_MACUPDATER_FILE"

# -------- 获取已安装应用的总数 （扫描 -------- 
printf  "\033[1;34m[List]\033[0m "
printf  "[List] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "MacUpdater 应用列表 ... "                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 


# 检查是否以 root 身份运行
if [ "$(id -u)" -eq 0 ]; then

    targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"

    # 获取目标普通用户（优先使用 SUDO_USER，其次获取当前登录控制台用户）
    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 MacUpdater scan ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    #sudo -H -u "$targetUser" bash -c  'macupdater_app_count=$("/Applications/MacUpdater.app/Contents/Resources/macupdater_client" list | wc -l) '
    macupdater_app_count=$(sudo -n -H -u "$targetUser" /Applications/MacUpdater.app/Contents/Resources/macupdater_client list | wc -l)

else

    echo -e "✓  当前用户'$USER'，为普通权限，直接运行 MacUpdater list ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    macupdater_app_count=$("/Applications/MacUpdater.app/Contents/Resources/macupdater_client" list | wc -l)

fi

# 去除前导空格
macupdater_app_count="${macupdater_app_count#"${macupdater_app_count%%[![:space:]]*}"}"
# 去除后置空格
macupdater_app_count="${macupdater_app_count%"${macupdater_app_count##*[![:space:]]}"}"
# 可选：强制算术求值以确保它是整数（加 0，如果非数字则出错）
macupdater_app_count=$((macupdater_app_count + 0))
# 进度条所需
TOTAL_APPS=$((macupdater_app_count + 0))
# 显示MacUpdater监控的所有APP数量
echo -e "✓  APP 数量（ MacUpdater ）: $macupdater_app_count （ $TOTAL_APPS ）"                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

#exit 1          # 测试！

# -------- 获取已安装应用的总数 （扫描 -------- 
printf  "\033[1;34m[Scan]\033[0m "
printf  "[Scan] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "MacUpdater 扫描更新 ... "                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 


# 检查是否以 root 身份运行
if [ "$(id -u)" -eq 0 ]; then

    targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"

    # 获取目标普通用户（优先使用 SUDO_USER，其次获取当前登录控制台用户）
    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 MacUpdater scan ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    MACUPDATER_COMMAND="sudo -n -H -u $targetUser /Applications/MacUpdater.app/Contents/Resources/macupdater_client scan"
        
    #  开始执行 MacUpdater 扫描 
    #### sudo -H -u "$targetUser" bash -c '"/Applications/MacUpdater.app/Contents/Resources/macupdater_client" scan'
    #sudo -H -u "$targetUser" bash -c  'macupdater_app_scanlist=$("/Applications/MacUpdater.app/Contents/Resources/macupdater_client" scan | wc -l) '
    #echo -e "✓  macupdater_app_scanlist : $macupdater_app_scanlist"                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
else

    echo -e "✓  当前用户'$USER'，为普通权限，直接运行 MacUpdater scan ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    MACUPDATER_COMMAND="/Applications/MacUpdater.app/Contents/Resources/macupdater_client scan"
    
fi

#  开始执行 MacUpdater 扫描 
run_command_with_show_progress "$MACUPDATER_COMMAND" "SCAN"  "$LOG_MACUPDATER_FILE"

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 


#  -------- 更新安装过期应用 （安装） -------- 

printf  "\033[1;34m[Install]\033[0m "
printf  "[Install] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "MacUpdater 开始更新 ... "                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 


# 检查是否以 root 身份运行
if [ "$(id -u)" -eq 0 ]; then

    # 自动获取当前登录用户
    currentUser=$(stat -f%Su /dev/console)
    targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"

    # 获取目标普通用户（优先使用 SUDO_USER，其次获取当前登录控制台用户）
    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 MacUpdater update ...（当前用户是 root）" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    macupdater_output=$(sudo -n -H -u "$targetUser" bash -c ' "/Applications/MacUpdater.app/Contents/Resources/macupdater_client" update --force-quit-running-apps --force-major-version-update' 2>&1)
    echo -e "$macupdater_output"                                                           | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

else

    echo -e "✓  当前用户'$USER'，为普通权限，直接运行 MacUpdater update ... "          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
   #"/Applications/MacUpdater.app/Contents/Resources/macupdater_client" update --force-quit-running-apps --force-major-version-update 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    macupdater_output=$(bash -c ' "/Applications/MacUpdater.app/Contents/Resources/macupdater_client" update --force-quit-running-apps --force-major-version-update' 2>&1)
    echo -e "$macupdater_output"                                                           | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

fi

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

# 检查是否以 root 身份运行
#if [ "$(id -u)" -eq 0 ]; then
#else
#fi

echo -e "\033[1;32m[OK] MacUpdater 运行已完成  ✅ \033[1;32m"   
echo -e "[OK]  MacUpdater 运行已完成  ✅ "                                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 





# ----------------------------------
# 恢复 启动台布局（LaunchPad）
# ----------------------------------

# 在所有更新操作完成后，调用启动台布局（LaunchPad）恢复脚本，恢复之前保存的布局

#trap - EXIT  # 取消先前设置的 trap，避免重复恢复

echo -e "\033[1;32m-----------------------------------------------\033[0m" 
echo -e "\033[1;32m 恢复 启动台布局（LaunchPad）                    \033[0m"
echo -e "\033[1;32m-----------------------------------------------\033[0m" 

echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "恢复 启动台布局（LaunchPad）"                                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
output=$(restore_desktop_layout 2>&1)   
status=$?   
echo -e "$output"                                  
    
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
if [ $status -ne 0 ]; then  

    printf  "\033[1;34m[Info]\033[0m "
    printf  "[Info] "                                                                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "启动台布局 恢复路径: '$PATH_DesktopLayout_db_SOURCE'"                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    printf  "\033[1;34m[Info]\033[0m "
    printf  "[Info] "                                                                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "启动台布局 备份路径：'$PATH_DesktopLayout_BACKUP'"                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    printf  "\033[1;34m[ERROR] 启动台布局 恢复失败，请手动恢复 ❌❌❌❌❌\033[0m "   
    printf  "[ERROR]  启动台布局 恢复失败，请手动恢复 ❌❌❌❌❌"                         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

else    

    echo -e "\033[1;32m[OK] 恢复 启动台布局  运行已完成 ✅ \033[1;32m"   
    echo -e "[OK]   恢复 启动台布局  运行已完成 ✅ "                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

fi  
    
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"





# ----------------------------------
# 记录：完成时间 
# ----------------------------------

# 最后打印执行完成的时间

echo -e "\033[1;32m-----------------------------------------------\033[0m" 
echo -e "\033[1;32m 已完成 所有更新                            \033[0m"
echo -e "\033[1;32m-----------------------------------------------\033[0m" 

echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "已完成 所有更新"                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
gui_app_count=$(($brew_cask_count+$mas_app_count))
echo -e "✅  APP 数量（ HomeBrew Formula    ） ：$brew_formula_count  "                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e "✅  APP 数量（ HomeBrew Cask       ） ：$brew_cask_count  "                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e "✅  APP 数量（ Mac App Store       ） ：$mas_app_count   "                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

if [ "${MacUpdater_ENABLE:-false}" != "true" ]; then  
    echo -e "✅  APP 数量（ MAS + HomeBrew Cask ） ：$gui_app_count "                  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
else
    echo -e "✅  APP 数量（ MacUpdater          ） ：$macupdater_app_count  （ $gui_app_count = MAS + HomeBrew Cask ）"                  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
fi

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
printf  "\033[1;34m[Info]\033[0m "
printf  "[Info] "                                                                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "日志路径 ... "                                                                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e "'$LOG_PATH'"                                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
echo -e "\033[1;32mFinished at: $(date) \033[0m"    
echo -e "Finished at: $(date)"                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_FILE" > /dev/null
    
# 打开Log日志文件夹 
open "$LOG_PATH"    
    
    
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 




