#!/bin/bash

# 自动执行的批处理：HomeBrew \ Mas \ MacPorts \ TopGrade \ MacUpdater

#设置执行所需的 环境变量！
export PATH="/usr/local/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/opt/local/bin:/opt/local/sbin:$PATH"


# ================================================================================================
# 参数设置：用户可修改 （Start）
# ================================================================================================

# 设置 ：本脚本拒绝执行的时间范围
STOP_TIME="03:00"       # 拒绝执行 的 结束时间（这个时间后任务正常运行）
DURATION_MINUTES=10     # 拒绝执行结束前 的 时间长度（10分钟，意味着从 2:50 - 3:00 , 本脚本拒绝执行） 注意，单位：分钟（注意，单位不是秒！！！）

# 路径：保存日志文件的路径
# ICLOUD_PATH="$HOME/Library/Mobile Documents/com~apple~CloudDocs"            # 获取 iCloud 云盘路径，
# COMPUTER_NAME=$(scutil --get ComputerName)                                  # 获取 本机名称（并以本机名称作为子文件夹名称）
# LOG_PATH="$ICLOUD_PATH/LOG/$COMPUTER_NAME"                                  # LOG 日志文件 的 保存路径
# mkdir -p "$LOG_PATH"                                                        # 创建目录   # 注意：这里是保存到iCloud，也可以设置别的保存路径


# 路径：保存日志文件的路径
ICLOUD_PATH="$HOME/Library/Mobile Documents/com~apple~CloudDocs"            # 获取 iCloud 云盘路径，
# 生成用于标识设备的目录名称。格式为“型号名称-芯片名称-序列号/用户名”。
# 型号名称取自系统信息的 Model Name 并删除空格；芯片名称去掉 Apple 前缀并删除所有空格；序列号读取系统序列号。
MODEL_NAME_RAW=$(system_profiler SPHardwareDataType 2>/dev/null | awk -F: '/Model Name/{print $2; exit}')
MODEL_NAME_CLEAN=$(echo "${MODEL_NAME_RAW}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//;s/[[:space:]]//g')
CPU_BRAND_RAW=$(sysctl -n machdep.cpu.brand_string 2>/dev/null)
CPU_BRAND_TRIM=$(echo "${CPU_BRAND_RAW}" | sed 's/^Apple[[:space:]]*//;s/^[[:space:]]*//;s/[[:space:]]*$//')
CPU_BRAND_CLEAN=$(echo "${CPU_BRAND_TRIM}" | sed 's/[[:space:]]//g')
SERIAL_NUMBER_RAW=$(system_profiler SPHardwareDataType 2>/dev/null | awk -F: '/Serial Number/{print $2; exit}')
SERIAL_NUMBER_CLEAN=$(echo "${SERIAL_NUMBER_RAW}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
USER_NAME="${USER:-$(whoami)}"
DEVICE_DIR="${MODEL_NAME_CLEAN}-${CPU_BRAND_CLEAN}-${SERIAL_NUMBER_CLEAN}"
# 清理多余的连字符
DEVICE_DIR=$(echo "$DEVICE_DIR" | sed 's/--*/-/g; s/^-//; s/-$//')
LOG_PATH="$ICLOUD_PATH/LOG/${DEVICE_DIR}/${USER_NAME}"
mkdir -p "$LOG_PATH"                                                        # 创建目录到 iCloud
# 保留原有 COMPUTER_NAME 变量以供其他逻辑使用
COMPUTER_NAME=$(scutil --get ComputerName)


# 用于标记需要手动运行安装器的 cask
MANUAL_INSTALL_CASKS=("paragon-ntfs" "paragon-extfs")


################################################################################
# 新增：初始化下载失败记录和重试参数
#
# 为了在并行下载阶段准确记录下载失败的软件包及其下载链接，本脚本引入以下变量：
#   FAILED_FETCH_FORMULAS_FILE ：记录 formula 下载失败的包名与下载链接
#   FAILED_FETCH_CASKS_FILE    ：记录 cask 下载失败的包名与下载链接
#   DOWNLOAD_MAX_RETRIES       ：每个软件包下载时最大的重试次数，默认 3 次
# 这些文件在脚本运行开始时会被清空，并在并行下载任务中写入。变量需要导出以便
# 在 sudo/parallel 环境中生效。
FAILED_FETCH_FORMULAS_FILE="$LOG_PATH/.failed_fetch_formulas"
FAILED_FETCH_CASKS_FILE="$LOG_PATH/.failed_fetch_casks"
# 清空失败记录文件，确保每次运行独立
: > "$FAILED_FETCH_FORMULAS_FILE"
: > "$FAILED_FETCH_CASKS_FILE"
# 下载失败的最大重试次数（可按需调整）
# 默认尝试五次，对于网络问题或链接不可用时会重试
DOWNLOAD_MAX_RETRIES=5
# 导出变量供子进程使用
export FAILED_FETCH_FORMULAS_FILE FAILED_FETCH_CASKS_FILE DOWNLOAD_MAX_RETRIES

# =====================
# 新增：校验失败重试参数（默认 1 次）
#
# 当 Homebrew 在安装过程中检测到下载后的文件 SHA-256 校验失败时，
# 本脚本会停止后续的重装尝试并直接标记为失败。该变量允许用户配置
# 重新尝试升级的次数（1 表示不重试）。如需尝试多次，可修改此值。
SHA_MISMATCH_MAX_RETRIES=1
export SHA_MISMATCH_MAX_RETRIES
################################################################################


# ================================================================================================
# 参数设置：用户可修改 （End）
# ================================================================================================




# ---------------------------------------
# 参数设置：不建议用户修改
# ---------------------------------------

# 定义：日志文件
LOG_FULL_LAST="$LOG_PATH/--UpdateFull.--Last--.log"
LOG_FILE="$LOG_PATH/Update_Auto.log"
LOG_FULL_FILE="$LOG_PATH/UpdateFull.$(date +%Y-%m).log"
LOG_ERROR_FILE="$LOG_PATH/Update_Error.log"
LOG_MACUPDATER_FILE="$LOG_PATH/Update_MacUpdater.log"

echo -e "" > "$LOG_MACUPDATER_FILE"

# 定义：被测试的外网网址（需要翻墙的网址）
TARGET_1="github.com"
TARGET_2="brew.sh"
TARGET_3="apps.apple.com/us/app/apple-store/id375380948"
TARGET_4="macupdater.com"
# 如果不能访问上述网站，会导致很多软件都 更新失败。




# ---------------------------------------
# 自定义函数
# ---------------------------------------


# ************************* #
# 定义函数：检查时间范围的函数
# ************************* #

check_time_range() {

    local stop_time="$1"           # 停止时间
    local duration_minutes="$2"    # 执行时长（分钟）
    local LOG_ERROR_FILE="$3"      # 日志文件

    # 计算起始时间并确保格式为 HH:MM
    local stop_time_seconds start_time
    stop_time_seconds=$(date -j -f "%H:%M" "$stop_time" "+%s") # 将停止时间转换为时间戳
    start_time=$(date -j -f "%s" $((stop_time_seconds - duration_minutes * 60)) "+%H:%M") # 计算起始时间，并转为 HH:MM 格式

    # 获取当前时间
    local current_time
    current_time=$(date '+%H:%M')

    # 检查当前时间是否在范围内
    if [[ ( "$current_time" > "$start_time" || "$current_time" == "$start_time" ) && "$current_time" < "$stop_time" ]]; then
        printf "\033[1;31m[STOP]\033[0m  "
        printf "[STOP] "                                                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  > /dev/null 
        echo -e "任务退出（$(date '+%Y-%m-%d %H:%M:%S')）：为避免与预设 定时任务 冲突"      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_ERROR_FILE" 
        printf "\033[1;31m[STOP]\033[0m  "
        printf "[STOP] "                                                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  > /dev/null 
        echo -e "时间范围（停止建立 更新任务）：$start_time - $stop_time"                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_ERROR_FILE" 
        exit
    fi

}


# ************************* #
# 自定义函数：检查连接的函数

# ************************* #
check_connection() {

    local target=$1
    local LOG_FILE=$2

    if curl -I --connect-timeout 5 "$target" > /dev/null 2>&1; then
        printf "\033[1;32m[OK]\033[0m   "  
        printf "[OK]   "                                                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  > /dev/null  
        printf "已连通 [$target] \n"                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"   
        return 0
    else
        printf "\033[1;31m[ERROR]\033[0m " 
        printf "[ERROR] "                                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_FILE"  > /dev/null  
        echo -e "[$target] $(date '+%Y-%m-%d %H:%M:%S') 连接失败，等待10秒后重试 ... "        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_FILE"  
        sleep 10
        return 1
    fi

}


# ************************* #
# 自定义函数：显示进度条
# ************************* #

show_progress() {

    # 可输入的变量
    local scanned=$1
    local unrecognized=$2
    local to_update=$3
    local total=$4

    # 定义进度条长度（注意：折行，会导致刷新异常！！！！！）
    local bar_width=20

    # 防止除以零
    if [ "$total" -eq 0 ]; then
        total=1
    fi

    # 计算百分比
    local percent=$(( scanned * 100 / total ))

    # 生成进度条
    local filled=$(( scanned * bar_width / total ))
    local empty=$(( bar_width - filled ))
    local bar=""
    for ((i=0; i<filled; i++)); do bar+="█"; done
    for ((i=0; i<empty; i++)); do bar+="-"; done

    # 打印进度条到终端
    printf "\r进度: [%-${bar_width}s] %d%% | 未识别: %d | 需更新: %d | 已扫描: %d/%d" \
        "$bar" "$percent" "$unrecognized" "$to_update" "$scanned" "$total" > /dev/tty

}


# ************************* #
# 自定义函数：运行命令并处理输出
# ************************* #

run_command_with_show_progress() {

    # 可输入的变量
    local CMD="$1"
    local MODE="$2" # SCAN 或 UPDATE
    local LOCAL_LOG_FILE="$3" # 

    # 初始化进度变量
    local scanned=0
    local unrecognized=0
    local to_update=0

    # 日志记录开始执行的命令
    echo -e "✓  执行命令: $CMD"         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOCAL_LOG_FILE"

    # 执行命令并实时处理输出
    eval "$CMD" 2>&1         | tee -a  "$LOCAL_LOG_FILE" | while IFS= read -r line; do
        # 检查是否为 'Scan did stop scanning' 的行
        if [[ "$line" =~ Scan\ did\ stop\ scanning\ \'[^\']+\'\ app\.\.\. ]]; then
            ((scanned++))
            show_progress "$scanned" "$unrecognized" "$to_update" "$TOTAL_APPS"
        fi

        # 记录每一行到日志文件
        echo -e "$line" >> "$LOCAL_LOG_FILE"
    done

    # 完成后换行（避免下次输出覆盖进度条）
    echo -e "" > /dev/tty
    echo -e ""         | tee -a  "$LOCAL_LOG_FILE"

}


# ************************* #
# 自定义函数：恢复 Launchpad 和 桌面布局
# ************************* #

restore_desktop_layout() {

    PATH_DesktopLayout_SOURCE1="$HOME/Library/Preferences"

    if [ -z "$PARENT_DIR" ]; then
        USER_ID=$(basename "$(dirname "$TMPDIR")")
        PARENT_DIR=$(find /System/Volumes/Data/private/var/folders/ -maxdepth 2 -type d -name "$USER_ID" 2>/dev/null)
    fi

    PATH_DesktopLayout_SOURCE2="$PARENT_DIR/0"

    if [ ! -f "$PATH_DesktopLayout_BACKUP/com.apple.spaces.plist" ] || \
       [ ! -f "$PATH_DesktopLayout_BACKUP/com.apple.dock.plist" ] || \
       [ ! -d "$PATH_DesktopLayout_BACKUP/com.apple.dock.launchpad" ]; then

        printf  "\033[1;34m[Info]\033[0m "
        printf  "[Info] "                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "错误：备份文件不完整，无法恢复 桌面布局"                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    else

        printf  "\033[1;34m[Info]\033[0m "
        printf  "[Info] "                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null  
        echo -e "开始还原 桌面布局 ... "                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        cp -f   "$PATH_DesktopLayout_BACKUP/com.apple.spaces.plist"       "$PATH_DesktopLayout_SOURCE1/com.apple.spaces.plist"
        cp -f   "$PATH_DesktopLayout_BACKUP/com.apple.dock.plist"         "$PATH_DesktopLayout_SOURCE1/com.apple.dock.plist"
        sudo cp -rf "$PATH_DesktopLayout_BACKUP/com.apple.dock.launchpad" "$PATH_DesktopLayout_SOURCE2"
        printf  "\033[1;34m[Info]\033[0m "
        printf  "[Info] "                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null  
        echo -e "正在重启 桌面布局 ... "                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        killall Dock

    fi

}



# ************************* #
# 自定义函数： GUI 会话里弹通知或对话框
# ************************* #

show_sysupdate_popup() {
    local title="MacOS 更新需要手动操作"
    local msg="脚本未执行安装，请在终端手动输入：\nsoftwareupdate --install --all --force --verbose"

    # 检测当前登录的图形用户
    local consoleUser
    consoleUser=$(stat -f '%Su' /dev/console)           # 10.10+ 正式接口  
    local consoleUid
    consoleUid=$(id -u "$consoleUser")

    # AppleScript；display dialog 会阻塞，可改成 display notification
    local osaScript='display alert "'"$title"'" message "'"$msg"'" buttons {"OK"} giving up after 30'

    if [[ $(id -u) -eq 0 ]]; then                       # 以 root 身份运行
        if launchctl asuser "$consoleUid" true &>/dev/null; then
            launchctl asuser "$consoleUid" /usr/bin/osascript -e "$osaScript" &
        else
            sudo -u "$consoleUser" /usr/bin/osascript -e "$osaScript" &
        fi
    else                                                # 普通用户
        /usr/bin/osascript -e "$osaScript" &
    fi
}




# ************************* #
# 自定义函数：尝试优雅退出指定的 Homebrew 应用，若30秒内未退出则强制结束
# ************************* #

attempt_quit_app() {
    local brew_app_id="$1"
    local brew_process_name="$2"

    # ---------- 新增：容错处理 ----------
    # 情况 A：Bundle ID 缺失，但进程名存在 → 退而直接 kill 进程
    if [[ -z "$brew_app_id" && -n "$brew_process_name" ]]; then
        echo "⚠️  未找到 Bundle ID，改用进程名 $brew_process_name 退出…" 
        /usr/bin/pkill -x "$brew_process_name" 2>/dev/null
        return 0
    fi

    # 情况 B：既缺 Bundle ID 又缺进程名 → 无可用信息，退出
    if [[ -z "$brew_app_id" && -z "$brew_process_name" ]]; then
        echo "⚠️  无法退出应用：缺少 应用ID ( brew_app_id = $brew_app_id ) 或 进程名 ( brew_process_name = $brew_process_name ) ... "
        return 1
    fi

    # ---------- 原有的优雅退出逻辑从此继续 ----------

    # 根据当前权限选择 AppleScript 执行方式（降权到实际用户）
    if [[ $(id -u) -eq 0 ]]; then

        local targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"   # 获取实际登录用户
        local consoleUid="$(id -u "$targetUser" 2>/dev/null)"
        
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 osascript 立刻退出进程。 ... "   
        echo -e "✓  注意：在退出 '$brew_process_name' 进程时，如果程序弹窗，阻止程序退出（需用户手动确认退）。本脚本将等待30秒，然后发起 强制退出，并强制关闭本进程所有窗口 ... "   

        if launchctl asuser "$consoleUid" true &>/dev/null; then
            # 以实际登录用户上下文运行 AppleScript，尝试优雅退出应用（30秒超时）
            launchctl asuser "$consoleUid" /usr/bin/osascript \
                -e "with timeout of 30 seconds" \
                -e "tell application id \"$brew_app_id\" to quit" \
                -e "end timeout"
        else
            # 回退：直接以该用户身份运行 AppleScript
            sudo -u "$targetUser" /usr/bin/osascript \
                -e "with timeout of 30 seconds" \
                -e "tell application id \"$brew_app_id\" to quit" \
                -e "end timeout"
        fi

    else

        echo -e "✓  当前用户'$USER'，为普通权限，直接运行 osascript 立刻退出进程。 ... "     
        echo -e "✓  注意：在退出 '$brew_process_name' 进程时，如果程序弹窗，阻止程序退出（需用户手动确认退）。本脚本将等待30秒，然后发起 强制退出，并强制关闭本进程所有窗口 ... "       

        # 非 root 情况，直接运行 AppleScript 优雅退出
        /usr/bin/osascript \
            -e "with timeout of 30 seconds" \
            -e "tell application id \"$brew_app_id\" to quit" \
            -e "end timeout"

    fi


    local exit_code=$?

    if [[ $exit_code -ne 0 ]]; then
        # 30秒内未正常退出，执行强制结束
        echo -e "✘  无法正常退出 '$brew_process_name' ，正在尝试 强制退出 !!!  "
        if [[ $(id -u) -eq 0 ]]; then
            # 以普通用户权限发送 kill 信号
            echo -e "...  （已完成30秒等待）Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 pkill 强制退出 '$brew_process_name' 进程 ，以便执行 后续更新 ... "   
            local targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
            sudo -u "$targetUser" /usr/bin/pkill -x "$brew_process_name"
        else
            echo -e "...  （已完成30秒等待）当前用户'$USER'，为普通权限，直接运行 pkill 强制退出 '$brew_process_name' 进程 ，以便执行 后续更新 ... "     
            /usr/bin/pkill -x "$brew_process_name"
        fi
    else
        echo -e "✓  已完成退出!!!! 进程 '$brew_process_name' 没有阻塞退出，没有启动30秒等待 !!!  "

    fi

}



# ************************* #
# 自定义函数：统一的错误输出（带着色与日志追加）
# ************************* #

print_error() {
  printf "\033[1;31m[ERROR]\033[0m  "
  printf "[ERROR] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
  echo -e "$*" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
}







# =========================
# Xcode Command Line Tools
# =========================

check_clt_receipt() {
    /usr/sbin/pkgutil --pkg-info=com.apple.pkg.CLTools_Executables >/dev/null 2>&1 \
    || /usr/sbin/pkgutil --pkg-info=com.apple.pkg.DeveloperToolsCLI >/dev/null 2>&1
}

_auto_find_clt_label() {
    /usr/sbin/softwareupdate --list 2>&1 \
    | /usr/bin/grep -Eo 'Label: .*Command Line Tools.*' \
    | /usr/bin/sed 's/^Label: //; q'
}

auto_install_clt() {
    local TMPFLAG="/tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress"
    local LOGA="$LOG_FULL_LAST" LOGB="$LOG_FULL_FILE"

    echo -e "⚙️  Command Line Tools 收据缺失，尝试自动安装 ..." | tee -a "$LOGA" "$LOGB"

    sudo /bin/rm -f "$TMPFLAG" 2>/dev/null || true
    sudo /usr/bin/touch "$TMPFLAG"

    local LABEL; LABEL="$(_auto_find_clt_label)"

    if [ -z "$LABEL" ] && [ -d /Library/Developer/CommandLineTools ] && ! check_clt_receipt; then
        echo -e "↻ 未找到标签，疑似残留安装；清理并重试一次 ..." | tee -a "$LOGA" "$LOGB"
        sudo /bin/rm -rf /Library/Developer/CommandLineTools
        sudo /bin/rm -f "$TMPFLAG" 2>/dev/null || true
        sudo /usr/bin/touch "$TMPFLAG"
        LABEL="$(_auto_find_clt_label)"
    fi

    if [ -n "$LABEL" ]; then
        echo -e "⚙️  安装: $LABEL" | tee -a "$LOGA" "$LOGB"
        if sudo /usr/sbin/softwareupdate --install "$LABEL" --agree-to-license --verbose 2>&1 | tee -a "$LOGA" "$LOGB"; then
            sudo /bin/rm -f "$TMPFLAG" 2>/dev/null || true
            return 0
        fi
    fi

    sudo /bin/rm -f "$TMPFLAG" 2>/dev/null || true
    echo -e "❌ 未找到 Command Line Tools 更新标签。请手动执行：xcode-select --install" \
        | tee -a "$LOGA" "$LOGB" "$LOG_ERROR_FILE"
    return 1
}

ensure_clt_or_skip_macports() {
    if check_clt_receipt; then
        return 0
    fi
    if auto_install_clt && check_clt_receipt; then
        return 0
    fi
    echo -e "⏭️  跳过 MacPorts：尚未检测到有效的 Command Line Tools 收据。" \
        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_ERROR_FILE"
    return 1
}



# =========================
# MacPorts 辅助函数
# =========================

# 判断是否需要迁移：当 Darwin 主版本、CPU 架构或 MacPorts base 版本变化时迁移
get_darwin_major() { /usr/bin/uname -r | /usr/bin/awk -F. '{print $1}'; }
get_arch() { /usr/bin/uname -m; }
get_macports_base_ver() { /opt/local/bin/port version 2>/dev/null | /usr/bin/awk '{print $2}'; }

MP_STATE_DIR="$HOME/.local/state/usercmd"
MP_MIGRATE_TOKEN_FILE="$MP_STATE_DIR/macports.migrate.token"

macports_should_migrate() {
    /bin/mkdir -p "$MP_STATE_DIR" 2>/dev/null || true
    local cur_token="$(get_darwin_major)-$(get_arch)-$(get_macports_base_ver)"
    [ ! -f "$MP_MIGRATE_TOKEN_FILE" ] && { echo "$cur_token" > "$MP_STATE_DIR/.need_migrate.tmp"; return 0; }
    local old_token; old_token="$(/bin/cat "$MP_MIGRATE_TOKEN_FILE" 2>/dev/null || echo "")"
    if [ "$old_token" != "$cur_token" ]; then
        echo "$cur_token" > "$MP_STATE_DIR/.need_migrate.tmp"
        return 0
    fi
    return 1
}

macports_mark_migrated() {
    [ -f "$MP_STATE_DIR/.need_migrate.tmp" ] && /bin/mv -f "$MP_STATE_DIR/.need_migrate.tmp" "$MP_MIGRATE_TOKEN_FILE"
}

# 静默升级过期端口并生成摘要
macports_upgrade_outdated_quiet() {
    printf  "\033[1;34m[Download & Install]\033[0m " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    printf  "[Download & Install] "                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "MacPorts 下载安装 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    echo -e "【升级摘要】" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 使用 -u 开关可在升级完成后卸载旧版本，以便在完成升级后自动清理老版本；--no-rev-upgrade 禁止在升级之后触发 rev-upgrade 检查
    sudo /opt/local/bin/port -u upgrade outdated -N --no-rev-upgrade 2>&1 \
      | /usr/bin/grep -E '^--->  (Upgrading|Installing|Activating|Deactivating) |^Error:' \
      | /usr/bin/sed -E \
        -e 's/^--->[[:space:]]+Upgrading[[:space:]]+([^[:space:]]+)[[:space:]]+@([^[:space:]]+)[[:space:]]+to[[:space:]]+@([^[:space:]]+).*/• \1  \2  →  \3/' \
        -e 's/^--->[[:space:]]+Installing/• Installing/' \
        -e 's/^--->[[:space:]]+Activating/• Activating/' \
        -e 's/^--->[[:space:]]+Deactivating/• Deactivating/' \
      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
}

macports_rev_upgrade_quiet() {
    # 显示扫描与结果，不落独立文件，只写主日志
    sudo /opt/local/bin/port rev-upgrade 2>&1 \
      | /usr/bin/grep -E '^--->  Scanning binaries for linking errors|^--->  No broken (files|ports) found\.|^Found [0-9]+ broken|^--->  Rebuilding ' \
      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
}


__get_migrate_log_file() {
    local base=""
    [ -n "${LOG_UPDATE_MACUPDATER:-}" ] && base="$LOG_UPDATE_MACUPDATER"
    [ -z "$base" ] && [ -n "${UPDATE_MACUPDATER_LOG:-}" ] && base="$UPDATE_MACUPDATER_LOG"
    [ -z "$base" ] && [ -f "$HOME/Update_MacUpdater.log" ] && base="$HOME/Update_MacUpdater.log"
    [ -z "$base" ] && [ -n "${LOG_FULL_LAST:-}" ] && base="$LOG_FULL_LAST"
    [ -z "$base" ] && [ -n "${LOG_FULL_FILE:-}" ] && base="$LOG_FULL_FILE"
    [ -z "$base" ] && base="$HOME/Update_MacUpdater.log"
    local dir="${base%/*}"; [ "$dir" = "$base" ] && dir="$HOME"
    echo "${dir}/Migrate_MacPorts.log"
}






# -----------------------------------------------
# 检查 & 创建 ：Log日志文件
# -----------------------------------------------

# 重置LOG_FULL_LAST日志文件
cat /dev/null > "$LOG_FULL_LAST"

# 检查LOG_FILE日志文件是否存在
if [ ! -f "$LOG_FILE" ]; then
    # 文件不存在，创建文件
    touch "$LOG_FILE"
fi

# 检查LOG_ERROR_FILE日志文件是否存在
if [ ! -f "$LOG_ERROR_FILE" ]; then
    # 文件不存在，创建文件
    touch "$LOG_ERROR_FILE"
fi

# 检查LOG_FULL_FILE日志文件是否存在
if [ ! -f "$LOG_FULL_FILE" ]; then
    # 文件不存在，创建文件
    touch "$LOG_FULL_FILE"
else
    # 文件存在，检查文件大小
    FILE_SIZE=$(stat -f%z "$LOG_FULL_FILE") # macOS 使用 stat -f%z

    if [ "$FILE_SIZE" -gt 10 ]; then
        # 如果文件大小超过100字节，执行以下操作
        echo -e "" >> "$LOG_FULL_FILE"
        echo -e "" >> "$LOG_FULL_FILE"
        echo -e "" >> "$LOG_FULL_FILE"
        echo -e "" >> "$LOG_FULL_FILE"
        echo -e "" >> "$LOG_FULL_FILE"
        echo -e "" >> "$LOG_FULL_FILE"
    fi
fi

# 初始化 MacUpdater 日志文件
echo -e "MacUpdater 执行日志 - $(date)" > "$LOG_MACUPDATER_FILE"



# ---------------------------------------
# 检测：外网是否能正常访问
# ---------------------------------------

echo $PWD

echo -e ""                                                                              | tee -a "$LOG_ERROR_FILE"
echo -e "-------------------------------------------------------------------"           | tee -a "$LOG_ERROR_FILE" > /dev/null
echo -e "" >> "$LOG_ERROR_FILE"
echo -e "[自动更新]  $(date '+%Y-%m-%d %H:%M:%S')  "                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_ERROR_FILE" 
echo -e "======================================================================="       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
printf  "测试网络（海外 HTTPS 连接） ...  ｜  "                                         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_ERROR_FILE" 
echo -e "当前工作目录 = '$PWD' "                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_ERROR_FILE" 
echo -e ""                                                                              | tee -a "$LOG_ERROR_FILE" > /dev/null

# 轮询检查网络连通性
while true; do

    # 调用检查时间范围函数
    check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

    # 检查 TARGET_1 的连接
    if ! check_connection "$TARGET_1" "$LOG_ERROR_FILE"; then
        continue # 如果连接失败，重新开始循环
    fi

    # 检查 TARGET_2 的连接
    if ! check_connection "$TARGET_2" "$LOG_ERROR_FILE"; then
        continue # 如果连接失败，重新开始循环
    fi

    # 检查 TARGET_3 的连接
    if ! check_connection "$TARGET_3" "$LOG_ERROR_FILE"; then
        continue # 如果连接失败，重新开始循环
    fi

    # 检查 TARGET_4 的连接
    if ! check_connection "$TARGET_4" "$LOG_ERROR_FILE"; then
        continue # 如果连接失败，重新开始循环
    fi

    # 如果N个目标，都成功连接，退出循环
    printf "\033[1;32m[OK]\033[0m   "  
    printf "[OK]   "                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "海外 HTTPS 连接正常 ... ✅ "                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    break

done

echo -e "======================================================================="       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"





# -----------------------------------------------
# 检查 ：工作目录（权限） 是否 正确分配
# -----------------------------------------------


echo -e "测试安装环境：$(date '+%Y-%m-%d %H:%M:%S') ... "                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

echo -e "\033[1;36m-----------------------------------------------\033[0m" 
echo -e "\033[1;36m 检查 ：工作目录 & 权限 ...                     \033[0m"
echo -e "\033[1;36m-----------------------------------------------\033[0m" 

echo -e "----------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "检查 ：工作目录 & 权限            "                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "----------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

# （可选）确保 Homebrew 路径在前         
# echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
# printf  "\033[1;34m[INFO]\033[0m "
# printf  "[INFO] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
# printf  "PATH     (环境变量) = "                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
# echo -e "'$PATH'"                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# ========= 环境初始化 =========

# 日志函数：统一时间戳格式，保持原有打印风格

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

printf  "\033[1;34m[INFO]\033[0m "
printf  "[INFO] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "根目录   (当前用户) = '$HOME'"                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

printf  "\033[1;34m[INFO]\033[0m "
printf  "[INFO] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "工作目录 (当前脚本) = '$(pwd)'"                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

printf  "\033[1;34m[INFO]\033[0m "
printf  "[INFO] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "当前用户            = '$USER'"                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

# 获取当前工作目录
current_dir=$(pwd)

# 使用 if 语句比较 $HOME 和当前目录
if [ "$HOME" != "$current_dir" ]; then
    # 如果不相等，切换到 $HOME
    cd "$HOME"
    echo -e "\033[1;32m[OK]工作目录 已切换为 : '$(pwd)' \033[0m "
    echo -e "[OK] 工作目录 已切换为 : '$(pwd)' "                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
else
    # 如果相等，打印无需切换
    echo -e "\033[1;32m[OK] 无需切换 工作目录 \033[0m "
    echo -e "[OK] 无需切换 工作目录 "                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
fi

# ========= 环境初始化结束 =========

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  



# -----------------------------------------------
# 检查 1 ：Homebrew 是否安装（并更新）
# -----------------------------------------------

echo -e "\033[1;36m-----------------------------------------------\033[0m" 
echo -e "\033[1;36m 检测 “Homebrew与系统架构” 是否匹配 ...        \033[0m"
echo -e "\033[1;36m-----------------------------------------------\033[0m" 

echo -e "----------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "检测 “Homebrew与系统架构” 是否匹配"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "----------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

# 检测系统架构

architecture=$(uname -m)

if [ "$architecture" = "arm64" ]; then

    # 检查 Homebrew 是否已安装
    if ! command -v brew > /dev/null 2>&1 ; then

        printf  "\033[1;34m[INFO]\033[0m "
        printf  "[INFO] "                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "未检测到 Homebrew，开始安装 Homebrew ... "                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
        
        # 添加 Homebrew 到环境变量
        echo -e 'eval "$(/opt/homebrew/bin/brew shellenv)"' >> ~/.zprofile
        eval "$(/opt/homebrew/bin/brew shellenv)"
        
        printf  "\033[1;34m[INFO]\033[0m "
        printf  "[INFO] "                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "Homebrew 安装完成。"                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        echo -e ""                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        exit 1

    fi

    # 获取 Homebrew 的 安装路径
    brew_path=$(brew --prefix)
    printf  "\033[1;34m[INFO]\033[0m "
    printf  "[INFO] "                                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "Homebrew目录 : '$brew_path'"                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 获取 CPU 的 芯片型号
    cpu_chip=$(sysctl -n machdep.cpu.brand_string)
    printf  "\033[1;34m[INFO]\033[0m "
    printf  "[INFO] "                                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "CPU 芯片型号 : '$cpu_chip'"                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 获取 CPU 的 处理器指令集
    cpu_isa=$(uname -m)
    printf  "\033[1;34m[INFO]\033[0m "
    printf  "[INFO] "                                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "CPU   指令集 : '$cpu_isa'"                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 获取 OS 的 版本名称
    os_name=$(awk '/SOFTWARE LICENSE AGREEMENT FOR macOS/' '/System/Library/CoreServices/Setup Assistant.app/Contents/Resources/en.lproj/OSXSoftwareLicense.rtf' | awk -F 'macOS ' '{print $NF}' | awk '{print substr($0, 0, length($0)-1)}')
    os_name=$(echo "$os_name" | tr '[:upper:]' '[:lower:]')  # 
    printf  "\033[1;34m[INFO]\033[0m "
    printf  "[INFO] "                                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "MacOS   版本 : '$os_name'"                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
   #echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    if [[ $cpu_isa == "arm64" && $brew_path == "/opt/homebrew" ]]; then

        printf  "\033[1;32m[OK]\033[0m   "
        printf  "[OK]   "                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "Homebrew 无需更改"                                                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 更新 Homebrew
        echo -e ""                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        echo -e ""                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

        echo -e "\033[1;36m-----------------------------------------------\033[0m" 
        echo -e "\033[1;36m 更新 Homebrew 工具 ...\033[0m"
        echo -e "\033[1;36m-----------------------------------------------\033[0m" 

        echo -e "----------------------------------"                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "更新 Homebrew 工具 "                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "----------------------------------"                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

        echo -e ""                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

        # 检查是否以 root 身份运行
        if [ "$(id -u)" -eq 0 ]; then
            # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
            targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
            echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 Homebrew 自更新 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            # 以目标用户身份执行 Homebrew 命令：更新索引
            sudo -H -u "$targetUser" bash -c 'brew update --force 2>&1'                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            # 关闭匿名使用统计，提升隐私
            echo -e "✓  设置 Homebrew analytics off" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            sudo -H -u "$targetUser" bash -c 'brew analytics off 2>&1'                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
           ## 执行 brew doctor 进行环境自检，不影响整体退出码
           #echo -e "✓  执行 brew doctor 自检" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
           #sudo -H -u "$targetUser" bash -c 'brew doctor || true'                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        else
            echo -e "✓   当前用户'$USER'，为普通权限，直接运行 Homebrew 自更新 ... "             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            brew update --force 2>&1                                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            # 关闭匿名使用统计，提升隐私
            echo -e "✓  设置 Homebrew analytics off" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            brew analytics off 2>&1                                                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
           ## 执行 brew doctor 进行环境自检，不影响整体退出码
           #echo -e "✓  执行 brew doctor 自检" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
           #brew doctor || true                                                         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        fi

       #exit 1

     elif [[ $cpu_isa == "arm64" && $brew_path == "/usr/local" ]]; then

        printf  "\033[1;31m[ERROR]\033[0m "
        printf  "[ERROR] "                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "检测到当前 Homebrew 为 x86_64 版本，准备切换为 ARM 版本  ❌"           | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        
        # exit 1   # 调试使用！！！

        # 提示用户确认卸载 x86_64 版本的 Homebrew
        #read -p "此操作将卸载 x86_64 版本的 Homebrew，并安装 ARM 版本。是否继续？(y/N): " confirm
        #if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        #    print_info "取消操作。"
        #    exit 1
        #fi

        # 卸载 x86_64 版本的 Homebrew
        echo -e "✓   正在卸载 x86_64 版本的 Homebrew ... "                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/uninstall.sh)"                         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        
        # 安装 ARM 版本的 Homebrew
        echo -e "✓   正在安装 ARM 版本的 Homebrew ... "                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 非交互式安装
        NONINTERACTIVE=1 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        
        # 添加 Homebrew 到环境变量
        echo -e 'eval "$(/opt/homebrew/bin/brew shellenv)"' >> ~/.zprofile
        eval "$(/opt/homebrew/bin/brew shellenv)"
        
        echo -e "✓  ARM 版本的 Homebrew 安装完成。"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

        # 获取 Homebrew 的安装路径
        brew_newpath=$(which brew)
        echo -e "✓  检测到 Homebrew 安装路径: $brew_newpath"                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        echo -e ""                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

        if [[ $brew_newpath == /opt/homebrew/* ]]; then
            printf  "\033[1;32m[OK]\033[0m "
            printf  "[OK]   "                                                           | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
            echo -e "验证结果：当前 Homebrew 为 ARM 版本。"                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
           #echo -e ""                                                                  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        elif [[ $brew_newpath == /usr/local/* ]]; then
            printf  "\033[1;31m[ERROR]\033[0m "
            printf  "[ERROR] "                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
            echo -e "验证结果：检测到当前 Homebrew 为 x86_64 版本。退出"                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
           #echo -e ""                                                                  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        else
            printf  "\033[1;31m[ERROR]\033[0m "
            printf  "[ERROR] "                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
            echo -e "验证结果：检测未知版本。退出"                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
           #echo -e ""                                                                  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        fi

    else

        print_error "未知的 Homebrew 安装路径: $brew_path"                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
       #echo -e ""                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    fi

else

    printf "当前系统不是 ARM 架构 (Apple Silicon)，本脚本暂不支持。"                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
   #echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    exit 1 

fi

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 





# ------------------------------------------------
# 检查 2 ：其他Homebrew工具 是否安装（并更新）
# ------------------------------------------------

# 调用检查时间范围函数
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

if ! brew list | grep -q "^jq$" || ! brew list | grep -q "^coreutils$" || ! brew list | grep -q "^parallel$" || ! brew list | grep -q "^aria2$";  then
    echo -e ""                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "\033[1;36m 安装 其他必备工具 ...\033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 

    echo -e "----------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "安装 其他必备工具 "                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "----------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
fi

if ! brew list | grep -q "^aria2$"; then
    printf  "\033[1;34m[INFO]\033[0m "
    echo -e "[安装] aria2 ... "                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    brew install aria2                                                                  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
fi

if ! brew list | grep -q "^parallel$"; then
    printf  "\033[1;34m[INFO]\033[0m "
    echo -e "[安装] parallel ... "                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    brew install parallel                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
fi

if ! brew list | grep -q "^coreutils$"; then
    printf  "\033[1;34m[INFO]\033[0m "
    echo -e "[安装] coreutils ... "                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    brew install coreutils                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
fi

if ! brew list | grep -q "^jq$"; then
    printf  "\033[1;34m[INFO]\033[0m "
    echo -e "[安装] jq ... "                                                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    brew install jq                                                                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
fi

if ! brew tap | grep -q '^buo/cask-upgrade$'; then
    printf  "\033[1;34m[INFO]\033[0m "
    echo -e "[安装] buo/cask-upgrad ... "                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    brew tap buo/cask-upgrade                                                           | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
fi



# -----------------------------------------------
# 检查 3 ：Mas 是否安装（并更新）
# -----------------------------------------------

# 调用检查时间范围函数
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

if brew list --formula | grep -q "^mas\$"; then

    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "\033[1;36m 更新 Mas 工具 ...\033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 

    echo -e "----------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "更新 Mas 工具"                                                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "----------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    # 检查是否以 root 身份运行
    if [ "$(id -u)" -eq 0 ]; then
        # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
        targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 Mas 自更新 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 以目标用户身份执行 Homebrew 命令
        sudo -H -u "$targetUser" bash -c 'brew upgrade mas 2>&1'       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    else
        echo -e "✓  当前用户'$USER'，为普通权限，直接运行 Mas 自更新 ... "            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        brew upgrade mas 2>&1                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    fi

else

    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "\033[1;36m Mas 未安装，开始安装 ...\033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "----------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "Mas 未安装，开始安装"                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "----------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

    # 检查是否以 root 身份运行
    if [ "$(id -u)" -eq 0 ]; then
        # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
        targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 Mas 安装 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 以目标用户身份执行 Homebrew 命令
        sudo -H -u "$targetUser" bash -c 'brew reinstall --force mas 2>&1'              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    else
        echo -e "✓  当前用户'$USER'，为普通权限，直接运行 Mas 安装 ... "                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        brew reinstall --force mas 2>&1                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    fi

    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    if [ $? -eq 0 ]; then
        echo -e "Mas 安装成功。"                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    else
        echo -e "Mas 安装失败。"                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    fi

fi

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 





# -----------------------------------------------
# 检查 4 ：MacPorts 是否安装（并更新）
# -----------------------------------------------

# 调用检查时间范围函数
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

if command -v /opt/local/bin/port >/dev/null 2>&1; then

    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "\033[1;36m 更新 MacPorts 工具 ...\033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "----------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "更新 MacPorts 工具  "       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "----------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e ""                         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 保证 CLT 收据存在，否则跳过 MacPorts 更新
    if ensure_clt_or_skip_macports; then
        # MacPorts 基础更新：仅运行自更新以更新 MacPorts base 和 ports 树
        sudo /opt/local/bin/port selfupdate 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    fi

else
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "\033[1;36m MacPorts 未安装，开始安装 ...\033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "----------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "MacPorts 未安装，开始安装  "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "----------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null


    if ensure_clt_or_skip_macports; then
        macos_version=$(sw_vers -productVersion)
        major_version=${macos_version%%.*}

        license_file="/System/Library/CoreServices/Setup Assistant.app/Contents/Resources/en.lproj/OSXSoftwareLicense.rtf"
        raw_codename=$(awk -F 'macOS ' '/SOFTWARE LICENSE AGREEMENT FOR macOS/ {print $NF}' "$license_file" \
                        | sed -E 's/[[:punct:]]*$//' | sed -E 's/[0-9].*$//' | tr '[:upper:]' '[:lower:]' | xargs)
        codename_camel=$(echo "$raw_codename" | awk '{for(i=1;i<=NF;i++){printf toupper(substr($i,1,1)) substr($i,2)}}')

        latest_version=$(curl -s https://api.github.com/repos/macports/macports-base/releases/latest \
                         | sed -n 's/.*\"tag_name\": \"v\\([0-9.]*\\)\".*/\\1/p')
        [ -z "$latest_version" ] && latest_version="2.11.5"

        pkg_name="MacPorts-${latest_version}-${major_version}-${codename_camel}.pkg"
        pkg_url="https://github.com/macports/macports-base/releases/download/v${latest_version}/${pkg_name}"
        echo "准备安装 MacPorts，下载地址：$pkg_url"

        curl -L -o /tmp/macports.pkg "$pkg_url" && \
        sudo /usr/sbin/installer -pkg /tmp/macports.pkg -target / && \
        /bin/rm -f /tmp/macports.pkg
    fi

fi


echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 







# -----------------------------------------------
# 检查 5 ：TopGrade 是否安装（并更新）
# -----------------------------------------------

# 调用检查时间范围函数
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

if brew list --formula | grep -q "^topgrade\$"; then

    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "\033[1;36m 更新 TopGrade 工具 ...\033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "----------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "更新 TopGrade 工具"                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "----------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    # 检查是否以 root 身份运行
    if [ "$(id -u)" -eq 0 ]; then
        # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
        targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 topgrade 自更新 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 以目标用户身份执行 Homebrew 命令
        sudo -H -u "$targetUser" bash -c 'brew upgrade --greedy --force topgrade 2>&1'  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    else
        echo -e "✓  当前用户'$USER'，为普通权限，直接运行 topgrade 自更新 ... "       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        brew upgrade --greedy --force topgrade 2>&1                                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    fi

else

    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "\033[1;36m TopGrade 未安装，开始安装 ...\033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "----------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "TopGrade 未安装，开始安装"                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "----------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    # 检查是否以 root 身份运行
    if [ "$(id -u)" -eq 0 ]; then
        # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
        targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 topgrade 安装 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 以目标用户身份执行 Homebrew 命令
        sudo -H -u "$targetUser" bash -c 'brew reinstall --force topgrade 2>&1'         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    else
        echo -e "✓  当前用户'$USER'，为普通权限，直接运行 topgrade 安装 ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        brew reinstall --force topgrade 2>&1                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    fi
    
    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    if [ $? -eq 0 ]; then
        echo -e "✅ TopGrade 安装成功。"                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        echo -e ""                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    else
        echo -e "❌ TopGrade 安装失败。"                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    fi

fi

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 




# ------------------------------------------------
# 检查 6 ：MacUpdater 是否安装（并更新）
# ------------------------------------------------

# 调用检查时间范围函数
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

if brew list --cask | grep -q "^macupdater\$"; then
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "\033[1;36m 更新 MacUpdater 工具 ...\033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "----------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "更新 MacUpdater 工具"                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "----------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
    # 检查是否以 root 身份运行
    if [ "$(id -u)" -eq 0 ]; then
        # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
        targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 macupdater 自更新 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 以目标用户身份执行 Homebrew 命令
        sudo -H -u "$targetUser" bash -c 'brew upgrade --greedy --cask macupdater 2>&1'  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    else
        echo -e "✓  当前用户'$USER'，为普通权限，直接运行 macupdater 自更新 ... "     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        brew upgrade --greedy --cask macupdater 2>&1                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    fi

else

    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "\033[1;36m MacUpdater 未安装，开始安装 ...\033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "----------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "MacUpdater 未安装，开始安装 "                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "----------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    
    # 检查是否以 root 身份运行
    if [ "$(id -u)" -eq 0 ]; then
        # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
        targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 macupdater 安装 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 以目标用户身份执行 Homebrew 命令
        sudo -H -u "$targetUser" bash -c 'brew reinstall --cask --force macupdater 2>&1'       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    else
        echo -e "✓  当前用户'$USER'，为普通权限，直接运行 macupdater 安装 ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        brew reinstall --cask --force macupdater 2>&1                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    fi
    
    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    if [ $? -eq 0 ]; then
        echo -e "✅ MacUpdater 安装成功。"                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        echo -e ""                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    else
        echo -e "❌ MacUpdater 安装失败。"                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    fi
fi
    
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
#echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 



# ----------------------------------
# 记录：开始时间
# ----------------------------------

# 等待3秒，开始执行
#sleep 3  

# 记录当前时间戳（到$LOG_FILE）
echo -e "-------------------------------------------------"                             | tee -a "$LOG_FILE"  > /dev/null
echo -e "开始更新 APP: $(date)"                                                         | tee -a "$LOG_FILE"  > /dev/null


# 记录当前时间戳（到$$LOG_FULL_FILE），
echo -e  ""                                                                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

echo -e "\033[1;34m-----------------------------------------------\033[0m" 
echo -e "\033[1;34m 开始更新 APP: $(date)                         \033[0m"
echo -e "\033[1;34m-----------------------------------------------\033[0m" 
echo -e "----------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "开始更新 APP: $(date)"                                                         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "----------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

echo -e  ""                                                                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e  ""                                                                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"




# 此后，开始升级第三方APP！！！！！！此前都是在，检测环境 和更新 升级程序本身。



# -----------------------------------------------
# 在更新操作前：备份桌桌面布局（Launchpad）
# -----------------------------------------------

echo -e "\033[1;32m-----------------------------------------------\033[0m" 
echo -e "\033[1;32m 备份 桌面布局（Launchpad）                    \033[0m"
echo -e "\033[1;32m-----------------------------------------------\033[0m" 

echo -e "----------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "备份 桌面布局（Launchpad）"                                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "----------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null


echo -e ""                                                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

# 备份 Launchpad 和 桌面布局

if [ "$(id -u)" -eq 0 ]; then

    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 获取桌面布局 所需的 \$targetUser 与 路径 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 获取目标普通用户（优先用 SUDO_USER，否则取当前控制台登录用户）
    targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
    targetHome=$(eval echo -e "~$targetUser")    # 目标用户的 $HOME
    USER_NAME="$targetUser"
    HOME="$targetHome"                        # 覆盖当前shell的HOME

    # 获取目标用户的 TMPDIR 路径（使用 getconf）
    userTmpDir=$(sudo -H -u "$targetUser" getconf DARWIN_USER_TEMP_DIR)
    userTmpDir="${userTmpDir%/}"                        # 移除末尾斜杠，标准化路径

else

    echo -e "✓  当前用户'$USER'，为普通权限，直接运行 获取 桌面布局 所需的 \$TMPDIR \$TMPDIR ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    USER_NAME="$USER"
    userTmpDir="$TMPDIR"

fi

# 记录目标用户及其TMPDIR路径到日志
echo -e "活跃用户 = $USER_NAME " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e "用户路径 = $userTmpDir" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# USER_ID=$(basename "$(dirname "$userTmpDir")")      # 提取TMPDIR路径中的随机目录ID
# PARENT_DIR=$(find /System/Volumes/Data/private/var/folders/ -maxdepth 2 -type d -name "$USER_ID" -print -quit 2>/dev/null)
# BACKUP_PATH="$ICLOUD_PATH/BACKUP/$COMPUTER_NAME/$USER_NAME"
# BACKUP_DATE=$(date +%Y-%m-%d)
# PATH_DesktopLayout_BACKUP="$BACKUP_PATH/DesktopLayout/$BACKUP_DATE"

USER_ID=$(basename "$(dirname "$userTmpDir")")      # 提取TMPDIR路径中的随机目录ID
PARENT_DIR=$(find /System/Volumes/Data/private/var/folders/ -maxdepth 2 -type d -name "$USER_ID" -print -quit 2>/dev/null)
# 根据新的目录规则生成 BACKUP 路径。以设备标识目录（型号名称-芯片名称-序列号）为基础，并包含用户名目录。
BACKUP_BASE="$ICLOUD_PATH/BACKUP/${DEVICE_DIR}"
# 如果 BACKUP_BASE 末尾已包含用户名，则不再追加；否则追加用户名目录。
if [[ "$BACKUP_BASE" == */"$USER_NAME" ]]; then
    BACKUP_PATH="$BACKUP_BASE"
else
    BACKUP_PATH="$BACKUP_BASE/$USER_NAME"
fi
BACKUP_DATE=$(date +%Y-%m-%d)
PATH_DesktopLayout_BACKUP="$BACKUP_PATH/DesktopLayout/$BACKUP_DATE"


# Launchpad plist 位于 Library/Preferences
PATH_DesktopLayout_plist_SOURCE="$HOME/Library/Preferences"
# Launchpad DB 位于 PARENT_DIR/0/com.apple.dock.launchpad/db/db
PATH_DesktopLayout_db_SOURCE="$PARENT_DIR/0"

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

printf  "\033[1;34m[Info]\033[0m "
printf  "[Info] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "桌面布局 备份路径：'$PATH_DesktopLayout_BACKUP'"                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

printf  "\033[1;34m[Info]\033[0m "
printf  "[Info] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "桌面布局 恢复路径: '$PATH_DesktopLayout_db_SOURCE'"                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

mkdir -p "$PATH_DesktopLayout_BACKUP"
errorFlag=0  # 初始化错误标志

# 备份 com.apple.spaces.plist
cp -rf "$PATH_DesktopLayout_plist_SOURCE/com.apple.spaces.plist" "$PATH_DesktopLayout_BACKUP/"
if [ $? -ne 0 ]; then
    echo -e "\033[1;33m[Warn]   com.apple.spaces.plist 备份失败 ⚠️ \033[0m"
    echo -e "[Warn]   com.apple.spaces.plist 备份失败 ⚠️ " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    errorFlag=1
fi

# 备份 com.apple.dock.plist
cp -rf "$PATH_DesktopLayout_plist_SOURCE/com.apple.dock.plist" "$PATH_DesktopLayout_BACKUP/"
if [ $? -ne 0 ]; then
    echo -e "\033[1;33m[Warn]   com.apple.dock.plist 备份失败 ⚠️ \033[0m"
    echo -e "[Warn]   com.apple.dock.plist 备份失败 ⚠️ " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    errorFlag=1
fi

# 备份 Launchpad 数据库目录
sudo cp -rf "$PATH_DesktopLayout_db_SOURCE/com.apple.dock.launchpad" "$PATH_DesktopLayout_BACKUP/"
if [ $? -ne 0 ]; then
    echo -e "\033[1;33m[Warn]   com.apple.dock.launchpad 目录备份失败 ⚠️ \033[0m"
    echo -e "[Warn]   com.apple.dock.launchpad 目录备份失败 ⚠️ " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    errorFlag=1
fi

# 设置权限（如有需要也可检查 chmod 的返回码）
cd "$PATH_DesktopLayout_BACKUP"
sudo chmod -R 755 "./com.apple.dock.launchpad"

echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 根据 errorFlag 输出最终结果
if [ $errorFlag -eq 0 ]; then
    echo -e "\033[1;32m[OK] 备份 桌面布局  运行已完成 ✅ \033[0m"
    echo -e "[OK]   备份 桌面布局  运行已完成 ✅ " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
else
    echo -e "\033[1;33m[Warn] 备份 桌面布局  运行已完成，但部分项目失败 ⚠️ \033[0m"
    echo -e "[Warn]   桌面布局 备份完成，但部分项目失败 ⚠️ " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
fi

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 










# ----------------------------------
# 开始执行：Homebrew
# ----------------------------------

export HOMEBREW_NO_INTERACTIVE=1

echo -e "\033[1;32m-----------------------------------------------\033[0m" 
echo -e "\033[1;32m 运行 HomeBrew ...                             \033[0m"
echo -e "\033[1;32m-----------------------------------------------\033[0m" 

echo -e "----------------------------------"                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "运行 HomeBrew"                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "----------------------------------"                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null


# 等待3秒，开始执行
#sleep 3  

# 调用检查时间范围函数
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

echo -e ""                                                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

printf  "\033[1;34m[List]\033[0m "
printf  "[List] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "Homebrew 应用列表 ... "                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
#( brew upgrade --debug --verbose --greedy )

# 检查是否以 root 身份运行
if [ "$(id -u)" -eq 0 ]; then

    # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
    targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 brew list ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 4️⃣ 所有项目（公式 + Cask）
    brew_formula_count=$(sudo -H -u "$targetUser" bash -lc 'brew list --formula -1 | wc -l' )
    brew_cask_count=$(sudo -H -u "$targetUser" bash -lc 'brew list --cask -1 | wc -l' )

else

    echo -e "✓  当前用户'$USER'，为普通权限，直接运行 brew list ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    # 所有项目（公式 + Cask）
    brew_formula_count=$(brew list --formula -1 | wc -l)
    brew_cask_count=$(brew list --cask -1 | wc -l)

fi


# 计算 APP 数量（假设 brew_installed_apps 是 brew list 的正常输出）
brew_cask_count=$((( brew_cask_count * 2 ) /2 ))
brew_formula_count=$((( brew_formula_count *2 ) /2 ))
brew_app_count=$(( brew_formula_count + brew_cask_count ))
echo -e "✅  APP 数量（ Homebrew formula ）：$brew_formula_count  "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e "✅  APP 数量（ Homebrew Cask    ）：$brew_cask_count  "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e "✅  APP 数量（ Homebrew         ）：$brew_app_count  "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"


echo -e ""                                                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 


printf  "\033[1;34m[Scan]\033[0m "
printf  "[Scan] "                                                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "Homebrew 扫描更新 ... "                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

if [ "$(id -u)" -eq 0 ]; then
  targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
  echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 brew outdated --greedy ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
  brew_outdated=$(
    sudo -H -u "$targetUser" bash -lc 'brew outdated --greedy' 2>/dev/null | awk '{print $1}'
  )
  brew_outdated_formulas=$(
    sudo -H -u "$targetUser" bash -lc 'brew outdated --formula --greedy' 2>/dev/null | awk '{print $1}'
  )
  brew_outdated_casks=$(
    sudo -H -u "$targetUser" bash -lc 'brew outdated --cask --greedy' 2>/dev/null | awk '{print $1}'
  )
else
  echo -e "✓  当前用户'$USER'，为普通权限，直接运行 brew outdated --greedy ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
  brew_outdated=$(
    brew outdated --greedy 2>/dev/null | awk '{print $1}'
  )
  brew_outdated_formulas=$(
    brew outdated --formula --greedy 2>/dev/null | awk '{print $1}'
  )
  brew_outdated_casks=$(
    brew outdated --cask --greedy 2>/dev/null | awk '{print $1}'
  )
fi

# 兼容 bash 3.2：逐行构建数组（避免 read -a 只读到第一行）
packages_brew=()
while IFS= read -r pkg; do
  [[ -n "$pkg" ]] && packages_brew+=("$pkg")
done <<< "$brew_outdated"

packages_brew_formulas=()
while IFS= read -r pkg; do
  [[ -n "$pkg" ]] && packages_brew_formulas+=("$pkg")
done <<< "$brew_outdated_formulas"

packages_brew_casks=()
while IFS= read -r pkg; do
  [[ -n "$pkg" ]] && packages_brew_casks+=("$pkg")
done <<< "$brew_outdated_casks"

# 分类打印（先判定 cask，再判定 formula）
for pkg in "${packages_brew[@]}"; do
  if printf '%s\n' "${packages_brew_casks[@]}"     | grep -qxF -- "$pkg"; then
    echo -e "✅  检测到新版本 [cask]    : $pkg"   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
  elif printf '%s\n' "${packages_brew_formulas[@]}" | grep -qxF -- "$pkg"; then
    echo -e "✅  检测到新版本 [formula] : $pkg" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
  else
    echo -e "✅  检测到新版本 [unknown] : $pkg" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
  fi
done



# 在获取 brew_outdated 列表并组装 packages_brew_formulas/casks 之后添加：
updated_list=()   # 初始化数组，用于保存每个更新项的结果

# 如果有需要更新的 Homebrew 软件包，则执行下载
if [ ${#packages_brew[@]} -ne 0 ]; then

    echo -e ""                                                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 第 2 步：并行下载（提高下载速度）
    printf "\033[1;34m[Download]\033[0m "
    printf "[Download] "                                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "开始下载：HomeBrew formula / cask（ 并行 ） ... "                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 构造平台键：Apple Silicon 带前缀，Intel 不带前缀
    platform_key=""
    if [ -n "$os_name" ]; then
      if [ "$cpu_isa" = "arm64" ]; then
        platform_key="${cpu_isa}_${os_name}"   # 例如 "arm64_sonoma"
      else
        platform_key="$os_name"            # 例如 "sonoma"
      fi
    fi



    # 筛选需要下载的 formula 软件包：如果缓存中已有完整的新版本则跳过
    packages_to_fetch_formulas=()
    for pkg_brew_formula in "${packages_brew_formulas[@]}"; do

        [[ -z "$pkg_brew_formula" ]] && continue  # 跳过空名称项（以防万一）

        #brew_cache_path=$(brew --cache --formula "$pkg_brew_formula")
        # 获取 Homebrew 缓存包路径（在 Root 权限下通过目标用户环境获取正确路径）
        if [ "$(id -u)" -eq 0 ]; then
            targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
            brew_cache_path=$(sudo -n -H -u "$targetUser" /bin/bash -lc "brew --cache --formula \"$pkg_brew_formula\"" 2>/dev/null)
        else
            brew_cache_path=$(brew --cache --formula "$pkg_brew_formula")
        fi
        #echo -e "brew_cache_path = $brew_cache_path"                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        
        if [ -f "$brew_cache_path" ]; then
            ################################################################
            # 修正：brew --cache 返回的路径可能指向 bottle_manifest.json
            # 这种情况下校验会错误，因为 manifest 文件和真正的瓶子文件 sha 不同。
            # 如果检测到文件名以 .bottle_manifest.json 结尾，尝试在同目录搜索对应
            # 的 .bottle.tar.gz 文件并替换 brew_cache_path。
            ################################################################
            if [[ "$brew_cache_path" == *.bottle_manifest.json ]]; then
                cache_dir="$(dirname "$brew_cache_path")"
                # 搜索第一个匹配该公式名称的瓶子文件
                candidate=$(ls "$cache_dir" 2>/dev/null | grep -E "${pkg_brew_formula}.*\.bottle.*\.tar\.gz$" | head -n1 || true)
                if [ -n "$candidate" ]; then
                    brew_cache_path="$cache_dir/$candidate"
                fi
            fi
            local_sha=$(shasum -a 256 "$brew_cache_path" | awk '{print $1}')
            ############################################
            # 计算 brew_expected_sha —— 自动降权 + 双日志输出
            ############################################
            if [ "$(id -u)" -eq 0 ]; then
                # 1. 解析目标普通用户（Lingon 经 sudo 调用时 SUDO_USER 存在）
                targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"

                # 2. 日志提示
                echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_formula 的 SHA256 查询 ... " \
                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

                # 3. 在目标用户登录环境中执行 brew info 获取 JSON
                json=$(sudo -n -H -u "$targetUser" /bin/bash -lc "brew info --json=v2 \"$pkg_brew_formula\"" 2>/dev/null)
            else
                # ------- 已是普通用户 -------
                echo -e "✓  当前用户'$USER'，为普通权限，直接运行 $pkg_brew_formula 的 SHA256 查询 ... " \
                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

                # 在当前用户环境中执行 brew info 获取 JSON
                json=$(brew info --json=v2 "$pkg_brew_formula" 2>/dev/null)
            fi

            # 提取对应的 SHA256（优先当前平台的 bottle，其次通用 bottle，最后源码 checksum）
            brew_expected_sha=""
            if [ -n "$json" ]; then
                if [ -n "$platform_key" ]; then
                    brew_expected_sha=$(/usr/bin/plutil -extract "formulae.0.bottle.stable.files.${platform_key}.sha256" \
                                 raw -o - - <<< "$json" 2>/dev/null)
                fi
                if [ -z "$brew_expected_sha" ]; then
                    brew_expected_sha=$(/usr/bin/plutil -extract "formulae.0.bottle.stable.files.all.sha256" \
                                 raw -o - - <<< "$json" 2>/dev/null)
                fi
                if [ -z "$brew_expected_sha" ]; then
                    brew_expected_sha=$(/usr/bin/plutil -extract "formulae.0.urls.stable.checksum" \
                                 raw -o - - <<< "$json" 2>/dev/null)
                fi
            fi

            if [ -n "$brew_expected_sha" ] && [ "$local_sha" = "$brew_expected_sha" ]; then
                echo -e "✅  [已缓存] 最新版 ｜ SHA256 ：$brew_expected_sha ｜ [formula] ：$pkg_brew_formula  "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                continue  # 略过重新下载
            else
                echo -e "⚠️  [SHA256异常] $pkg_brew_formula [formula]" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                echo -e "   -  已下载包 ：$local_sha "    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                echo -e "   -  homebrew ：$brew_expected_sha " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            fi
        fi

        packages_to_fetch_formulas+=("$pkg_brew_formula")

    done


    # 筛选需要下载的 cask 软件包：如果缓存中已有完整的新版本则跳过
    packages_to_fetch_casks=()
    for pkg_brew_cask in "${packages_brew_casks[@]}"; do

        [[ -z "$pkg_brew_cask" ]] && continue  # 跳过空名称项

        #brew_cache_path=$(brew --cache --cask "$pkg_brew_cask")
        # 获取 Homebrew 缓存包路径（在 Root 权限下通过目标用户环境获取正确路径）
        if [ "$(id -u)" -eq 0 ]; then
            targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
            brew_cache_path=$(sudo -n -H -u "$targetUser" /bin/bash -lc "brew --cache --cask \"$pkg_brew_cask\"" 2>/dev/null)
        else
            brew_cache_path=$(brew --cache --cask "$pkg_brew_cask")
        fi
        #echo -e "brew_cache_path = $brew_cache_path"                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

        if [ -f "$brew_cache_path" ]; then
            local_sha=$(shasum -a 256 "$brew_cache_path" | awk '{print $1}')
            ############################################
            # 计算 brew_expected_sha —— 自动降权 + 双日志输出
            ############################################
            if [ "$(id -u)" -eq 0 ]; then
                # 1. 解析目标普通用户（Lingon 经 sudo 调用时 SUDO_USER 存在）
                targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"

                # 2. 日志提示
                echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_cask 的 SHA256 查询 ... " \
                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

                # 3. 在目标用户登录环境中执行 brew info 获取 JSON
                json=$(sudo -n -H -u "$targetUser" /bin/bash -lc "brew info --json=v2 \"$pkg_brew_cask\"" 2>/dev/null)
            else
                # ------- 已是普通用户 -------
                echo -e "✓  当前用户'$USER'，为普通权限，直接运行 $pkg_brew_cask 的 SHA256 查询 ... "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

                # 在当前用户环境中执行 brew info 获取 JSON
                json=$(brew info --json=v2 "$pkg_brew_cask" 2>/dev/null)
            fi

            # 提取 cask 的 SHA256（某些 cask 可能无 SHA 信息，例如 :latest 或 auto_updates）
            brew_expected_sha=""
            if [ -n "$json" ]; then
                brew_expected_sha=$(/usr/bin/plutil -extract "casks.0.sha256" raw -o - - <<< "$json" 2>/dev/null)
            fi

            if [[ "$brew_expected_sha" == "null" || -z "$brew_expected_sha" ]]; then
                echo -e "✅  [已缓存] 无校验版 ｜ [cask] ：：$pkg_brew_cask " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                continue
            fi
            if [ "$local_sha" = "$brew_expected_sha" ]; then
                echo -e "✅  [已缓存] 最新版 ｜ SHA256 ：$brew_expected_sha ｜    [cask] ：$pkg_brew_cask  "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                continue
            fi
        fi

        packages_to_fetch_casks+=("$pkg_brew_cask")

    done



    # 并行下载需要更新的 formula 和 cask（使用 --retry 自动校验缓存有效性） 注意，与 下面的 parallel 方案 二选一。建议使用Parallel，因为速度更快。
    # printf '%s\n' "${packages_to_fetch_formulas[@]}" | xargs -n1 -P16 brew fetch --formula --retry         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # printf '%s\n' "${packages_to_fetch_casks[@]}"    | xargs -n1 -P8 brew fetch --cask --retry             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 确保 GNU Parallel 已安装（macOS 可通过 Homebrew 安装）
    if ! command -v parallel &>/dev/null; then

          # 安装 GNU Parallel 并行执行工具 [oai_citation:3‡formulae.brew.sh](https://formulae.brew.sh/formula/parallel#:~:text=Install%20command%3A)
          # 检查是否以 root 身份运行
          if [ "$(id -u)" -eq 0 ]; then
              # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
              targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
              echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 parallel 安装 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
              # 以目标用户身份执行 Homebrew 命令
              sudo -H -u "$targetUser" bash -c 'brew reinstall --force parallel 2>&1'         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
          else
              echo -e "✓  当前用户'$USER'，为普通权限，直接运行 parallel 安装 ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
              brew reinstall --force parallel 2>&1                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
          fi

    fi

    ##############################################################################
    # 函数: run_as_normal_user
    # 说明: 若脚本当前 UID=0，则解析 targetUser 并用 sudo -E -H -u targetUser
    #       执行传入的整条命令；否则直接执行。不硬编码用户名。
    ##############################################################################
    run_as_normal_user() {
      if [ "$(id -u)" -eq 0 ]; then
          # 取触发脚本的真实用户; 若无 SUDO_USER, 退回控制台登录用户
          local targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
    
          # 友好提示一次（防止重复刷屏，可按需注释）
          printf '\033[1;34m[INFO]\033[0m '
          #echo -e "Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行: $*"  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
          echo -e "Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 并行下载（parallel download）安装包"  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    
          # -n 非交互；-E 保留 LOG_* 环境变量；-H 修正 HOME
          sudo -n -E -H -u "$targetUser" "$@"
      else
          # 已是普通用户
          "$@"
      fi
    }
    export -f run_as_normal_user      # 供 GNU parallel 内部 shell 调用 (需要时)
    export LOG_FULL_LAST LOG_FULL_FILE   # 让 sudo -E 能继承日志路径

    # -----------------------------------------------------------------------------
    # 新增：定义下载函数用于并行下载 formula 和 cask，支持重试并记录失败链接
    #
    # 这两个函数会被 GNU parallel 调用以下载对应的软件包。当下载失败时，会按
    # DOWNLOAD_MAX_RETRIES 指定的次数进行重试，并在最终失败时把包名和
    # 下载链接追加写入失败记录文件，供后续安装阶段判断是否跳过升级。
    fetch_brew_formula() {
        local pkg="$1"
        local success=0
        local tmpfile
        tmpfile=$(mktemp)
        # 下载失败重试次数与校验失败重试次数
        local max_download_retry=${DOWNLOAD_MAX_RETRIES:-5}
        local max_sha_retry=${SHA_MISMATCH_MAX_RETRIES:-1}
        local download_attempt=0
        local sha_attempt=0
        # 循环尝试：根据错误类型分别重试
        while true; do
            download_attempt=$((download_attempt + 1))
            brew fetch --formula --retry "$pkg" 2>&1 \
                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" \
                | tee "$tmpfile"
            fetch_exit=${PIPESTATUS[0]}
            if [ $fetch_exit -ne 0 ]; then
                # 下载失败
                if [ $download_attempt -lt $max_download_retry ]; then
                    sleep 1
                    continue
                else
                    # 达到下载重试上限
                    success=0
                    break
                fi
            fi
            # 下载成功后，校验 SHA
            local brew_cache_path=""
            local brew_expected_sha=""
            local json=""
            if [ "$(id -u)" -eq 0 ]; then
                local targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
                brew_cache_path=$(sudo -n -H -u "$targetUser" /bin/bash -lc "brew --cache --formula \"$pkg\"" 2>/dev/null)
                json=$(sudo -n -H -u "$targetUser" /bin/bash -lc "brew info --json=v2 \"$pkg\"" 2>/dev/null)
            else
                brew_cache_path=$(brew --cache --formula "$pkg")
                json=$(brew info --json=v2 "$pkg" 2>/dev/null)
            fi
            if [ -n "$brew_cache_path" ] && [ -f "$brew_cache_path" ]; then
                ################################################################
                # 修正：brew --cache 返回的文件可能是 bottle_manifest.json，而不是真正的瓶子包。
                # 如果是 manifest，则尝试查找同目录的 .bottle.tar.gz 文件并使用该文件计算 SHA。
                ################################################################
                if [[ "$brew_cache_path" == *.bottle_manifest.json ]]; then
                    cache_dir="$(dirname "$brew_cache_path")"
                    candidate=$(ls "$cache_dir" 2>/dev/null | grep -E "${pkg}.*\.bottle.*\.tar\.gz$" | head -n1 || true)
                    if [ -n "$candidate" ]; then
                        brew_cache_path="$cache_dir/$candidate"
                    fi
                fi
                local_sha=$(shasum -a 256 "$brew_cache_path" | awk '{print $1}')
                if [ -n "$json" ]; then
                    brew_expected_sha=$(/usr/bin/plutil -extract "formulae.0.bottle.stable.files.${platform_key}.sha256" raw -o - - <<< "$json" 2>/dev/null)
                    if [ -z "$brew_expected_sha" ]; then
                        brew_expected_sha=$(/usr/bin/plutil -extract "formulae.0.bottle.stable.files.all.sha256" raw -o - - <<< "$json" 2>/dev/null)
                    fi
                    if [ -z "$brew_expected_sha" ]; then
                        brew_expected_sha=$(/usr/bin/plutil -extract "formulae.0.urls.stable.checksum" raw -o - - <<< "$json" 2>/dev/null)
                    fi
                fi
                if [ -n "$brew_expected_sha" ] && [ "$local_sha" != "$brew_expected_sha" ]; then
                    sha_attempt=$((sha_attempt + 1))
                    if [ $sha_attempt -lt $max_sha_retry ]; then
                        rm -f "$brew_cache_path"
                        sleep 1
                        continue
                    fi
                    success=2
                    break
                else
                    success=1
                    break
                fi
            else
                success=1
                break
            fi
        done
        if [ $success -eq 1 ]; then
            echo -e "✅  下载成功 [formula] ：$pkg " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        elif [ $success -eq 2 ]; then
            echo -e "⚠️  下载成功 [formula] ：$pkg (警告：校验码不匹配)" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        else
            echo -e "❌  下载失败 [formula] ：$pkg " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            # 提取最后出现的 URL（若无则为空）
            url=$(grep -oE 'https?://[^[:space:]]+' "$tmpfile" | tail -n1 || true)
            echo "$pkg|$url" >> "$FAILED_FETCH_FORMULAS_FILE"
        fi
        rm -f "$tmpfile"
    }
    export -f fetch_brew_formula

    fetch_brew_cask() {
        local pkg="$1"
        local success=0
        local tmpfile
        tmpfile=$(mktemp)
        # 下载失败重试次数与校验失败重试次数
        local max_download_retry=${DOWNLOAD_MAX_RETRIES:-5}
        local max_sha_retry=${SHA_MISMATCH_MAX_RETRIES:-1}
        local download_attempt=0
        local sha_attempt=0
        while true; do
            download_attempt=$((download_attempt + 1))
            brew fetch --cask --retry "$pkg" 2>&1 \
                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" \
                | tee "$tmpfile"
            fetch_exit=${PIPESTATUS[0]}
            if [ $fetch_exit -ne 0 ]; then
                if [ $download_attempt -lt $max_download_retry ]; then
                    sleep 1
                    continue
                else
                    success=0
                    break
                fi
            fi
            # 下载成功后校验 SHA
            local brew_cache_path=""
            local brew_expected_sha=""
            local json=""
            if [ "$(id -u)" -eq 0 ]; then
                local targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
                brew_cache_path=$(sudo -n -H -u "$targetUser" /bin/bash -lc "brew --cache --cask \"$pkg\"" 2>/dev/null)
                json=$(sudo -n -H -u "$targetUser" /bin/bash -lc "brew info --json=v2 \"$pkg\"" 2>/dev/null)
            else
                brew_cache_path=$(brew --cache --cask "$pkg")
                json=$(brew info --json=v2 "$pkg" 2>/dev/null)
            fi
            if [ -n "$brew_cache_path" ] && [ -f "$brew_cache_path" ]; then
                local_sha=$(shasum -a 256 "$brew_cache_path" | awk '{print $1}')
                if [ -n "$json" ]; then
                    brew_expected_sha=$(/usr/bin/plutil -extract "casks.0.sha256" raw -o - - <<< "$json" 2>/dev/null)
                fi
                if [[ -n "$brew_expected_sha" && "$brew_expected_sha" != "null" && "$local_sha" != "$brew_expected_sha" ]]; then
                    sha_attempt=$((sha_attempt + 1))
                    if [ $sha_attempt -lt $max_sha_retry ]; then
                        rm -f "$brew_cache_path"
                        sleep 1
                        continue
                    fi
                    success=2
                    break
                else
                    success=1
                    break
                fi
            else
                success=1
                break
            fi
        done
        if [ $success -eq 1 ]; then
            echo -e "✅  下载成功 [cask] ：$pkg " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        elif [ $success -eq 2 ]; then
            echo -e "⚠️  下载成功 [cask] ：$pkg (警告：校验码不匹配)" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        else
            echo -e "❌  下载失败 [cask] ：$pkg " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            url=$(grep -oE 'https?://[^[:space:]]+' "$tmpfile" | tail -n1 || true)
            echo "$pkg|$url" >> "$FAILED_FETCH_CASKS_FILE"
        fi
        rm -f "$tmpfile"
    }
    export -f fetch_brew_cask
    # -----------------------------------------------------------------------------


    # ---------------- ① 并行下载 formula ----------------
    if [ ${#packages_to_fetch_formulas[@]} -gt 0 ]; then
      # 使用自定义的 fetch_brew_formula 函数并行下载，每个任务会自动重试和记录失败链接
      run_as_normal_user parallel --will-cite --line-buffer --unsafe -j16 fetch_brew_formula ::: "${packages_to_fetch_formulas[@]}" &
    fi

    # ---------------- ② 并行下载 cask ----------------
    if [ ${#packages_to_fetch_casks[@]} -gt 0 ]; then
      # 使用自定义的 fetch_brew_cask 函数并行下载，每个任务会自动重试和记录失败链接
      run_as_normal_user parallel --will-cite --line-buffer --unsafe -j16 fetch_brew_cask ::: "${packages_to_fetch_casks[@]}" &
    fi
    
    wait  # 等待所有并行任务完成

    #echo -e "✅ 所有下载任务 已完成/已退出"                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
    #brew doctor  2>&1                                                                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    #exit 1                                                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"          # 用于调试 ！！



    brew_formula_upgrade_exit=false
    brew_formula_reinstall_exit=false
    brew_formula_reinstall_force_exit=false

    # 第 3 步：串行安装（Homebrew formula）
    if [ ${#packages_brew_formulas[@]} -ne 0 ] ; then
        echo -e ""                                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        printf "\033[1;34m[Install]\033[0m "
        printf "[Install] "                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "开始更新：HomeBrew formula（ 串行 ） ... "                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

        # 循环逐个处理每个过期的 Homebrew formula
        for pkg_brew_formula in "${packages_brew_formulas[@]}"; do

            # 如果在并行下载阶段检测到该 formula 下载失败，则直接跳过升级
            if [[ -n "$FAILED_FETCH_FORMULAS_FILE" && -f "$FAILED_FETCH_FORMULAS_FILE" ]]; then
                fail_line=$(grep -F "${pkg_brew_formula}|" "$FAILED_FETCH_FORMULAS_FILE" || true)
                if [[ -n "$fail_line" ]]; then
                    fail_url=$(echo "$fail_line" | cut -d'|' -f2-)
                    echo -e "❌  更新失败 [formula] : $pkg_brew_formula (下载失败：$fail_url)" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    updated_list+=("failure|formula|$pkg_brew_formula|fetch_failed:$fail_url")
                    echo -e "--------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    continue
                fi
            fi

            brew_formula_tmpfile=$(mktemp)

            # ---------- 尝试升级 ----------
            # 检查是否以 root 身份运行
            if [ "$(id -u)" -eq 0 ]; then
                # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
                targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
                echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_formula 升级 ( brew upgrade $pkg_brew_formula --verbose --debug ) ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
                # 以目标用户身份执行 Homebrew 命令
                sudo -H -u "$targetUser" bash -c "brew upgrade $pkg_brew_formula 2>&1" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$brew_formula_tmpfile"
            else
                echo -e "✓  当前用户'$USER'，为普通权限，直接运行 $pkg_brew_formula 升级 ( brew upgrade $pkg_brew_formula --verbose --debug ) ... "                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
                brew upgrade "$pkg_brew_formula" 2>&1                                                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$brew_formula_tmpfile" 
            fi

            brew_formula_upgrade_exit=${PIPESTATUS[0]}        # 取 brew upgrade 的退出码
            brew_formula_final_exit=$brew_formula_upgrade_exit             # 先假定最终状态 = 升级状态
            brew_formula_relink_exit=false

            # ---------- 新增：SHA-256 校验失败检测 ----------
            # 如果此次升级失败且输出中含有 SHA-256 mismatch，则提取期望和实际校验码并停止后续尝试
            # 允许用户通过 SHA_MISMATCH_MAX_RETRIES 配置尝试次数（默认为 1）
            if [ "$brew_formula_upgrade_exit" -ne 0 ]; then
                # 查找关键字（兼容大小写）
                if grep -qiE 'sha[- ]?256 mismatch' "$brew_formula_tmpfile"; then
                    # 抽取期望和实际校验码（若有）
                    sha_expected=$(grep -i 'Expected:' "$brew_formula_tmpfile" | head -n1 | sed -E 's/.*Expected:[[:space:]]*//I')
                    sha_actual=$(grep -i 'Actual:' "$brew_formula_tmpfile" | head -n1 | sed -E 's/.*Actual:[[:space:]]*//I')
                    # 输出警告并停止重试
                    echo -e "⚠️  检测到 SHA-256 校验失败 [formula] $pkg_brew_formula ，停止后续尝试。实际校验码: ${sha_actual:-未知} ，期望校验码: ${sha_expected:-未知}" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    # 记录失败状态，方法为 sha256_mismatch:actual:expected
                    updated_list+=("failure|formula|$pkg_brew_formula|sha256_mismatch:${sha_actual:-unknown}:${sha_expected:-unknown}")
                    echo -e "--------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    rm -f "$brew_formula_tmpfile"
                    continue   # 跳过后续链接或重装步骤
                fi
            fi

            # ---------- 若升级失败则尝试重装 ----------
            if [ $brew_formula_upgrade_exit -ne 0 ] ; then

                # 第二次尝试升级：通过 brew link 修复 formula APP 链接 （检查输出中是否包含符号链接冲突提示）
                if grep -q "not symlinked" "$brew_formula_tmpfile" || grep -q "Could not symlink" "$brew_formula_tmpfile"; then

                    echo "⚠️ 检测到 $pkg_brew_formula 升级后，符号链接冲突，尝试执行 'brew link --overwrite $pkg_brew_formula' ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    # 检查是否以 root 身份运行
                    if [ "$(id -u)" -eq 0 ]; then
                        # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
                        targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
                        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_formula 重装 ( brew link --overwrite $pkg_brew_formula )  ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        # 以目标用户身份执行 Homebrew 命令
                        sudo -H -u "$targetUser" bash -c "brew link --overwrite $pkg_brew_formula 2>&1"                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    else
                        echo -e "✓  当前用户'$USER'，为普通权限，直接运行 $pkg_brew_formula 重装 ( brew link --overwrite $pkg_brew_formula ) ... "                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        brew link --overwrite "$pkg_brew_formula" 2>&1                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    fi

                    #brew link --overwrite "$pkg_brew_formula" 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    brew_formula_relink_exit=${PIPESTATUS[0]} 

                    # ---------- 根据最终状态输出结果 ----------
                    if [ $brew_formula_relink_exit -eq 0 ]; then
                        echo "✅  更新成功 [formula] ：$pkg_brew_formula ( 已更新 & 符号链接 ) " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        # 记录成功状态（将$pkg_brew_formula加入成功列表），并跳过后续的重装尝试
                        if [ $brew_formula_upgrade_exit -ne 0 ]; then
                            if [ $brew_formula_relink_exit -eq 0 ]; then
                                brew_formula_method="relink"
                            fi
                        else
                            brew_formula_method="upgrade"
                        fi     
                        #updated_list+=("success|formula|$pkg_brew_formula|$brew_formula_method")
                        if [ $brew_formula_final_exit -eq 0 ] ; then
                            updated_list+=("success|formula|$pkg_brew_formula|$brew_formula_method")
                        else
                            updated_list+=("failure|formula|$pkg_brew_formula|$brew_formula_method")
                        fi
                        echo -e "--------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        rm -f "$brew_formula_tmpfile"
                        continue   # 进入下一个 formula 处理
                    else
                        echo -e "⚠️  符号链接 失败 [formula] $pkg_brew_formula ，继续尝试 重新安装 ( brew reinstall $pkg_brew_formula --verbose --debug ) ... "                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    fi

                    # 若强制链接仍失败，下面会继续执行重装逻辑
                fi

                # 第三次尝试升级：通过 brew reinstall  升级 formula APP
                echo -e "⚠️ upgrade 失败，尝试 重装 ( brew reinstall $pkg_brew_formula --verbose --debug ) ... "                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                # 检查是否以 root 身份运行
                if [ "$(id -u)" -eq 0 ]; then
                    # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
                    targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
                    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_formula 重装 ( brew reinstall $pkg_brew_formula --verbose --debug )  ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    # 以目标用户身份执行 Homebrew 命令
                    sudo -H -u "$targetUser" bash -c "brew reinstall $pkg_brew_formula 2>&1"                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                else
                    echo -e "✓  当前用户'$USER'，为普通权限，直接运行 $pkg_brew_formula 重装 ( brew reinstall $pkg_brew_formula --verbose --debug ) ... "                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    brew reinstall "$pkg_brew_formula" 2>&1                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                fi

                brew_formula_reinstall_exit=${PIPESTATUS[0]}  # 取 brew reinstall 的退出码
                brew_formula_final_exit=$brew_formula_reinstall_exit

                # 第四次尝试升级：通过 brew reinstall --force 升级 formula APP
                if [ $brew_formula_reinstall_exit -ne 0 ]; then
                    echo -e "⚠️ reinstall 失败，尝试 强制重装 ( brew reinstall --force $pkg_brew_formula --verbose --debug ) ... "                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    # 检查是否以 root 身份运行
                    if [ "$(id -u)" -eq 0 ]; then
                        # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
                        targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
                        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_formula 强制重装 ( brew reinstall --force $pkg_brew_formula --verbose --debug )  ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        # 以目标用户身份执行 Homebrew 命令
                        sudo -H -u "$targetUser" bash -c "brew reinstall --force $pkg_brew_formula 2>&1"                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    else
                        echo -e "✓  当前用户'$USER'，为普通权限，直接运行 $pkg_brew_formula 强制重装 ( brew reinstall --force $pkg_brew_formula --verbose --debug ) ... "                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        brew reinstall --force "$pkg_brew_formula" 2>&1                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    fi
                    brew_formula_reinstall_force_exit=${PIPESTATUS[0]}  # 取 brew reinstall 的退出码
                    brew_formula_final_exit=$brew_formula_reinstall_force_exit
                fi
            fi

            # ---------- 根据最终状态输出结果 ----------
            if [ $brew_formula_final_exit -eq 0 ] ; then
                echo -e "✅  更新成功 [formula] ：$pkg_brew_formula "                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            else
                echo -e "❌  更新失败 [formula] ：$pkg_brew_formula "                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            fi

            #brew_formula_method=$([ $brew_formula_upgrade_exit -ne 0 ] && echo "reinstall" || echo "upgrade")
            if [ $brew_formula_upgrade_exit -ne 0 ]; then
                if [ $brew_formula_reinstall_exit -eq 0 ]; then
                    brew_formula_method="reinstall"
                    brew_formula_reinstall_exit=0
                elif [ $brew_formula_reinstall_force_exit -eq 0 ]; then
                    brew_formula_method="reinstall_force"
                    brew_formula_reinstall_exit=0
                fi
            else
                brew_formula_method="upgrade"
            fi    

            #updated_list+=("success|cask|$pkg_brew_formula|$brew_formula_method")
            if [ $brew_formula_final_exit -eq 0 ] ; then
                updated_list+=("success|formula|$pkg_brew_formula|$brew_formula_method")
            else
                updated_list+=("failure|formula|$pkg_brew_formula|$brew_formula_method")
            fi

            echo -e "--------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            rm -f "$brew_formula_tmpfile"

        done

    else

        echo -e ""                                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        printf "\033[1;34m[Install]\033[0m "
        printf "[Install] "                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "无需更新：HomeBrew formula ... "                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        #echo -e ""                                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    fi






    brew_cask_upgrade_exit=false
    brew_cask_reinstall_exit=false
    brew_cask_reinstall_force_exit=false

    # 第 4 步：串行安装（Homebrew cask）
    if [ ${#packages_brew_casks[@]} -ne 0 ] ; then
        echo -e ""                                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        printf  "\033[1;34m[Install]\033[0m "
        printf  "[Install] "                                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "开始更新：HomeBrew cask（ 串行 ） ... "                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

        # 存储需要关闭和重启的应用程序
        #brew_cask_apps_to_restart=()

        # 逐个安装 每个待更新的 cask app
        for pkg_brew_cask in "${packages_brew_casks[@]}"; do

            # 如果在并行下载阶段检测到该 cask 下载失败，则直接跳过升级
            if [[ -n "$FAILED_FETCH_CASKS_FILE" && -f "$FAILED_FETCH_CASKS_FILE" ]]; then
                fail_line=$(grep -F "${pkg_brew_cask}|" "$FAILED_FETCH_CASKS_FILE" || true)
                if [[ -n "$fail_line" ]]; then
                    fail_url=$(echo "$fail_line" | cut -d'|' -f2-)
                    echo -e "❌  更新失败 [cask]   : $pkg_brew_cask (下载失败：$fail_url)" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    updated_list+=("failure|cask|$pkg_brew_cask|fetch_failed:$fail_url")
                    echo -e "--------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    continue
                fi
            fi

            # 新增：为 cask 升级输出创建临时文件，避免变量未定义导致 tee 报错
            brew_cask_tmpfile=$(mktemp)

            # 初始化每个 cask 应用的状态变量
            brew_cask_app_name=""
            brew_cask_exec_name=""
            brew_cask_process_name=""
            brew_cask_app_id=""
            brew_cask_was_running=false

            # ------- 判断当前用户权限：Root 或 普通用户 -------
            if [[ $(id -u) -eq 0 ]]; then
                # 1) 如果是 root，降权至目标普通用户执行 brew info
                targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
                echo -e "✓  Root权限降权至普通权限 ($targetUser) 后，查询 cask 信息..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                brew_cask_info_output=$(sudo -H -u "$targetUser" /bin/bash -lc "brew info --cask \"$pkg_brew_cask\"" 2>&1 | tee -a /dev/tty "$LOG_FULL_LAST" "$LOG_FULL_FILE")
            else
                # 2) 如果已是普通用户，直接执行 brew info
                echo -e "✓  当前用户 '$USER' 为普通权限，直接查询 cask 信息..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                brew_cask_info_output=$(brew info --cask "$pkg_brew_cask" 2>&1 | tee -a /dev/tty "$LOG_FULL_LAST" "$LOG_FULL_FILE")
            fi


            #exit 1                                                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"          # 用于调试 ！！

            # ---------- 升级 cask 应用 ----------   

            # 第一次尝试升级：通过 brew upgrade 升级 APP
            if [ "$(id -u)" -eq 0 ]; then
              # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
              targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
              echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_cask 升级 ( brew upgrade --cask --greedy $pkg_brew_cask --verbose --debug ) ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
              # 以目标用户身份执行 Homebrew 命令
              sudo -H -u "$targetUser" bash -c "brew upgrade --cask --greedy $pkg_brew_cask 2>&1"         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$brew_cask_tmpfile"
            else
              echo -e "✓  当前用户'$USER'，为普通权限，直接运行 $pkg_brew_cask 升级 ( brew upgrade --cask --greedy $pkg_brew_cask --verbose --debug ) ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
              brew upgrade --cask --greedy "$pkg_brew_cask" 2>&1                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$brew_cask_tmpfile"
            fi

            brew_cask_upgrade_exit=${PIPESTATUS[0]}        # 取 brew upgrade 的退出码
            brew_cask_final_exit=$brew_cask_upgrade_exit             # 先假定最终状态 = 升级状态

            # ---------- 新增：SHA-256 校验失败检测 ----------
            # 当首次升级失败且输出包含 SHA-256 mismatch 时，直接记录失败并跳过后续重装
            if [ "$brew_cask_upgrade_exit" -ne 0 ]; then
                if grep -qiE 'sha[- ]?256 mismatch' "$brew_cask_tmpfile"; then
                    sha_expected=$(grep -i 'Expected:' "$brew_cask_tmpfile" | head -n1 | sed -E 's/.*Expected:[[:space:]]*//I')
                    sha_actual=$(grep -i 'Actual:' "$brew_cask_tmpfile" | head -n1 | sed -E 's/.*Actual:[[:space:]]*//I')
                    echo -e "⚠️  检测到 SHA-256 校验失败 [cask]   $pkg_brew_cask ，停止后续尝试。实际校验码: ${sha_actual:-未知} ，期望校验码: ${sha_expected:-未知}" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    updated_list+=("failure|cask|$pkg_brew_cask|sha256_mismatch:${sha_actual:-unknown}:${sha_expected:-unknown}")
                    echo -e "--------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    rm -f "$brew_cask_tmpfile"
                    continue   # 跳过后续重装
                fi
            fi

            # ---------- 若升级失败则尝试重装 ----------
            if [ $brew_cask_upgrade_exit -ne 0 ] ; then

                # 注意：⚠️ cask不需要 重新链接 ！

                # 第二次尝试升级：通过 brew reinstall 升级 APP  
                echo -e "⚠️ upgrade 失败，尝试重装 ( brew reinstall --cask $pkg_brew_cask --verbose --debug ) ... "                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                # 检查是否以 root 身份运行
                if [ "$(id -u)" -eq 0 ]; then
                    # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
                    targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
                    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_cask 重装 ( brew reinstall --cask $pkg_brew_cask --verbose --debug ) ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    # 以目标用户身份执行 Homebrew 命令
                    sudo -H -u "$targetUser" bash -c "brew reinstall --cask  $pkg_brew_cask 2>&1"       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                else
                    echo -e "✓  当前用户'$USER'，为普通权限，直接运行 $pkg_brew_cask 重装 ( brew reinstall --cask $pkg_brew_cask --verbose --debug ) ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
                    brew reinstall --cask "$pkg_brew_cask" 2>&1                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                fi
   
                brew_cask_reinstall_exit=${PIPESTATUS[0]}    # 获取 brew reinstall 的退出码  
                brew_cask_final_exit=$brew_cask_reinstall_exit       # 将最终状态更新为 reinstall 的状态  



                # 如果第二次尝试仍然失败。尝试关闭线程，然后开始尝试 第三次更升级，通过 brew reinstall --force 强制升级 APP。  
                if [ $brew_cask_reinstall_exit -ne 0 ]; then

                    # 尝试从输出中提取应用的 .app 行（如果存在）
                    brew_cask_app_line=$(echo "$brew_cask_info_output" | grep -m1 '\.app (App)')
                    if [[ -n "$brew_cask_app_line" ]]; then
                        # 提取应用程序包名（去掉“.app (App)”标记和多余空格）
                        brew_cask_app_name=$(echo "$brew_cask_app_line" | sed -e 's/\.app (App)//' -e 's/^[[:space:]]*//')
                    fi

                    if [[ -n "$brew_cask_app_name" ]]; then
                            echo -e "✓  检测到应用名称 = '$brew_cask_app_name.app' ，通过命令 ( brew info $pkg_brew_cask ) 输出的 Artifacts 字段。应用名称用来，关闭进程。已防止阻碍后续更新 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    fi

                    # 如果未找到 .app 信息且检测到 .pkg 安装包，则解析 .pkg 获取应用名称和进程名
                    if [[ -z "$brew_cask_app_line" && $(echo "$brew_cask_info_output" | grep -c '\.pkg (Pkg)') -gt 0 ]]; then

                        echo -e "✘  未能从 brew info $pkg_brew_cask 中，提取到安装后的 应用名称（*.app） ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

                        # 提取即将安装的版本号（优先从 brew info 第一行获取）
                        brew_cask_new_version="$(echo "$brew_cask_info_output" | awk -F'[: ]+' 'NR==1{print $3}')"
                        if [[ -z "$brew_cask_new_version" ]]; then
                            brew_cask_new_version="$(brew info --cask --json=v2 "$pkg_brew_cask" 2>/dev/null | grep -m1 '"version"' | sed -E 's/.*"version": *"([^"]+)".*/\1/')"
                        fi
                        # 构造 .pkg 文件路径（Homebrew Cask 默认安装路径）
                        brew_cask_pkg_line="$(echo "$brew_cask_info_output" | grep -m1 '\.pkg (Pkg)')"
                        brew_cask_pkg_file_name="$(echo "$brew_cask_pkg_line" | awk '{print $1}')"
                        brew_cask_pkg_path="/opt/homebrew/Caskroom/$pkg_brew_cask/$brew_cask_new_version/$brew_cask_pkg_file_name"

                        echo -e "✓  准备通过 解压缩 $brew_cask_pkg_file_name.pkg 安装包，寻找安装包内的 *.app 文件（安装后的的APP名称） ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        echo -e "✓  解析到 pkg 安装包 的 本地路径：$brew_cask_pkg_path ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

                        if [[ -f "$brew_cask_pkg_path" ]]; then
                            # 创建临时目录并展开 .pkg 文件
                            brew_cask_tmp_dir="$("/usr/bin/mktemp" -d)"
                            /usr/sbin/pkgutil --expand "$brew_cask_pkg_path" "$brew_cask_tmp_dir"
                            # 利用 lsbom 列出安装清单中的 .app 路径列表
                            brew_cask_app_paths="$(find "$brew_cask_tmp_dir" -name '*.bom' -exec /usr/bin/lsbom -f {} \; | sed -n 's#^\(.*\.app\)/Contents/.*#\1#p' | sort -u)"
                            # 遍历 .pkg 安装包含的应用路径（使用 while 逐行读取，支持路径中含空格）
                            while IFS= read -r app_rel_path; do
                                full_app_path="/$app_rel_path"   # .pkg 安装路径是系统根目录起始
                                if [[ -d "$full_app_path" ]]; then
                                    # 读取应用的 Info.plist 获取可执行文件名和 Bundle ID
                                    brew_cask_exec_name="$(/usr/bin/defaults read "$full_app_path/Contents/Info.plist" CFBundleExecutable 2>/dev/null)"
                                    brew_cask_bundle_id="$(/usr/bin/defaults read "$full_app_path/Contents/Info.plist" CFBundleIdentifier 2>/dev/null)"
                                    if [[ -n "$brew_cask_exec_name" ]]; then
                                        brew_cask_app_name="$full_app_path"    # 保存应用程序路径
                                        brew_cask_process_name="$brew_cask_exec_name"    # 对应进程名（用于 pkill/killall）
                                        brew_cask_app_id="$brew_cask_bundle_id"          # 应用 Bundle ID（用于 AppleScript 定位）
                                        echo -e "✓  检测到 .pkg 将安装应用：$full_app_path，进程名：$brew_cask_process_name" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                                        # 如检测到该进程正在运行则尝试关闭
                                        #if pgrep -ix "$brew_cask_process_name" > /dev/null; then
                                        #    echo -e "✓  检测到 $brew_cask_process_name 正在运行，正在尝试退出 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                                        #    ( /usr/bin/osascript -e "tell application id \"$brew_cask_app_id\" to quit" || /usr/bin/pkill -x "$brew_cask_process_name" ) 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                                        #    sleep 5   # 等待进程退出完成
                                        #    brew_cask_was_running=true
                                        #fi
                                        # 检测到目标应用正在运行则尝试关闭（优雅退出 + 超时强杀）
                                        if pgrep -ix "$brew_cask_process_name" > /dev/null; then
                                            echo -e "✓  检测到 '$brew_cask_process_name' (pkg) 正在运行，正在尝试退出 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                                            attempt_quit_app "$brew_cask_app_id" "$brew_cask_process_name" 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                                            brew_cask_was_running=true   # 标记应用本来是运行状态（供后续决定是否重启）
                                        fi

                                        break   # 已找到目标应用，退出循环
                                    fi
                                fi
                            done <<< "$brew_cask_app_paths"
                            # 清理临时文件
                            /bin/rm -rf "$brew_cask_tmp_dir"
                        fi
                        # 有的时候，由于pkg内部还会套多个pkg，故对pkg第一次解压缩后，可能拿不到.app文件名。此时就会获取不到应用名称。
                        # 对于这种情况，建议直接使用 brew info 的 Name 字段作为候选
                        # 如果仍未从 .pkg 中提取到应用名，则使用 brew info 的 Name 字段作为候选
                        if [[ -z "$brew_cask_exec_name" ]]; then
                            echo -e "✘  未能从 $pkg_brew_cask 的 pkg 安装包 $brew_cask_pkg_line 中，提取到安装后的 应用名称（*.app）..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                            echo -e "✘  由于 pkg 内嵌套多个 pkg 。此时就会 获取不到 应用名称 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                            brew_cask_name_line="$(echo "$brew_cask_info_output" | awk '/^==> Name$/{getline; print}')"
                            echo -e "✓  使用 brew info $pkg_brew_cask 的 Name 字段 $brew_cask_name_line ，作为安装后的 应用名称（$brew_cask_name_line.app），查询并关闭 相应进程 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                            brew_cask_app_name="$brew_cask_name_line"
                            [[ "$brew_cask_app_name" =~ Pro\ DC$ ]] && brew_cask_app_name="${brew_cask_app_name// Pro DC/}"   # 去除特殊后缀（如 "Pro DC"）
                            brew_cask_process_name="$brew_cask_app_name"
                        fi
                    fi

                    # 根据提取的应用名/进程名，尝试关闭正在运行的应用以便升级

                    # 如 brew_cask_app_id 为空（非 .pkg 安装），尝试查找已安装的 .app 路径并读取 Info.plist 获取 Bundle ID 和 可执行文件名
                    if [[ -n "$brew_cask_app_name" && -z "$brew_cask_app_id" ]]; then
                        # 搜索常见安装路径 /Applications 和 ~/Applications 下的 .app
                        if [[ -d "/Applications/$brew_cask_app_name.app" ]]; then
                            full_app_path="/Applications/$brew_cask_app_name.app"
                        elif [[ -d "$HOME/Applications/$brew_cask_app_name.app" ]]; then
                            full_app_path="$HOME/Applications/$brew_cask_app_name.app"
                        else
                            # 若上述路径未找到，检查 Homebrew Caskroom 目录
                            if [[ -d "/opt/homebrew/Caskroom/$pkg_brew_cask" ]]; then
                                full_app_path=$(find "/opt/homebrew/Caskroom/$pkg_brew_cask" -maxdepth 4 -type d -name "$brew_cask_app_name.app" -print -quit)
                            fi
                            if [[ -z "$full_app_path" && -d "/usr/local/Caskroom/$pkg_brew_cask" ]]; then
                                full_app_path=$(find "/usr/local/Caskroom/$pkg_brew_cask" -maxdepth 4 -type d -name "$brew_cask_app_name.app" -print -quit)
                            fi
                        fi

                        # 如果找到已安装的 .app，读取其 Info.plist 获取进程名和 Bundle ID
                        if [[ -n "$full_app_path" && -d "$full_app_path" ]]; then
                            brew_cask_exec_name=$(/usr/bin/defaults read "$full_app_path/Contents/Info.plist" CFBundleExecutable 2>/dev/null)
                            brew_cask_bundle_id=$(/usr/bin/defaults read "$full_app_path/Contents/Info.plist" CFBundleIdentifier 2>/dev/null)
                            if [[ -n "$brew_cask_exec_name" ]]; then
                                brew_cask_process_name="$brew_cask_exec_name"
                                brew_cask_app_id="$brew_cask_bundle_id"
                                echo -e "✓  当前APP的，应用名：'$brew_cask_app_name' ; 路径名：'$full_app_path' ; 进程名：'$brew_cask_process_name' " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                            fi
                        fi
                    fi

                    # 如仍未设置进程名（非 .pkg 安装且未找到 Info），则使用应用名称作为进程名
                    [[ -z "$brew_cask_process_name" ]] && brew_cask_process_name="$brew_cask_app_name"

                    if pgrep -ix "$brew_cask_process_name" > /dev/null; then
                        echo -e "✓  检测到 $brew_cask_process_name (app) 正在运行。开始尝试退出 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        attempt_quit_app "$brew_cask_app_id" "$brew_cask_process_name" 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        brew_cask_was_running=true   # 标记应用原本处于运行状态（更新后需重启）
                        echo -e "✓  退出 '$brew_cask_process_name' 进程 已完成 ... " 
                    else
                        echo -e "✓  直接升级！！！ $brew_cask_app_name 未运行" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    fi

                fi


                # 第三次尝试升级：再次尝试关闭阻碍更新的进程，并通过 brew reinstall --force 升级 APP
                if [ $brew_cask_reinstall_exit -ne 0 ]; then
                      # 若重装失败且检测到应用仍在运行，强制关闭后再重试一次
                      if pgrep -ix "$brew_cask_app_name" > /dev/null; then
                          brew_cask_pid=$(pgrep -f "$brew_cask_app_name")
                          echo -e "⚠️ 检测到 $brew_cask_app_name ( PID = $brew_cask_pid ) 仍在运行，尝试强制关闭，然后再次尝试 reinstall 覆盖安装 ... "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                          if [ -n "$brew_cask_pid" ]; then
                              kill -9 "$brew_cask_pid"
                          fi
                      else
                          echo -e "✓  $brew_cask_app_name 未发现其运行，准备尝试 reinstall --force 强制覆盖安装 !!! "          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                      fi
       
                      # 检查是否以 root 身份运行
                      if [ "$(id -u)" -eq 0 ]; then
                          echo -e "⚠️ upgrade 失败，尝试 强制覆盖安装 ( brew reinstall --cask --force $pkg_brew_cask --verbose --debug ) ... "                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                          # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
                          targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
                          echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_cask 强制覆盖安装 ( brew reinstall --cask --force $pkg_brew_cask --verbose --debug ) ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                          # 以目标用户身份执行 Homebrew 命令
                          sudo -H -u "$targetUser" bash -c "brew reinstall --cask --force $pkg_brew_cask 2>&1"       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                      else
                          echo -e "✓  当前用户'$USER'，为普通权限，直接运行 $pkg_brew_cask 强制覆盖安装 ( brew reinstall --cask --force $pkg_brew_cask --verbose --debug ) ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
                          brew reinstall --cask --force "$pkg_brew_cask" 2>&1                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                      fi
       
                      #brew reinstall --cask --force "$pkg_brew_cask" 2>&1                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
       
                      brew_cask_reinstall_force_exit=${PIPESTATUS[0]}
                      brew_cask_final_exit=$brew_cask_reinstall_force_exit       # 将最终状态更新为 reinstall 的状态  
                fi


                # 第四次尝试升级 ：对于需要手动更新的app，单独处理 （ 如：paragon-ntfs、paragon-extfs ）
                if [[ " ${MANUAL_INSTALL_CASKS[*]} " == *" $pkg_brew_cask "* ]]; then
                  echo -e "⚠️  $pkg_brew_cask 需要手动安装，尝试运行其安装器..."

                  # 根据 Homebrew 前缀确定 Caskroom 路径（Intel 在 /usr/local/Caskroom）
                  caskroom_base=$(brew --prefix)/Caskroom

                  # 查找 FSInstaller.app 的最新版本路径
                  manual_installer_app=$(find "$caskroom_base/$pkg_brew_cask" -maxdepth 3 -type d -name "FSInstaller.app" | sort -r | head -n 1)

                  if [[ -n "$manual_installer_app" ]]; then
                    # 为避免 Gatekeeper 静默阻止，先移除隔离标记
                    if [[ $(id -u) -eq 0 ]]; then
                      targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
                      sudo -u "$targetUser" xattr -dr com.apple.quarantine "$manual_installer_app"
                      # 以图形界面方式启动安装器并等待安装器退出
                      sudo -u "$targetUser" open -n -W "$manual_installer_app"
                    else
                      xattr -dr com.apple.quarantine "$manual_installer_app"
                      open -n -W "$manual_installer_app"
                    fi
                  else
                    echo -e "❌ 未找到 $pkg_brew_cask 的安装器，请手动在 Finder 中运行 FSInstaller.app"
                  fi

                  # 安装器执行完后，系统会提示“来自 Paragon Software 的系统软件已被阻止”时
                  # 需要用户前往系统设置 → 隐私与安全性 → 允许，并根据提示重启。
                fi

            fi  

            # ---------- 重新启动 APP（如果在本次升级中被关闭） ----------   

            # 如果之前关闭了应用，更新完成后重新打开 
            if [[ "$brew_cask_was_running" = true && -n "$brew_cask_app_name" ]]; then  
              echo -e "✓  重新启动此前关闭的应用：$brew_cask_app_name ... "                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
              open -a "$brew_cask_app_name.app" 2>&1                                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            fi

            # ---------- 本APP 的 升级结果 ----------  
            if [ $brew_cask_final_exit -eq 0 ]; then
                echo -e "✅  更新成功 [cask]   : $pkg_brew_cask "                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            else
                echo -e "❌  更新失败 [cask]   : $pkg_brew_cask "                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            fi

            #brew_cask_method=$([ $brew_cask_upgrade_exit -ne 0 ] && echo "reinstall" || echo "upgrade")
            if [ $brew_cask_upgrade_exit -ne 0 ]; then
                if [ $brew_cask_reinstall_exit -eq 0 ]; then
                    brew_cask_method="reinstall"
                    brew_cask_reinstall_exit=0
                elif [ $brew_cask_reinstall_force_exit -eq 0 ]; then
                    brew_cask_method="reinstall_force"
                    brew_cask_reinstall_exit=0
                fi
            else
                brew_cask_method="upgrade"
            fi                

            #updated_list+=("success|cask|$pkg_brew_cask|$brew_cask_method")
            if [ $brew_cask_final_exit -eq 0 ] ; then
                updated_list+=("success|cask|$pkg_brew_cask|$brew_cask_method")
            else
                updated_list+=("failure|cask|$pkg_brew_cask|$brew_cask_method")
            fi

            echo -e "--------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

            rm -f "$brew_cask_tmpfile"  # 清理临时文件

        done

        echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    else  

        echo -e ""                                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        printf  "\033[1;34m[Install]\033[0m "   
        printf  "[Install] "                                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  > /dev/null
        echo -e "无需更新：HomeBrew cask ... "                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    fi    




 #  brew upgrade --greedy --debug --force                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE""  ###### 仅作为Debug使用！！！

else    

    echo -e "✓  未检测到新版本 ：HomeBrew formula ... "                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    echo -e "✓  未检测到新版本 ：HomeBrew cask ... "                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    echo -e ""                                                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    printf  "\033[1;34m[Download & Install]\033[0m "    
    printf  "[Download & Install] "                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "HomeBrew 下载安装 ... "                                         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    echo -e "✓  所有APP已经是 最新版本 ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    echo -e ""                                                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

fi


# 第 5 步： 清洁
printf  "\033[1;34m[Clean]\033[0m "
printf  "[Clean] "                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "Homebrew 清理残留 ... "                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"


# 检查是否以 root 身份运行
if [ "$(id -u)" -eq 0 ]; then
    # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
    targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 brew cleanup ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 以目标用户身份执行 Homebrew 命令
    sudo -H -u "$targetUser" bash -c 'brew cleanup --prune=all 2>&1'       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 使用 -s 参数彻底清理下载缓存，包括最新版本的下载文件
    sudo -H -u "$targetUser" bash -c 'brew cleanup -s 2>&1'                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 自动移除不再依赖的“孤儿”包
    sudo -H -u "$targetUser" bash -c 'brew autoremove 2>&1'                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 列出缺失依赖，仅提示，不影响退出码
    sudo -H -u "$targetUser" bash -c 'brew missing || true'                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
else
    echo -e "✓  当前用户'$USER'，为普通权限，直接运行 brew cleanup ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    brew cleanup --prune=all 2>&1                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 使用 -s 参数彻底清理下载缓存，包括最新版本的下载文件
    brew cleanup -s 2>&1                                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    brew autoremove 2>&1                                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 列出缺失依赖，仅提示，不影响退出码
    brew missing || true                                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
fi


echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"


# 第 6 步： 显示结果
printf "\033[1;34m[Final]\033[0m "
printf "[Final] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "Homebrew 更新结果 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

if [ ${#packages_brew[@]} -eq 0 ]; then
    # 没有任何软件需要更新的情况
    echo -e "✓  没有APP被更新 !!! " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
else
    # 逐条输出更新结果
    for entry in "${updated_list[@]}"; do
        IFS='|' read -r status type name brew_method <<< "$entry"
        # 每次循环重置，避免上一条的 reinstall 提示“串味”
        brew_warning_cmd=""
        # 根据状态选择符号和文字
        if [ "$status" = "success" ]; then
            symbol="✅"
            status_text="成功"
        else
            symbol="❌"
            status_text="失败"
        fi
        # 根据类型调整对齐格式
        if [ "$type" = "cask" ]; then
            type_display="[cask]"
            spacing="   "      # cask 比 formula 短3个字母，补3个空格对齐
        else
            type_display="[formula]"
            spacing=""
        fi
        # 构造基础输出行（符号、结果、类型、名称）
        line="$symbol  更新$status_text $type_display$spacing : $name"
        # 如果是失败且 brew_method 为 fetch_failed:<URL>，则追加下载失败原因
        # 处理 SHA-256 校验失败的情况
        if [ "$status" = "failure" ] && [[ "$brew_method" == sha256_mismatch:* ]]; then
            # brew_method 格式: sha256_mismatch:actual:expected
            tmp="${brew_method#sha256_mismatch:}"
            sha_actual="${tmp%%:*}"
            sha_expected="${tmp#*:}"
            line="$symbol  更新$status_text $type_display$spacing : $name (SHA-256校验失败：实际: $sha_actual, 期望: $sha_expected)"
        # 如果是失败且 brew_method 为 fetch_failed:<URL>，则追加下载失败原因
        elif [ "$status" = "failure" ] && [[ "$brew_method" == fetch_failed:* ]]; then
            fail_url="${brew_method#fetch_failed:}"
            line="$symbol  更新$status_text $type_display$spacing : $name (下载失败：$fail_url)"
        fi
        # 若通过重装更新，则附加警告标记和具体命令
        if [ "$status" = "success" ]; then
            if [ "$brew_method" = "reinstall_force" ]; then
                # 强制重装成功的情况
                brew_warning_cmd="brew reinstall --cask --force $name"
                [ "$type" != "cask" ] && brew_warning_cmd="brew reinstall --force $name"
            elif [ "$brew_method" = "reinstall" ]; then
                # 普通重装成功的情况
                brew_warning_cmd="brew reinstall --cask $name"
                [ "$type" != "cask" ] && brew_warning_cmd="brew reinstall $name"
            fi
            [ -n "$brew_warning_cmd" ] && line="$line   ( ⚠️ 更新方式 ：$brew_warning_cmd )"
        fi
        # 输出该行到屏幕和日志
        echo -e "$line" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    done
fi


echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"


# 检查是否以 root 身份运行
#if [ "$(id -u)" -eq 0 ]; then
#else
#fi

echo -e "\033[1;32m[OK] Homebrew upgrade  运行已完成  ✅ \033[1;32m"   
echo -e "[OK]  Homebrew upgrade  运行已完成  ✅ "                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

#exit 1                                                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"          # 用于调试 ！！









# ----------------------------------
# 开始执行：Mas
# ----------------------------------

export Mas_NO_INTERACTIVE=1

# 配置 MAS 最大重试次数和重试间隔（可根据需要调整或通过环境变量设置）
MAS_MAX_RETRIES=3                                                                       # 最多重试3次（超时重试次数，可配置）
MAS_RETRY_DELAY=5                                                                       # 每次重试之间等待5秒

echo -e "\033[1;32m-----------------------------------------------\033[0m" 
echo -e "\033[1;32m 运行 Mas ...                                  \033[0m"
echo -e "\033[1;32m-----------------------------------------------\033[0m" 

echo -e "----------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "运行 Mas"                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "----------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
  

# 等待3秒，开始执行
#sleep 3  

# 调用检查时间范围函数（假设此函数已定义）
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"


# 尝试扫描 Mac App Store 更新，显示未更新APP列表，带重试机制

mas_attempt=1
mas_success=false

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

printf  "\033[1;34m[List] \033[0m"
printf  "[List] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "MAS 应用列表 ... "                                                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

# 自动获取当前登录用户
currentUser=$(stat -f%Su /dev/console)

# 如无用户登录则退出
if [ -z "$currentUser" -o "$currentUser" = "loginwindow" ]; then
    echo -e "没有用户登录，无法获取 Mac App Store 应用列表。"       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    exit 1
fi

# 如果是 root 运行，则切换到登录用户运行 mas list
if [ "$(id -u)" -eq 0 ]; then
    targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 mas list... "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    uid=$(id -u "$currentUser")
    mas_installed_apps=$(launchctl asuser "$uid" sudo -u "$currentUser" /opt/homebrew/bin/mas list)
    #mas_app_count=$(launchctl asuser "$uid" sudo -u "$currentUser" /opt/homebrew/bin/mas list | wc -l)
else
    echo -e "✓  当前用户'$USER'，为普通权限，直接运行 mas list ... "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 非 root 直接运行 mas list
    mas_installed_apps=$(/opt/homebrew/bin/mas list)
    #mas_app_count=$(/opt/homebrew/bin/mas list | wc -l)
fi

if [ -z "$mas_installed_apps" ]; then
    mas_app_count=0
else
    mas_app_count=$(echo "$mas_installed_apps" | wc -l)
fi

# 统计 App 数量并输出结果
mas_app_count=$((mas_app_count+0))
echo -e "✅  APP 数量（ Mac AppStore ）：$mas_app_count  "                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"


echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

printf  "\033[1;34m[Scan] \033[0m"
printf  "[Scan] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "MAS 扫描更新 ... "                                                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

while [ $mas_attempt -le $MAS_MAX_RETRIES ]; do
   #mas_output=$(mas outdated 2>&1)                                                     # 执行 mas 查询更新（捕获输出和错误）
    if [[ $(id -u) -eq 0 ]]; then
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 mas outdated ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        mas_output=$(sudo -H -u "$targetUser" /bin/bash -lc 'mas outdated' 2>/dev/null )
    else
        echo -e "✓  当前用户'$USER'，为普通权限，直接运行 mas outdated ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  
        mas_output=$( /bin/bash -lc 'mas outdated' 2>/dev/null )
    fi
    mas_status=$?   

    # 把扫描结果写日志并存变量
    #echo -e "$mas_output"                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    outdated_mas_apps="$mas_output"

    if [ $mas_status -eq 0 ]; then
        # 扫描成功，输出结果并标记成功
        echo -e "$mas_output"                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        # 使用 sed 去掉应用ID和版本号，只保留应用名
        mas_app_names=$(echo "$mas_output" | sed -E 's/^[0-9]+[[:space:]]+//; s/ *\([^)]*\)//g; s/ *->.*//g')
        #echo -e "✅  检测到新版本 : $mas_app_names" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        while IFS= read -r app_line; do
            [[ -n "$app_line" ]] && echo -e "✅  检测到新版本 : $app_line" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        done <<< "$mas_app_names"
        mas_success=true
        break
    else
        # 扫描失败，检查是否超时错误
        if echo -e "$mas_output" | grep -q "The request timed out"; then
            echo -e "⚠️ 第${mas_attempt}次 MAS 扫描超时，重试中 ... "                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        else
            echo -e "❌ mas 扫描更新失败：$mas_output"                                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
            break   # 遇到非超时错误，跳出循环不再重试
        fi
        mas_attempt=$((mas_attempt+1))
        sleep $MAS_RETRY_DELAY 2>&1                                                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"          # 等待一段时间再重试
    fi
done

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

printf  "\033[1;34m[Download & Install]\033[0m "
printf  "[Download & Install] "                                                         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "MAS 下载安装 ... "                                                           | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 根据扫描结果决定是否进行安装更新
if [ "$mas_success" = true ]; then
    # 开始执行：Mas 更新（并捕获输出）
    # 获取过时应用程序的ID
    mas_app_ids=$(echo -e "$outdated_mas_apps" | awk '{print $1}'  | grep -E '^[0-9]+$')
    
    echo -e "✓  开始扫描，待更新的APP，是否正在运行 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    #echo -e "mas_app_ids = $mas_app_ids "      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  # 测试！

    # 存储需要关闭和重启的应用程序
    mas_apps_to_restart=()

    # 检查并关闭正在运行的应用程序
    for mas_id in $mas_app_ids; do
        # 从已安装应用列表中提取应用名称，去掉ID和可能的版本号
        mas_app_name=$(echo -e "$mas_installed_apps" | grep "^$mas_id" | awk '{$1=""; print substr($0,2)}' | sed 's/ ([0-9].*)$//')
        #echo -e "mas_app_name = $mas_app_name "     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" # 测试！
        
        # 检测进程正在运行，如果运行则尝试关闭
        if [ -n "$mas_app_name" ]; then
            # 使用 osascript 检查应用是否正在运行
            if osascript -e "tell application \"System Events\" to (name of processes) contains \"$mas_app_name\"" | grep -q "true"; then
                echo -e "✓  检测到 $mas_app_name 正在运行，正在尝试关闭 ... "                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
                # 安全关闭应用程序
                osascript -e "tell application \"$mas_app_name\" to quit"
                # 等待应用完全关闭（最多10秒）
                for i in {1..10}; do
                    if ! osascript -e "tell application \"System Events\" to (name of processes) contains \"$mas_app_name\"" | grep -q "true"; then
                        break
                    fi
                    sleep 1
                done
                # 如果应用仍未关闭，尝试强制关闭
                if osascript -e "tell application \"System Events\" to (name of processes) contains \"$mas_app_name\"" | grep -q "true"; then
                    echo -e "✘  无法正常关闭 $mas_app_name ，正在尝试强制关闭 ... "                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
                    # 获取应用程序的PID
                    mas_pid=$(pgrep -f "$mas_app_name")
                    if [ -n "$mas_pid" ]; then
                        kill -9 $mas_pid
                        echo -e "✓  已强制关闭 $mas_app_name (PID: $mas_pid)"                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
                    else
                        echo -e "✘  无法获取 $mas_app_name 的PID，跳过强制关闭"                         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
                    fi
                fi
                # 再次检查应用是否已关闭成功
                if osascript -e "tell application \"System Events\" to (name of processes) contains \"$mas_app_name\"" | grep -q "true"; then
                    echo -e "✘  无法关闭 $mas_app_name ，稍后 将跳过重启该应用。"                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                else
                    # 已成功关闭的应用加入重启列表
                    mas_apps_to_restart+=("$mas_app_name")
                    echo -e "✓  已关闭 $mas_app_name ，稍后 将重新启动该应用。"                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                fi
            fi
        fi
    done
    
    echo -e "✓  所有 待更新的 MAS APP ，均已停止运行 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    if [[ $(id -u) -eq 0 ]]; then
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 mas upgrade ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        mas_output=$(sudo -H -u "$targetUser" /bin/bash -lc 'mas upgrade' 2>/dev/null )
    else
        echo -e "✓  当前用户'$USER'，为普通权限，直接运行 mas upgrade ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  
        mas_output=$( /bin/bash -lc 'mas upgrade' 2>/dev/null )
    fi
    
    echo -e "$mas_output"                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # （3）根据升级结果打印“更新成功”或“已最新”提示
    if echo "$mas_output" | grep -q "Installed"; then
        # 解析 mas upgrade 输出，提取已更新的应用名称列表
        updated_mas_app_names=$(echo "$mas_output"  | grep -E "Installed"  | sed -E 's/^==> Installed //; s/ *\([^)]*\)//g')
        # 遍历每个已更新应用名称，输出日志
        while IFS= read -r app_line; do
            [[ -n "$app_line" ]] && echo -e "✅  更新成功    : $app_line"  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        done <<< "$updated_mas_app_names"
    else
        echo -e "✓  应用已是最新版本，无需更新。" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    fi

    # 重新启动之前关闭的应用程序
    for mas_app in "${mas_apps_to_restart[@]}"; do
        echo -e "✓ 正在重新启动 $mas_app ... "                                                  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        open -a "$mas_app"  2>&1                                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        sleep 1  # 短暂延迟以确保应用启动
    done

    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    # 检查是否以 root 身份运行
    #if [ "$(id -u)" -eq 0 ]; then
    #else
    #fi

    echo -e "\033[1;32m[OK] Mac AppStore upgrade  运行已完成已完成 ，APP 已重启 ✅ \033[1;32m"   
    echo -e "[OK]  Mac AppStore upgrade  运行已完成已完成 ，APP 已重启 ✅ "                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

else

    echo -e "❌ mas 多次尝试仍超时，已跳过 Mac App Store （MAS）应用更新"

fi


echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"     





# ----------------------------------
# 开始执行：MacPorts
# ----------------------------------

export MacPorts_NO_INTERACTIVE=1


echo -e "\033[1;32m-----------------------------------------------\033[0m"
echo -e "\033[1;32m 运行 MacPorts ...                             \033[0m"
echo -e "\033[1;32m-----------------------------------------------\033[0m"

echo -e "----------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "运行 MacPorts"                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "----------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 拒绝执行时间窗口
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

# （1）仅在确实发生“重大变化”时执行一次 migrate
# 若 CLT 未就绪，跳过

if ! ensure_clt_or_skip_macports; then
    echo -e "⏭️  MacPorts 步骤被跳过（缺少 CLT）" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
else
    printf "\033[1;34m[Migrate]\033[0m "
    printf "[Migrate] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null 
    echo "MacPorts 扫描迁移 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    if macports_should_migrate; then
        MIGRATE_LOG="$(__get_migrate_log_file)"
        /bin/mkdir -p "${MIGRATE_LOG%/*}" 2>/dev/null || true
        if yes | sudo /opt/local/bin/port -q migrate 2>&1 \
            | /usr/bin/tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$MIGRATE_LOG" > /dev/null; then
            macports_mark_migrated
            echo -e "✓ 迁移完成" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        else
            echo -e "❌ 迁移失败（请检查日志）" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_ERROR_FILE"
        fi
    else
        echo -e "✓ 无需迁移（已处于当前 Darwin/架构/base）" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    fi

    echo "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    printf "\033[1;34m[Scan]\033[0m "
    printf "[Scan] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null 
    echo "MacPorts 扫描更新 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    outdated_list="$(sudo /opt/local/bin/port -q outdated -N 2>/dev/null || true)"
    if [ -z "$outdated_list" ]; then
        echo -e "✓ 未检测到过期端口" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 仍然运行一次 rev-upgrade 摘要
        macports_rev_upgrade_quiet
    else
        echo -e "【过期端口】" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        echo "$outdated_list" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        echo "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

        # （3）升级：终端只打印摘要…完整构建日志写文件
        macports_upgrade_outdated_quiet

        # （4）清理（不依赖当前目录）
        printf "\033[1;34m[Clean]\033[0m "
        printf "[Clean] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo "MacPorts 清理残留 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 官方 reclaim 命令会删除日志、旧档和 distfiles，并尝试卸载非活动版本
        sudo /opt/local/bin/port -q reclaim
        
        # 卸载仍然处于非活动状态的端口（如果 reclaim 未能完全删除）
        printf "\033[1;34m[Uninstall]\033[0m "
        printf "[Uninstall] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo "MacPorts 卸载非活动旧版本 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        sudo /opt/local/bin/port uninstall inactive
        
        # 删除无人依赖的叶子端口
        printf "\033[1;34m[Leaves]\033[0m "
        printf "[Leaves] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo "MacPorts 移除无人依赖的叶子端口 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        sudo /opt/local/bin/port echo leaves | xargs sudo /opt/local/bin/port uninstall

        echo "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

        # （5）链接自检（摘要）
        printf "\033[1;34m[Verify]\033[0m "
        printf "[Verify] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo "MacPorts 验证结果 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        macports_rev_upgrade_quiet

    fi

    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
    echo -e "\033[1;32m[OK] MacPorts upgrade  运行已完成  ✅\033[0m"
    echo -e "[OK]  MacPorts upgrade  运行已完成  ✅"                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
fi


echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 


# ----------------------------------
# MacOS System Update
# ----------------------------------

export SoftwareUpdate_NO_INTERACTIVE=1

echo -e "\033[1;32m-----------------------------------------------\033[0m"  
echo -e "\033[1;32m 运行 MacOS System Update ...                  \033[0m"  
echo -e "\033[1;32m-----------------------------------------------\033[0m"  

echo -e "----------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "运行 MacOS System Update"                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "----------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 等待3秒，开始执行 
#sleep 3     

# 调用检查时间范围函数  
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE" 

# 自动执行：SoftwareUpdate （并捕获输出）   
printf "\033[1;34m[Scan]\033[0m "  
printf "[Scan] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null  
echo -e "MacOS 扫描检测 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  

# Run the update scan and capture output (stderr included), logging it as well
MacOSSystemUpdate_output=$(sudo softwareupdate --list --force --agree-to-license 2>&1)  
echo -e "$MacOSSystemUpdate_output" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  
echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  

# Check scan output for "No new software available."
if echo "$MacOSSystemUpdate_output" | grep -F -q "No new software available."; then  
    # No updates available – skip download/install, output "no update needed"
    printf "\033[1;34m[Download & Install]\033[0m "  
    printf "[Download & Install] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null  
    echo -e "MacOS 下载安装 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    echo -e "✓  当前没有需要安装的 MacOS 系统更新 !!!" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
else  
    # Updates are available – proceed with download (and prompt for install)
    printf "\033[1;34m[Download]\033[0m "  
    printf "[Download] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null  
    echo -e "MacOS 下载更新包 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  
    sudo softwareupdate --download --force --agree-to-license 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  

    printf "\033[1;34m[Install]\033[0m "  
    printf "[Install] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null  
    echo -e "MacOS 安装更新 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  
    #sudo softwareupdate --install --all --force --agree-to-license --verbose  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  
    #macos_system_update_ec=${PIPESTATUS[0]}
    ## 分析更新结果并输出提示
    #if [[ $macos_system_update_ec -eq 0 ]] && ! grep -qiE "failed|error" "$LOG_FULL_LAST"; then
    #    echo "✅  更新成功 ：MacOS ${OLD_VER} -> ${TARGET_VER}  （ 请重启电脑‼️‼️ ）" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    #else
    #    echo "❌  更新失败 ：MacOS ${OLD_VER} -> ${TARGET_VER}" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    #fi

    echo -e "⚠️【检测到系统更新】！！请手动输入命令 ： softwareupdate --install --all --force --verbose " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  
    show_sysupdate_popup          # <<< 新增：弹 GUI 提示 
fi   

echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"    # blank line for separation  

targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"  

# 检查是否以 root 身份运行 (Check if running as root)
#if [ "$(id -u)" -eq 0 ]; then  
#else  
#fi  

echo -e "\033[1;32m[OK] MacOS System Update  运行已完成  ✅ \033[1;32m"  
echo -e "[OK]  MacOS System Update  运行已完成  ✅ " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null  

echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  
echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  



# ----------------------------------
# 开始执行：TopGrade
# ----------------------------------

export TopGrade_NO_INTERACTIVE=1


echo -e "\033[1;32m-----------------------------------------------\033[0m"  
echo -e "\033[1;32m 运行 TopGrade ...                             \033[0m"  
echo -e "\033[1;32m-----------------------------------------------\033[0m"  

echo -e "----------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "运行 TopGrade"                                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "----------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 等待3秒，开始执行
#sleep 3  

# 调用检查时间范围函数
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
if [[ $(id -u) -eq 0 ]]; then
    #—— root 环境：切换到桌面用户执行 ——#
    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 topgrade 进行升级 ... "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    topgrade_output=$(sudo -H -u "$targetUser"  /bin/bash -c 'topgrade --disable brew_formula --disable brew_cask --disable mas --disable system --disable macports --disable node --disable pnpm --disable powershell --disable tldr --disable tlmgr --cleanup' 2>&1)
    printf "%s\n" "$topgrade_output"        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

else
    #—— 非 root 环境：直接执行 ——#
    echo -e "✓  当前用户'$USER'，为普通权限，直接运行 topgrade 进行升级 ... "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    topgrade --disable brew_formula --disable brew_cask --disable mas --disable system --disable macports --disable node --disable pnpm --disable powershell --disable tldr --disable tlmgr --cleanup 2>&1   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

fi


echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 


# ----------------------------------
# 开始执行： 其他更新（ 对 Topgreade 更新 补充 ）
# ----------------------------------

#########  更新 TeX Live 管理器 (tlmgr)  ########
#if command -v tlmgr > /dev/null 2>&1; then
#
#    errorFlag=0
#    echo -e "\033[1;32m更新 TeX Live 管理器 ...     \033[0m"
#    echo -e "更新 TeX Live 管理器"         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
#
#    #—— 更新 TeX Live 模块 ——#
#    #if [[ $(id -u) -eq 0 ]]; then
#    #    #—— root 环境：降权到桌面用户 ——#
#    #    echo -e "✓  Root 权限，降权至普通用户 ( $targetUser ) ，运行 tlmgr init-usertree ..."   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
#    #    sudo -H -u "$targetUser" tlmgr init-usertree 2>&1   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
#    #    [ ${PIPESTATUS[0]} -ne 0 ] && errorFlag=1
#    #    echo -e "✓  Root 权限，降权至普通用户 ( $targetUser ) ，运行 tlmgr update --self --all ..."  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
#    #    sudo -H -u "$targetUser" tlmgr update --self --all 2>&1   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
#    #    [ ${PIPESTATUS[0]} -ne 0 ] && errorFlag=1
#    #    echo -e "✓  Root 权限，降权至普通用户 ( $targetUser ) ，运行 tlmgr backup --clean --all ..."   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
#    #    sudo -H -u "$targetUser" tlmgr backup --clean --all 2>&1   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
#    #    [ ${PIPESTATUS[0]} -ne 0 ] && errorFlag=1
#    #else
#    #    #—— 非 root 环境 ——#
#    #    echo -e "✓  当前用户 '$USER' ，运行 tlmgr init-usertree ..."   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
#    #    tlmgr init-usertree 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
#    #    [ ${PIPESTATUS[0]} -ne 0 ] && errorFlag=1
#    #    echo -e "✓  当前用户 '$USER' ，运行 tlmgr update --self --all ..."  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
#    #    tlmgr update --self --all 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
#    #    [ ${PIPESTATUS[0]} -ne 0 ] && errorFlag=1
#    #    echo -e "✓  当前用户 '$USER' ，运行 tlmgr backup --clean --all ..."    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
#    #    tlmgr backup --clean --all 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
#    #    [ ${PIPESTATUS[0]} -ne 0 ] && errorFlag=1
#    #fi
#
#    echo -e "✓  当前用户 '$USER' ，运行 sudo tlmgr init-usertree ..."   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
#    sudo tlmgr init-usertree 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
#    [ ${PIPESTATUS[0]} -ne 0 ] && errorFlag=1
#    echo -e "✓  当前用户 '$USER' ，运行 sudo tlmgr update --self --all ..."  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
#    sudo tlmgr update --self --repository https://mirror.ctan.org/systems/texlive/tlnet 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
#    sudo tlmgr update --self --repository https://mirror.ctan.org/systems/texlive/tlnet --all 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
#    [ ${PIPESTATUS[0]} -ne 0 ] && errorFlag=1
#    echo -e "✓  当前用户 '$USER' ，运行 sudo tlmgr backup --clean --all ..."    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
#    sudo tlmgr backup --clean --all 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
#    [ ${PIPESTATUS[0]} -ne 0 ] && errorFlag=1
#
#    # 输出最终结果
#    if [ $errorFlag -eq 0 ]; then
#        echo -e "✅  TeX Live 更新  运行已完成 !!! " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
#    else
#        echo -e "⚠️  TeX Live 更新  完成，但出现错误 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
#    fi
#else
#    printf "\033[1;34m[INFO]\033[0m "
#    printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
#    echo -e "tlmgr 未安装，跳过 TeX Live 更新 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
#fi
#
#echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 


########  更新 PowerShell  ########
#if command -v pwsh > /dev/null 2>&1; then
#    errorFlag=0
#
#    echo -e "\033[1;32m更新 PowerShell ...    \033[0m"
#    echo -e "更新 PowerShell"            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
#
#    #—— 更新 PowerShell 模块 ——#
#    #if [[ $(id -u) -eq 0 ]]; then
#    #    #—— root 环境：降权到桌面用户 ——#
#    #    sudo pwsh -NoProfile -NonInteractive -Command 'Get-InstalledModule | ForEach-Object { try { Update-Module -Name $_.Name -Force -ErrorAction Stop } catch { Write-Output $_.Exception.Message; $global:LastExitCode = 1 } }' 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
#    #    [ ${PIPESTATUS[0]} -ne 0 ] && errorFlag=1
#    #else
#    #    #—— 非 root 环境 ——#
#    #    echo -e "✓  当前用户 '$USER' ，使用 pwsh 更新所有模块 ..."   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
#    #    /usr/local/bin/pwsh -NoProfile -NonInteractive -Command  'Get-InstalledModule | ForEach-Object { try { Update-Module -Name $_.Name -Force -ErrorAction Stop } catch { Write-Output $_.Exception.Message; $global:LastExitCode = 1 } }' 2>&1   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
#    #    [ ${PIPESTATUS[0]} -ne 0 ] && errorFlag=1
#    #fi   
#    sudo pwsh -NoProfile -NonInteractive -Command 'Get-InstalledModule | ForEach-Object { try { Update-Module -Name $_.Name -Force -ErrorAction Stop } catch { Write-Output $_.Exception.Message; $global:LastExitCode = 1 } }' 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
#    [ ${PIPESTATUS[0]} -ne 0 ] && errorFlag=1
#
#    # 输出最终结果
#    if [ $errorFlag -eq 0 ]; then
#        echo -e "✅  PowerShell 更新  运行已完成 " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
#    else
#        echo -e "⚠️  PowerShell 更新  运行已完成，但出现错误 " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
#    fi
#else
#    printf "\033[1;34m[INFO]\033[0m "
#    printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
#    echo -e "Homebrew 未安装，跳过 PowerShell 更新 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
#fi
#
#echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

echo -e "\033[1;32m[OK] TopGrade upgrade  运行已完成  ✅ \033[1;32m"   
echo -e "[OK]  TopGrade upgrade  运行已完成  ✅ "                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 



# ----------------------------------
# 开始执行： MacUpdater
# ----------------------------------

MacUpdater_ENABLE="true"
export MacUpdater_NO_INTERACTIVE=1

echo -e "\033[1;32m-----------------------------------------------\033[0m" 
echo -e "\033[1;32m 运行 MacUpdater ...                           \033[0m"
echo -e "\033[1;32m-----------------------------------------------\033[0m" 

echo -e "----------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "运行 MacUpdater"                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "----------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 等待3秒，开始执行
#sleep 3  

# 调用检查时间范围函数
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

# echo -e "应用列表 ... " | tee -a "$LOG_FULL_FILE"
# TOTAL_APPS=$("/Applications/MacUpdater.app/Contents/Resources/macupdater_client" list | wc -l)
# echo -e "APP 数量（全部总计）: $TOTAL_APPS" | tee -a "$LOG_FULL_FILE"
# run_command_with_show_progress "\"$MACUPDATER_CLIENT\" scan" "SCAN"  "$LOG_MACUPDATER_FILE"

# -------- 获取已安装应用的总数 （扫描 -------- 
printf  "\033[1;34m[List]\033[0m "
printf  "[List] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "MacUpdater 应用列表 ... "                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 


# 检查是否以 root 身份运行
if [ "$(id -u)" -eq 0 ]; then

    targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"

    # 获取目标普通用户（优先使用 SUDO_USER，其次获取当前登录控制台用户）
    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 MacUpdater scan ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    #sudo -H -u "$targetUser" bash -c  'macupdater_app_count=$("/Applications/MacUpdater.app/Contents/Resources/macupdater_client" list | wc -l) '
    macupdater_app_count=$(sudo -H -u "$targetUser" /Applications/MacUpdater.app/Contents/Resources/macupdater_client list | wc -l)

else

    echo -e "✓  当前用户'$USER'，为普通权限，直接运行 MacUpdater list ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    macupdater_app_count=$("/Applications/MacUpdater.app/Contents/Resources/macupdater_client" list | wc -l)

fi

# 去除前导空格
macupdater_app_count="${macupdater_app_count#"${macupdater_app_count%%[![:space:]]*}"}"
# 去除后置空格
macupdater_app_count="${macupdater_app_count%"${macupdater_app_count##*[![:space:]]}"}"
# 可选：强制算术求值以确保它是整数（加 0，如果非数字则出错）
macupdater_app_count=$((macupdater_app_count + 0))
# 进度条所需
TOTAL_APPS=$((macupdater_app_count + 0))
# 显示MacUpdater监控的所有APP数量
echo -e "✓  APP 数量（ MacUpdater ）: $macupdater_app_count （ $TOTAL_APPS ）"                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

#exit 1          # 测试！

# -------- 获取已安装应用的总数 （扫描 -------- 
printf  "\033[1;34m[Scan]\033[0m "
printf  "[Scan] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "MacUpdater 扫描更新 ... "                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 


# 检查是否以 root 身份运行
if [ "$(id -u)" -eq 0 ]; then

    targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"

    # 获取目标普通用户（优先使用 SUDO_USER，其次获取当前登录控制台用户）
    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 MacUpdater scan ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    MACUPDATER_COMMAND="sudo -H -u $targetUser /Applications/MacUpdater.app/Contents/Resources/macupdater_client scan"
        
    #  开始执行 MacUpdater 扫描 
    #### sudo -H -u "$targetUser" bash -c '"/Applications/MacUpdater.app/Contents/Resources/macupdater_client" scan'
    #sudo -H -u "$targetUser" bash -c  'macupdater_app_scanlist=$("/Applications/MacUpdater.app/Contents/Resources/macupdater_client" scan | wc -l) '
    #echo -e "✓  macupdater_app_scanlist : $macupdater_app_scanlist"                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
else

    echo -e "✓  当前用户'$USER'，为普通权限，直接运行 MacUpdater scan ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    MACUPDATER_COMMAND="/Applications/MacUpdater.app/Contents/Resources/macupdater_client scan"
    
fi

#  开始执行 MacUpdater 扫描 
run_command_with_show_progress "$MACUPDATER_COMMAND" "SCAN"  "$LOG_MACUPDATER_FILE"

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 


#  -------- 更新安装过期应用 （安装） -------- 

printf  "\033[1;34m[Install]\033[0m "
printf  "[Install] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "MacUpdater 开始更新 ... "                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 


# 检查是否以 root 身份运行
if [ "$(id -u)" -eq 0 ]; then

    # 自动获取当前登录用户
    currentUser=$(stat -f%Su /dev/console)
    targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"

    # 获取目标普通用户（优先使用 SUDO_USER，其次获取当前登录控制台用户）
    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 MacUpdater update ...（当前用户是 root）" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    macupdater_output=$(sudo -H -u "$targetUser" bash -c ' "/Applications/MacUpdater.app/Contents/Resources/macupdater_client" update --force-quit-running-apps --force-major-version-update' 2>&1)
    echo -e "$macupdater_output"                                                           | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

else

    echo -e "✓  当前用户'$USER'，为普通权限，直接运行 MacUpdater update ... "          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
   #"/Applications/MacUpdater.app/Contents/Resources/macupdater_client" update --force-quit-running-apps --force-major-version-update 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    macupdater_output=$(bash -c ' "/Applications/MacUpdater.app/Contents/Resources/macupdater_client" update --force-quit-running-apps --force-major-version-update' 2>&1)
    echo -e "$macupdater_output"                                                           | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

fi

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

# 检查是否以 root 身份运行
#if [ "$(id -u)" -eq 0 ]; then
#else
#fi

echo -e "\033[1;32m[OK] MacUpdater 运行已完成  ✅ \033[1;32m"   
echo -e "[OK]  MacUpdater 运行已完成  ✅ "                                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 





# ----------------------------------
# 恢复 桌面布局（Launchpad）
# ----------------------------------

# 在所有更新操作完成后，调用桌面布局（Launchpad）恢复脚本，恢复之前保存的布局

#trap - EXIT  # 取消先前设置的 trap，避免重复恢复

echo -e "\033[1;32m-----------------------------------------------\033[0m" 
echo -e "\033[1;32m 恢复 桌面布局（Launchpad）                    \033[0m"
echo -e "\033[1;32m-----------------------------------------------\033[0m" 

echo -e "----------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "恢复 桌面布局（Launchpad）"                                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "----------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
output=$(restore_desktop_layout 2>&1)   
status=$?   
echo -e "$output"                                  
    
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
if [ $status -ne 0 ]; then  

    printf  "\033[1;34m[Info]\033[0m "
    printf  "[Info] "                                                                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "桌面布局 恢复路径: '$PATH_DesktopLayout_db_SOURCE'"                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    printf  "\033[1;34m[Info]\033[0m "
    printf  "[Info] "                                                                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "桌面布局 备份路径：'$PATH_DesktopLayout_BACKUP'"                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    printf  "\033[1;34m[ERROR] 桌面布局 恢复失败，请手动恢复 ❌❌❌❌❌\033[0m "   
    printf  "[ERROR]  桌面布局 恢复失败，请手动恢复 ❌❌❌❌❌"                         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

else    

    echo -e "\033[1;32m[OK] 恢复 桌面布局  运行已完成 ✅ \033[1;32m"   
    echo -e "[OK]   恢复 桌面布局  运行已完成 ✅ "                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

fi  
    
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"





# ----------------------------------
# 记录：完成时间 
# ----------------------------------

# 最后打印执行完成的时间

echo -e "\033[1;32m-----------------------------------------------\033[0m" 
echo -e "\033[1;32m 已完成 所有更新  ...                          \033[0m"
echo -e "\033[1;32m-----------------------------------------------\033[0m" 

echo -e "----------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "已完成 所有更新"                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "----------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
gui_app_count=$(($brew_cask_count+$mas_app_count))
echo -e "✅  APP 数量（ Homebrew formula   ） ：$brew_formula_count  "                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e "✅  APP 数量（ Homebrew Cask      ） ：$brew_cask_count  "                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e "✅  APP 数量（ Mac AppStore       ） ：$mas_app_count   "                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

if [ "$MacUpdater_ENABLE" != "true" ]; then  
    echo -e "✅  APP 数量（ MAS + HomebrewCask ） ：$gui_app_count "                  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
else
    echo -e "✅  APP 数量（ MacUpdater         ） ：$macupdater_app_count  （ $gui_app_count = MAS + HomebrewCask ）"                  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
fi

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
printf  "\033[1;34m[Info]\033[0m "
printf  "[Info] "                                                                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "日志路径 ... "                                                                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e "'$LOG_PATH'"                                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
echo -e "\033[1;32mFinished at: $(date) \033[0m"    
echo -e "Finished at: $(date)"                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_FILE" > /dev/null
    
# 打开Log日志文件夹 
open "$LOG_PATH"    
    
    
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 




