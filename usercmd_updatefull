#!/usr/bin/env bash
# Apple Silicon: 自动切换到 HomeBrew 或 /usr/local 安装的 bash（若存在），保证脚本在较新版本的 bash 中运行。
if [[ -x /opt/homebrew/bin/bash && "$BASH" != "/opt/homebrew/bin/bash" ]]; then
  exec /opt/homebrew/bin/bash "$0" "$@"
elif [[ -x /usr/local/bin/bash && "$BASH" != "/usr/local/bin/bash" ]]; then
  exec /usr/local/bin/bash "$0" "$@"
fi

# 自动执行的批处理：HomeBrew \ MAS \ MacPorts \ TopGrade \ MacUpdater

#设置执行所需的 环境变量！
export PATH="/usr/local/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/opt/local/bin:/opt/local/sbin:$PATH"

# 禁用 Homebrew 的彩色输出，以便于解析日志内容。设置该变量可以防止 brew 在非交互环境下插入 ANSI 颜色序列。
export HOMEBREW_NO_COLOR=1

# 脚本版本号：用于调试和确认是否使用最新脚本
SCRIPT_VERSION="2025.11.30.v1"

# 预先解析 GNU Parallel 的绝对路径。在某些 sudo 环境下 PATH 可能被重置，导致找不到 parallel。
if command -v parallel >/dev/null 2>&1; then
    PARALLEL_BIN="$(command -v parallel)"
else
    # 如果未安装 parallel，保持变量为空。后续逻辑会自动安装或提示。
    PARALLEL_BIN="parallel"
fi
export PARALLEL_BIN

# 动态计算并行下载任务数量：根据 CPU 核心数设定 xargs/parallel 的 -P 参数
CPU_CORES=$(sysctl -n hw.ncpu 2>/dev/null || getconf _NPROCESSORS_ONLN 2>/dev/null || echo 4)
# 如果无法检测或结果非法，则默认设置为 4
if ! echo "$CPU_CORES" | grep -qE '^[0-9]+$' || [ "$CPU_CORES" -lt 1 ]; then
    CPU_CORES=4
fi
# 根据 CPU 核心数决定并行度，最大不超过 32
if [ "$CPU_CORES" -gt 32 ]; then
    PARALLEL_JOBS=32
else
    PARALLEL_JOBS=$CPU_CORES
fi
export PARALLEL_JOBS

# 为了避免某些多语言 Cask 默认下载系统语言版本导致网络不可达，
# 默认根据系统的首选语言自动设置 HomeBrew Cask 的语言选项。
# 当系统语言对应的下载镜像不可用时，可通过修改下方算法或在脚本
# 外部预定义 HOMEBREW_CASK_OPTS 环境变量以覆盖自动检测结果。
#
# 读取 macOS 的首选语言。优先从 AppleLanguages 读取第一个元素，
# 如果不可用，则退回到 AppleLocale。检测结果会简化为 brew 支持的
# IETF 语言标记格式。若无法检测则默认使用 en-US。
if [ -z "$HOMEBREW_CASK_OPTS" ]; then
    __brew_lang=""
    if command -v defaults >/dev/null 2>&1; then
        # 尝试读取 AppleLanguages 的首选项
        __first_lang="$(defaults read -g AppleLanguages 2>/dev/null | awk -F '"' 'NR==2 {print $2}')"
        if [ -n "$__first_lang" ]; then
            __brew_lang="$__first_lang"
        else
            # 如果 AppleLanguages 不可用，则读取 AppleLocale
            __locale="$(defaults read -g AppleLocale 2>/dev/null || defaults read NSGlobalDomain AppleLocale 2>/dev/null)"
            # 去除 @ 符号及其后内容
            __locale="${__locale%%@*}"
            # 将 zh_CN 等下划线形式转换为 zh-CN
            __brew_lang="$(echo "$__locale" | tr '_' '-')"
        fi
    fi
    # 针对常见语言代码进行映射修正
    case "$__brew_lang" in
        zh-Hans*|zh_CN*|zh-CN*)
            __brew_lang="zh-CN"
            ;;
        zh-Hant*|zh_TW*|zh-TW*)
            __brew_lang="zh-TW"
            ;;
        en*|en_US*|en-US*)
            __brew_lang="en-US"
            ;;
        "")
            __brew_lang="en-US"
            ;;
    esac
    export HOMEBREW_CASK_OPTS="--language=$__brew_lang"
    # 同时设置 BREW_CASK_LANGUAGE 变量，便于传参到 brew fetch 等命令
    export BREW_CASK_LANGUAGE="$__brew_lang"
    unset __first_lang __locale __brew_lang
fi


# ================================================================================================
# 参数设置：用户可修改 （Start）
# ================================================================================================

# 设置 ：本脚本拒绝执行的时间范围
STOP_TIME="03:00"       # 拒绝执行 的 结束时间（这个时间后任务正常运行）
DURATION_MINUTES=1     # 拒绝执行结束前 的 时间长度（10分钟，意味着从 2:50 - 3:00 , 本脚本拒绝执行） 注意，单位：分钟（注意，单位不是秒！！！）

# ===== MAS 更新并行度设置 =====
# 为 mas upgrade 命令定义并行进程数。默认使用 8 个进程并行执行单个应用的升级
# 如果希望调整并行度（例如根据 CPU 数量），请修改此变量。
MAS_PARALLEL_JOBS=2

# ===== MAS 扫描方式设置 =====
# 控制 mas outdated 的执行方式。
# - 当 MAS_OUTDATED_MODE 设置为 "parallel"（默认）时，脚本会针对每个已安装的应用 ID 单独调用 `mas outdated`，并通过并行运行提高速度。
#   并行度由 MAS_OUTDATED_PARALLEL_JOBS 设置。
# - 当 MAS_OUTDATED_MODE 设置为 "simple" 时，脚本将直接运行一次 `mas outdated`（不传入任何参数）来获取所有待更新应用。
#   对于用户希望保留官方实现行为或避免并行导致的潜在问题，可将此值设为 "simple"。
# 允许从环境变量 MAS_OUTDATED_MODE 覆盖扫描模式，默认为 simple。
# 用户可在执行脚本时设置 MAS_OUTDATED_MODE=parallel 启用并行扫描。
MAS_OUTDATED_MODE="${MAS_OUTDATED_MODE:-simple}"
# 当 MAS_OUTDATED_MODE 为 "parallel" 时的并发扫描进程数。默认使用 16 个进程。
# 并行扫描过多的进程可能导致网络连接中断，降低并发度以提高稳定性
MAS_OUTDATED_PARALLEL_JOBS=4


# 路径：保存日志文件的路径
# ICLOUD_PATH="$HOME/Library/Mobile Documents/com~apple~CloudDocs"            # 获取 iCloud 云盘路径，
# COMPUTER_NAME=$(scutil --get ComputerName)                                  # 获取 本机名称（并以本机名称作为子文件夹名称）
# LOG_PATH="$ICLOUD_PATH/LOG/$COMPUTER_NAME"                                  # LOG 日志文件 的 保存路径
# mkdir -p "$LOG_PATH"                                                        # 创建目录   # 注意：这里是保存到iCloud，也可以设置别的保存路径


# 路径：保存日志文件的路径
# 根据当前运行环境动态确定 iCloud 云盘路径。若以 root 身份运行（例如通过 sudo 调用），
# 则根据实际登录用户的家目录计算 iCloud 路径，保证日志和备份路径始终保存在真实用户的 iCloud 目录下。
if [[ "$(id -u)" -eq 0 ]]; then
    targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
    targetHome=$(eval echo "~$targetUser")
    ICLOUD_PATH="$targetHome/Library/Mobile Documents/com~apple~CloudDocs"
else
    ICLOUD_PATH="$HOME/Library/Mobile Documents/com~apple~CloudDocs"
fi
# 生成用于标识设备的目录名称。格式为“型号名称-芯片名称-序列号/用户名”。
# 型号名称取自系统信息的 Model Name 并删除空格；芯片名称去掉 Apple 前缀并删除所有空格；序列号读取系统序列号。
MODEL_NAME_RAW=$(system_profiler SPHardwareDataType 2>/dev/null | awk -F: '/Model Name/{print $2; exit}')
MODEL_NAME_CLEAN=$(echo "${MODEL_NAME_RAW}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//;s/[[:space:]]//g')
CPU_BRAND_RAW=$(sysctl -n machdep.cpu.brand_string 2>/dev/null)
CPU_BRAND_TRIM=$(echo "${CPU_BRAND_RAW}" | sed 's/^Apple[[:space:]]*//;s/^[[:space:]]*//;s/[[:space:]]*$//')
CPU_BRAND_CLEAN=$(echo "${CPU_BRAND_TRIM}" | sed 's/[[:space:]]//g')
SERIAL_NUMBER_RAW=$(system_profiler SPHardwareDataType 2>/dev/null | awk -F: '/Serial Number/{print $2; exit}')
SERIAL_NUMBER_CLEAN=$(echo "${SERIAL_NUMBER_RAW}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
# 为了确保无论脚本以哪种方式运行（普通用户/通过 sudo 提权等），日志目录均基于实际登录用户而不是当前有效 UID。
# 如果当前 uid 为 0（root），优先使用 $SUDO_USER（sudo 调用者），否则从控制台获取活跃用户；
# 否则直接使用 $USER 环境变量，若未设置则回退到控制台用户。
if [[ "$(id -u)" -eq 0 ]]; then
    # 以 root 运行时尝试还原到调用 sudo 的用户，若不存在则使用当前控制台登录用户
    USER_NAME="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
else
    # 非 root 情况直接使用 USER 环境变量，若不存在则使用当前控制台登录用户
    USER_NAME="${USER:-$(stat -f '%Su' /dev/console)}"
fi

# 如果以 root 身份运行，则对 tee 命令做降权处理，使所有日志写入操作在登录用户上下文中执行。
if [ "$(id -u)" -eq 0 ]; then
    __targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
    __uid="$(id -u "$__targetUser" 2>/dev/null || echo "")"
    if [ -n "$__uid" ]; then
        __original_tee="$(command -v tee)"
        tee() {
            launchctl asuser "$__uid" sudo -n -u "$__targetUser" "$__original_tee" "$@"
        }
        # 定义安全 touch 函数：在 root 下通过登录用户身份创建文件
        safe_touch() {
            local __file="$1"
            launchctl asuser "$__uid" sudo -n -u "$__targetUser" /usr/bin/touch "$__file"
        }
    else
        # 如果无法获取 uid，则回退使用普通 touch
        safe_touch() {
            local __file="$1"
            /usr/bin/touch "$__file"
        }
    fi
else
    # 非 root 身份运行时，safe_touch 直接调用系统 touch
    safe_touch() {
        local __file="$1"
        /usr/bin/touch "$__file"
    }
fi
DEVICE_DIR="${MODEL_NAME_CLEAN}-${CPU_BRAND_CLEAN}-${SERIAL_NUMBER_CLEAN}"
# 清理多余的连字符
DEVICE_DIR=$(echo "$DEVICE_DIR" | sed 's/--*/-/g; s/^-//; s/-$//')


    # 尝试创建日志目录并设置 LOG_PATH。优先使用 iCloud 路径，创建失败则回退到主目录路径
    tmp_log="$ICLOUD_PATH/LOG/${DEVICE_DIR}/${USER_NAME}"
    if mkdir -p "$tmp_log" 2>/dev/null; then
        LOG_PATH="$tmp_log"
        log_created_in_icloud=1
    else
        fallback_home="${targetHome:-$HOME}"
        LOG_PATH="$fallback_home/LOG/${DEVICE_DIR}/${USER_NAME}"
        mkdir -p "$LOG_PATH"
        log_created_in_icloud=0
    fi

# 保留原有 COMPUTER_NAME 变量以供其他逻辑使用
COMPUTER_NAME=$(scutil --get ComputerName)


# 用于标记需要手动运行安装器的 cask
MANUAL_INSTALL_CASKS=("paragon-ntfs" "paragon-extfs")


################################################################################
# 新增：初始化下载失败记录和重试参数
#
# 为了在并行下载阶段准确记录下载失败的软件包及其下载链接，本脚本引入以下变量：
#   FAILED_FETCH_FORMULAS_FILE ：记录 formula 下载失败的包名与下载链接
#   FAILED_FETCH_CASKS_FILE    ：记录 cask 下载失败的包名与下载链接
#   DOWNLOAD_MAX_RETRIES       ：每个软件包下载时最大的重试次数，默认 3 次
# 这些文件在脚本运行开始时会被清空，并在并行下载任务中写入。变量需要导出以便
# 在 sudo/parallel 环境中生效。
# 将下载失败记录文件放在 /tmp 下，确保普通用户也有权限写入
FAILED_FETCH_FORMULAS_FILE=$(mktemp "/tmp/failed_fetch_formulas.XXXXXX")
FAILED_FETCH_CASKS_FILE=$(mktemp "/tmp/failed_fetch_casks.XXXXXX")
# 设置权限，使得目标普通用户可以读写这些文件
chmod 666 "$FAILED_FETCH_FORMULAS_FILE" "$FAILED_FETCH_CASKS_FILE"
# 下载失败的最大重试次数（可按需调整）
# 默认尝试五次，对于网络问题或链接不可用时会重试
DOWNLOAD_MAX_RETRIES=5
# 新增：初始化下载成功记录文件。将其放在 /tmp 下，避免权限问题
SUCCESS_FETCH_FORMULAS_FILE=$(mktemp "/tmp/success_fetch_formulas.XXXXXX")
SUCCESS_FETCH_CASKS_FILE=$(mktemp "/tmp/success_fetch_casks.XXXXXX")
# 设置权限，以便普通用户可以写入
chmod 666 "$SUCCESS_FETCH_FORMULAS_FILE" "$SUCCESS_FETCH_CASKS_FILE"
# 导出变量供子进程使用
export FAILED_FETCH_FORMULAS_FILE FAILED_FETCH_CASKS_FILE DOWNLOAD_MAX_RETRIES
export SUCCESS_FETCH_FORMULAS_FILE SUCCESS_FETCH_CASKS_FILE

# -------------------------------------------------------------------------------------------------
# 根据当前脚本的执行身份，决定 sudo 命令是否强制使用非交互模式
# 如果脚本以 root 身份运行（例如通过 sudo 调用），则后续内部调用 sudo 时添加 -n 选项，
# 防止在无人值守执行时阻塞等待密码。如果脚本以普通用户身份运行，则允许 sudo 正常提示密码
# 以便在交互式终端中完成相应操作。
if [ "$(id -u)" -eq 0 ]; then
    SUDO_N_FLAG="-n"
else
    SUDO_N_FLAG=""
fi
export SUDO_N_FLAG

# =====================
# 新增：校验失败重试参数（默认 1 次）
#
# 当 HomeBrew 在安装过程中检测到下载后的文件 SHA-256 校验失败时，
# 本脚本会停止后续的重装尝试并直接标记为失败。该变量允许用户配置
# 重新尝试升级的次数（1 表示不重试）。如需尝试多次，可修改此值。
SHA_MISMATCH_MAX_RETRIES=1
export SHA_MISMATCH_MAX_RETRIES
################################################################################


# ================================================================================================
# 参数设置：用户可修改 （End）
# ================================================================================================




# ---------------------------------------
# 参数设置：不建议用户修改
# ---------------------------------------

# 定义：日志文件
LOG_FULL_LAST="$LOG_PATH/--UpdateFull-Last--.log"
LOG_FILE="$LOG_PATH/Update_Auto.log"
LOG_FULL_FILE="$LOG_PATH/UpdateFull.$(date +%Y-%m).log"
LOG_ERROR_FILE="$LOG_PATH/Update_Error.log"
LOG_MACUPDATER_FILE="$LOG_PATH/Update_MacUpdater.log"

echo -e "" | tee "$LOG_MACUPDATER_FILE" > /dev/null

# 打印脚本版本信息到日志，方便核对版本。仅在日志路径初始化后执行。
#echo -e "[Info] Script version : $SCRIPT_VERSION" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 调试开关：设置为 true 时，会输出调试信息；运行稳定后可改为 false 以关闭调试输出。
DEBUG_SCRIPT=false

# 开启严格模式与统一错误处理。
# 使用 set -Eeuo pipefail 让脚本在遇到未捕获的错误时立即退出，
# 并通过 trap 捕捉 ERR 事件，在出错时输出详细的错误信息到日志文件。
set -u -o pipefail -E
trap 'last_cmd=$BASH_COMMAND; code=$?; line=${BASH_LINENO[0]}; \
     # 只有非零返回码才视为错误，code=0 时忽略
     if [ "$code" -ne 0 ]; then \
         printf "[FATAL] 第 %s 行命令 \"%s\" 失败，退出码=%s\n" "$line" "$last_cmd" "$code" | \
         tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_ERROR_FILE"; \
         # 不退出脚本，继续执行后续任务
     fi' ERR

# 定义：被测试的外网网址（需要翻墙的网址）
TARGET_1="github.com"                                       # 测试 主流开源软件下载库 的连通性
TARGET_2="formulae.brew.sh/api/formula.jws.json"            # 测试 homebrew 的主站 连通性 (brew.sh)
TARGET_3="apps.apple.com/us/app/apple-store/id375380948"    # 测试 Mac App Store 连通性 （本链接是 苹果官方 Apple Store ）
TARGET_4="macupdater.com"                                   # 测试 MacUpdater 连通性
# 如果不能访问上述网站，会导致很多软件都 更新失败。




# ---------------------------------------
# 自定义函数
# ---------------------------------------


# ************************* #
# 定义函数：检查时间范围的函数
# ************************* #

check_time_range() {

    local stop_time="$1"           # 停止时间
    local duration_minutes="$2"    # 执行时长（分钟）
    local LOG_ERROR_FILE="$3"      # 日志文件

    # 计算起始时间并确保格式为 HH:MM
    local stop_time_seconds start_time
    stop_time_seconds=$(date -j -f "%H:%M" "$stop_time" "+%s") # 将停止时间转换为时间戳
    start_time=$(date -j -f "%s" $((stop_time_seconds - duration_minutes * 60)) "+%H:%M") # 计算起始时间，并转为 HH:MM 格式

    # 获取当前时间
    local current_time
    current_time=$(date '+%H:%M')

    # 检查当前时间是否在范围内
    if [[ ( "$current_time" > "$start_time" || "$current_time" == "$start_time" ) && "$current_time" < "$stop_time" ]]; then
        printf "\033[1;31m[STOP]\033[0m  "
        printf "[STOP] "                                                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  > /dev/null 
        echo -e "任务退出（$(date '+%Y-%m-%d %H:%M:%S')）：为避免与预设 定时任务 冲突"      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_ERROR_FILE" 
        printf "\033[1;31m[STOP]\033[0m  "
        printf "[STOP] "                                                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  > /dev/null 
        echo -e "时间范围（停止建立 更新任务）：$start_time - $stop_time"                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_ERROR_FILE" 
        exit
    fi

}


# ************************* #
# 自定义函数：检查连接的函数

# ************************* #
check_connection() {

    local target=$1
    local LOG_FILE=$2

    if curl -I --connect-timeout 5 "$target" > /dev/null 2>&1; then
        printf "\033[1;32m[OK]\033[0m   "  
        printf "[OK]   "                                                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  > /dev/null  
        printf "已连通 [$target] \n"                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"   
        return 0
    else
        printf "\033[1;31m[ERROR]\033[0m " 
        printf "[ERROR] "                                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_FILE"  > /dev/null  
        echo -e "[$target] $(date '+%Y-%m-%d %H:%M:%S') 连接失败，等待10秒后重试 ... "        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_FILE"  
        sleep 10
        return 1
    fi

}


# ************************* #
# 自定义函数：显示进度条
# ************************* #

show_progress() {

    # 可输入的变量
    local scanned=$1
    local unrecognized=$2
    local to_update=$3
    local total=$4

    # 定义进度条长度（注意：折行，会导致刷新异常！！！！！）
    local bar_width=20

    # 防止除以零
    if [ "$total" -eq 0 ]; then
        total=1
    fi

    # 计算百分比
    local percent=$(( scanned * 100 / total ))

    # 生成进度条
    local filled=$(( scanned * bar_width / total ))
    local empty=$(( bar_width - filled ))
    local bar=""
    for ((i=0; i<filled; i++)); do bar+="█"; done
    for ((i=0; i<empty; i++)); do bar+="-"; done

    # 打印进度条到终端（仅当存在交互终端）
    if [ -t 1 ]; then
        printf "\r进度: [%-${bar_width}s] %d%% | 未识别: %d | 需更新: %d | 已扫描: %d/%d" \
            "$bar" "$percent" "$unrecognized" "$to_update" "$scanned" "$total" > /dev/tty
    fi

}


# ************************* #
# 自定义函数：运行命令并处理输出
# ************************* #

run_command_with_show_progress() {

    # 可输入的变量
    local CMD="$1"
    local MODE="$2" # SCAN 或 UPDATE
    local LOCAL_LOG_FILE="$3" # 

    # 初始化进度变量
    local scanned=0
    local unrecognized=0
    local to_update=0

    # 日志记录开始执行的命令
    echo -e "✓  执行命令: $CMD"         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOCAL_LOG_FILE"

    # 执行命令并实时处理输出
    # 通过在管道结尾加上 '|| true' 避免 set -e 与 pipefail 在命令非零退出时导致脚本终止
    eval "$CMD" 2>&1         | tee -a  "$LOCAL_LOG_FILE" | while IFS= read -r line; do
        # 检查是否为 'Scan did stop scanning' 的行
        if [[ "$line" =~ Scan\ did\ stop\ scanning\ \'[^\']+\'\ app\.\.\. ]]; then
            ((scanned++))
            show_progress "$scanned" "$unrecognized" "$to_update" "$TOTAL_APPS"
        fi

        # 记录每一行到日志文件
        echo -e "$line" >> "$LOCAL_LOG_FILE"
    done || true

    # 完成后换行（避免下次输出覆盖进度条，仅当存在交互终端）
    if [ -t 1 ]; then
        echo -e "" > /dev/tty
    fi
    echo -e ""         | tee -a  "$LOCAL_LOG_FILE"

}


# ************************* #
# 自定义函数：恢复 LaunchPad 和 启动台布局
# ************************* #

restore_desktop_layout() {

    PATH_DesktopLayout_SOURCE1="$HOME/Library/Preferences"

    if [ -z "$PARENT_DIR" ]; then
        USER_ID=$(basename "$(dirname "$TMPDIR")")
        PARENT_DIR=$(find /System/Volumes/Data/private/var/folders/ -maxdepth 2 -type d -name "$USER_ID" 2>/dev/null)
    fi

    PATH_DesktopLayout_SOURCE2="$PARENT_DIR/0"

    if [ ! -f "$PATH_DesktopLayout_BACKUP/com.apple.spaces.plist" ] || \
       [ ! -f "$PATH_DesktopLayout_BACKUP/com.apple.dock.plist" ] || \
       [ ! -d "$PATH_DesktopLayout_BACKUP/com.apple.dock.launchpad" ]; then

        printf  "\033[1;34m[Info]\033[0m "
        printf  "[Info] "                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "错误：备份文件不完整，无法恢复 启动台布局"                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    else

        printf  "\033[1;34m[Info]\033[0m "
        printf  "[Info] "                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null  
        echo -e "开始还原 启动台布局 ... "                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        cp -f   "$PATH_DesktopLayout_BACKUP/com.apple.spaces.plist"       "$PATH_DesktopLayout_SOURCE1/com.apple.spaces.plist"
        cp -f   "$PATH_DesktopLayout_BACKUP/com.apple.dock.plist"         "$PATH_DesktopLayout_SOURCE1/com.apple.dock.plist"
        sudo $SUDO_N_FLAG cp -rf "$PATH_DesktopLayout_BACKUP/com.apple.dock.launchpad" "$PATH_DesktopLayout_SOURCE2"
        printf  "\033[1;34m[Info]\033[0m "
        printf  "[Info] "                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null  
        echo -e "正在重启 启动台布局 ... "                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        killall Dock

    fi

}



# ************************* #
# 自定义函数： GUI 会话里弹通知或对话框
# ************************* #

show_sysupdate_popup() {
    local title="MacOS 更新需要手动操作"
    local msg="脚本未执行安装，请在终端手动输入：\nsoftwareupdate --install --all --force --verbose"

    # 检测当前登录的图形用户
    local consoleUser
    consoleUser=$(stat -f '%Su' /dev/console)           # 10.10+ 正式接口  
    local consoleUid
    consoleUid=$(id -u "$consoleUser")

    # AppleScript；display dialog 会阻塞，可改成 display notification
    local osaScript='display alert "'"$title"'" message "'"$msg"'" buttons {"OK"} giving up after 30'

    if [[ $(id -u) -eq 0 ]]; then                       # 以 root 身份运行
        if launchctl asuser "$consoleUid" true &>/dev/null; then
            launchctl asuser "$consoleUid" /usr/bin/osascript -e "$osaScript" &
        else
            sudo -n -u "$consoleUser" /usr/bin/osascript -e "$osaScript" &
        fi
    else                                                # 普通用户
        /usr/bin/osascript -e "$osaScript" &
    fi
}




# ************************* #
# 自定义函数：尝试优雅退出指定的 HomeBrew 应用，若30秒内未退出则强制结束
# ************************* #

attempt_quit_app() {
    local brew_app_id="$1"
    local brew_process_name="$2"

    # ---------- 新增：容错处理 ----------
    # 情况 A：Bundle ID 缺失，但进程名存在 → 退而直接 kill 进程
    if [[ -z "$brew_app_id" && -n "$brew_process_name" ]]; then
        echo "⚠️  未找到 Bundle ID，改用进程名 $brew_process_name 退出…" 
        /usr/bin/pkill -x "$brew_process_name" 2>/dev/null
        return 0
    fi

    # 情况 B：既缺 Bundle ID 又缺进程名 → 无可用信息，退出
    if [[ -z "$brew_app_id" && -z "$brew_process_name" ]]; then
        echo "⚠️  无法退出应用：缺少 应用ID ( brew_app_id = $brew_app_id ) 或 进程名 ( brew_process_name = $brew_process_name ) ... "
        return 1
    fi

    # ---------- 原有的优雅退出逻辑从此继续 ----------

    # 根据当前权限选择 AppleScript 执行方式（降权到实际用户）
    if [[ $(id -u) -eq 0 ]]; then

        local targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"   # 获取实际登录用户
        local consoleUid="$(id -u "$targetUser" 2>/dev/null)"
        
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 osascript 立刻退出进程。 ... "   
        echo -e "✓  注意：在退出 '$brew_process_name' 进程时，如果程序弹窗，阻止程序退出（需用户手动确认退）。本脚本将等待30秒，然后发起 强制退出，并强制关闭本进程所有窗口 ... "   

        if launchctl asuser "$consoleUid" true &>/dev/null; then
            # 以实际登录用户上下文运行 AppleScript，尝试优雅退出应用（30秒超时）
            launchctl asuser "$consoleUid" /usr/bin/osascript \
                -e "with timeout of 30 seconds" \
                -e "tell application id \"$brew_app_id\" to quit" \
                -e "end timeout"
        else
            # 回退：直接以该用户身份运行 AppleScript
            sudo -n -u "$targetUser" /usr/bin/osascript \
                -e "with timeout of 30 seconds" \
                -e "tell application id \"$brew_app_id\" to quit" \
                -e "end timeout"
        fi

    else

        echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 osascript 立刻退出进程。 ... "     
        echo -e "✓  注意：在退出 '$brew_process_name' 进程时，如果程序弹窗，阻止程序退出（需用户手动确认退）。本脚本将等待30秒，然后发起 强制退出，并强制关闭本进程所有窗口 ... "       

        # 非 root 情况，直接运行 AppleScript 优雅退出
        /usr/bin/osascript \
            -e "with timeout of 30 seconds" \
            -e "tell application id \"$brew_app_id\" to quit" \
            -e "end timeout"

    fi


    local exit_code=$?

    if [[ $exit_code -ne 0 ]]; then
        # 30秒内未正常退出，执行强制结束
        echo -e "✘  无法正常退出 '$brew_process_name' ，正在尝试 强制退出 !!!  "
        if [[ $(id -u) -eq 0 ]]; then
            # 以普通用户权限发送 kill 信号
            echo -e "...  （已完成30秒等待）Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 pkill 强制退出 '$brew_process_name' 进程 ，以便执行 后续更新 ... "   
            local targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
            sudo -n -u "$targetUser" /usr/bin/pkill -x "$brew_process_name"
        else
            echo -e "...  （已完成30秒等待）当前用户 '$USER' 为普通权限，直接运行 pkill 强制退出 '$brew_process_name' 进程 ，以便执行 后续更新 ... "     
            /usr/bin/pkill -x "$brew_process_name"
        fi
    else
        echo -e "✓  已完成退出!!!! 进程 '$brew_process_name' 没有阻塞退出，没有启动30秒等待 !!!  "

    fi

}



# ************************* #
# 自定义函数：统一的错误输出（带着色与日志追加）
# ************************* #

print_error() {
  printf "\033[1;31m[ERROR]\033[0m  "
  printf "[ERROR] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
  echo -e "$*" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
}

# -------------------------------------------------------------------------------
# 辅助函数：run_as_normal_user 和 maybe_run_as_normal_user
# 这些函数在脚本顶层定义，确保在任何地方调用时均已存在。
# run_as_normal_user 会在当前为 root 时降权到真实用户并执行命令，否则直接执行。
# maybe_run_as_normal_user 会根据当前权限自动选择运行 run_as_normal_user 或直接执行命令。
run_as_normal_user() {
  if [ "$(id -u)" -eq 0 ]; then
      local targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
      # 在 root 模式下，使用 sudo 保留环境并降权执行命令，避免重复打印提示
      sudo -n -E -H -u "$targetUser" env PATH="/opt/homebrew/bin:/usr/local/bin:$PATH" HOMEBREW_CASK_OPTS="$HOMEBREW_CASK_OPTS" "$@"
  else
      "$@"
  fi
}
maybe_run_as_normal_user() {
  if [ "$(id -u)" -eq 0 ]; then
      run_as_normal_user "$@"
  else
      "$@"
  fi
}
export -f run_as_normal_user
export -f maybe_run_as_normal_user
##
## 注：run_fsinstaller_if_needed 的定义在脚本稍后部分，为避免出现
## `export: run_fsinstaller_if_needed: not a function` 的错误，这里不立即导出。
## 该函数将在定义完成后再进行 export。








# =========================
# Xcode Command Line Tools
# =========================

check_clt_receipt() {
    /usr/sbin/pkgutil --pkg-info=com.apple.pkg.CLTools_Executables >/dev/null 2>&1 \
    || /usr/sbin/pkgutil --pkg-info=com.apple.pkg.DeveloperToolsCLI >/dev/null 2>&1
}

_auto_find_clt_label() {
    /usr/sbin/softwareupdate --list 2>&1 \
    | /usr/bin/grep -Eo 'Label: .*Command Line Tools.*' \
    | /usr/bin/sed 's/^Label: //; q'
}

auto_install_clt() {
    local TMPFLAG="/tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress"
    local LOGA="$LOG_FULL_LAST" LOGB="$LOG_FULL_FILE"

    echo -e "⚙️  Command Line Tools 收据缺失，尝试自动安装 ..." | tee -a "$LOGA" "$LOGB"

    sudo $SUDO_N_FLAG /bin/rm -f "$TMPFLAG" 2>/dev/null || true
    sudo $SUDO_N_FLAG /usr/bin/touch "$TMPFLAG"

    local LABEL; LABEL="$(_auto_find_clt_label)"

    if [ -z "$LABEL" ] && [ -d /Library/Developer/CommandLineTools ] && ! check_clt_receipt; then
        echo -e "↻ 未找到标签，疑似残留安装；清理并重试一次 ..." | tee -a "$LOGA" "$LOGB"
        sudo $SUDO_N_FLAG /bin/rm -rf /Library/Developer/CommandLineTools
        sudo $SUDO_N_FLAG /bin/rm -f "$TMPFLAG" 2>/dev/null || true
        sudo $SUDO_N_FLAG /usr/bin/touch "$TMPFLAG"
        LABEL="$(_auto_find_clt_label)"
    fi

    if [ -n "$LABEL" ]; then
        echo -e "⚙️  安装: $LABEL" | tee -a "$LOGA" "$LOGB"
        if sudo $SUDO_N_FLAG /usr/sbin/softwareupdate --install "$LABEL" --agree-to-license --verbose 2>&1 | tee -a "$LOGA" "$LOGB"; then
            sudo $SUDO_N_FLAG /bin/rm -f "$TMPFLAG" 2>/dev/null || true
            return 0
        fi
    fi

    sudo $SUDO_N_FLAG /bin/rm -f "$TMPFLAG" 2>/dev/null || true
    echo -e "❌ 未找到 Command Line Tools 更新标签。请手动执行：xcode-select --install" \
        | tee -a "$LOGA" "$LOGB" "$LOG_ERROR_FILE"
    return 1
}

ensure_clt_or_skip_macports() {
    if check_clt_receipt; then
        return 0
    fi
    if auto_install_clt && check_clt_receipt; then
        return 0
    fi
    echo -e "⏭️  跳过 MacPorts：尚未检测到有效的 Command Line Tools 收据。" \
        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_ERROR_FILE"
    return 1
}



# =========================
# MacPorts 辅助函数
# =========================

# 判断是否需要迁移：当 Darwin 主版本、CPU 架构或 MacPorts base 版本变化时迁移
get_darwin_major() { /usr/bin/uname -r | /usr/bin/awk -F. '{print $1}'; }
get_arch() { /usr/bin/uname -m; }
get_macports_base_ver() { /opt/local/bin/port version 2>/dev/null | /usr/bin/awk '{print $2}'; }

MP_STATE_DIR="$HOME/.local/state/usercmd"
MP_MIGRATE_TOKEN_FILE="$MP_STATE_DIR/macports.migrate.token"

macports_should_migrate() {
    /bin/mkdir -p "$MP_STATE_DIR" 2>/dev/null || true
    local cur_token="$(get_darwin_major)-$(get_arch)-$(get_macports_base_ver)"
    [ ! -f "$MP_MIGRATE_TOKEN_FILE" ] && { echo "$cur_token" > "$MP_STATE_DIR/.need_migrate.tmp"; return 0; }
    local old_token; old_token="$(/bin/cat "$MP_MIGRATE_TOKEN_FILE" 2>/dev/null || echo "")"
    if [ "$old_token" != "$cur_token" ]; then
        echo "$cur_token" > "$MP_STATE_DIR/.need_migrate.tmp"
        return 0
    fi
    return 1
}

macports_mark_migrated() {
    [ -f "$MP_STATE_DIR/.need_migrate.tmp" ] && /bin/mv -f "$MP_STATE_DIR/.need_migrate.tmp" "$MP_MIGRATE_TOKEN_FILE"
}

# 静默升级过期端口并生成摘要
macports_upgrade_outdated_quiet() {
    printf  "\033[1;34m[Download & Install]\033[0m " 
    printf  "[Download & Install] "                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "MacPorts 下载安装 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    echo -e "【升级摘要】" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 使用 -u 开关可在升级完成后卸载旧版本，以便在完成升级后自动清理老版本；--no-rev-upgrade 禁止在升级之后触发 rev-upgrade 检查
    sudo $SUDO_N_FLAG /opt/local/bin/port -u -N upgrade --no-rev-upgrade outdated 2>&1 \
      | /usr/bin/grep -E '^--->  (Upgrading|Installing|Activating|Deactivating) |^Error:' \
      | /usr/bin/sed -E \
        -e 's/^--->[[:space:]]+Upgrading[[:space:]]+([^[:space:]]+)[[:space:]]+@([^[:space:]]+)[[:space:]]+to[[:space:]]+@([^[:space:]]+).*/• \1  \2  →  \3/' \
        -e 's/^--->[[:space:]]+Installing/• Installing/' \
        -e 's/^--->[[:space:]]+Activating/• Activating/' \
        -e 's/^--->[[:space:]]+Deactivating/• Deactivating/' \
      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
}

macports_rev_upgrade_quiet() {
    # 显示扫描与结果，不落独立文件，只写主日志
    sudo $SUDO_N_FLAG /opt/local/bin/port rev-upgrade 2>&1 \
      | /usr/bin/grep -E '^--->  Scanning binaries for linking errors|^--->  No broken (files|ports) found\.|^Found [0-9]+ broken|^--->  Rebuilding ' \
      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
}


__get_migrate_log_file() {
    local base=""
    [ -n "${LOG_UPDATE_MACUPDATER:-}" ] && base="$LOG_UPDATE_MACUPDATER"
    [ -z "$base" ] && [ -n "${UPDATE_MACUPDATER_LOG:-}" ] && base="$UPDATE_MACUPDATER_LOG"
    [ -z "$base" ] && [ -f "$HOME/Update_MacUpdater.log" ] && base="$HOME/Update_MacUpdater.log"
    [ -z "$base" ] && [ -n "${LOG_FULL_LAST:-}" ] && base="$LOG_FULL_LAST"
    [ -z "$base" ] && [ -n "${LOG_FULL_FILE:-}" ] && base="$LOG_FULL_FILE"
    [ -z "$base" ] && base="$HOME/Update_MacUpdater.log"
    local dir="${base%/*}"; [ "$dir" = "$base" ] && dir="$HOME"
    echo "${dir}/Migrate_MacPorts.log"
}






# -----------------------------------------------
# 检查 & 创建 ：Log日志文件
# -----------------------------------------------

# 重置LOG_FULL_LAST日志文件
cat /dev/null | tee "$LOG_FULL_LAST" > /dev/null

# 检查LOG_FILE日志文件是否存在
if [ ! -f "$LOG_FILE" ]; then
    # 文件不存在，创建文件
    safe_touch "$LOG_FILE"
fi

# 检查LOG_ERROR_FILE日志文件是否存在
if [ ! -f "$LOG_ERROR_FILE" ]; then
    # 文件不存在，创建文件
    safe_touch "$LOG_ERROR_FILE"
fi

# 检查LOG_FULL_FILE日志文件是否存在
if [ ! -f "$LOG_FULL_FILE" ]; then
    # 文件不存在，创建文件
    safe_touch "$LOG_FULL_FILE"
else
    # 文件存在，检查文件大小
    FILE_SIZE=$(stat -f%z "$LOG_FULL_FILE") # macOS 使用 stat -f%z

    if [ "$FILE_SIZE" -gt 10 ]; then
        # 如果文件大小超过100字节，执行以下操作
        # 使用 tee 写入空行，借助上方的 tee 函数（当 root 运行时自动降权）
        echo -e "" | tee -a "$LOG_FULL_FILE" > /dev/null
        echo -e "" | tee -a "$LOG_FULL_FILE" > /dev/null
        echo -e "" | tee -a "$LOG_FULL_FILE" > /dev/null
        echo -e "" | tee -a "$LOG_FULL_FILE" > /dev/null
        echo -e "" | tee -a "$LOG_FULL_FILE" > /dev/null
        echo -e "" | tee -a "$LOG_FULL_FILE" > /dev/null
    fi
fi

# 初始化 MacUpdater 日志文件（使用 tee 降权写入）
echo -e "MacUpdater 执行日志 - $(date)" | tee "$LOG_MACUPDATER_FILE" > /dev/null



# ---------------------------------------
# 检测：外网是否能正常访问
# ---------------------------------------

#echo $PWD

echo -e ""                                                                              | tee -a "$LOG_ERROR_FILE"
echo -e "-------------------------------------------------------------------"           | tee -a "$LOG_ERROR_FILE" > /dev/null
echo -e "" | tee -a "$LOG_ERROR_FILE" > /dev/null
echo -e "[Version]  $SCRIPT_VERSION "                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_ERROR_FILE" 
echo -e "[Running]  $(date '+%Y-%m-%d      %H:%M:%S')   "                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_ERROR_FILE" 
echo -e "======================================================================="       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
printf  "测试网络（海外 HTTPS 连接） ...   |   "                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_ERROR_FILE" 
echo -e "当前工作目录 = '$PWD' "                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_ERROR_FILE" 
echo -e ""                                                                              | tee -a "$LOG_ERROR_FILE" > /dev/null

# 轮询检查网络连通性
while true; do

    # 调用检查时间范围函数
    check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

    # 检查 TARGET_1 的连接
    if ! check_connection "$TARGET_1" "$LOG_ERROR_FILE"; then
        continue # 如果连接失败，重新开始循环
    fi

    # 检查 TARGET_2 的连接
    if ! check_connection "$TARGET_2" "$LOG_ERROR_FILE"; then
        continue # 如果连接失败，重新开始循环
    fi

    # 检查 TARGET_3 的连接
    if ! check_connection "$TARGET_3" "$LOG_ERROR_FILE"; then
        continue # 如果连接失败，重新开始循环
    fi

    # 检查 TARGET_4 的连接
    if ! check_connection "$TARGET_4" "$LOG_ERROR_FILE"; then
        continue # 如果连接失败，重新开始循环
    fi

    # 如果N个目标，都成功连接，退出循环
    printf "\033[1;32m[OK]\033[0m   "  
    printf "[OK]   "                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "海外 HTTPS 连接正常 ... ✅ "                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    break

done

echo -e "======================================================================="       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"





# -----------------------------------------------
# 检查 ：软硬件信息
# -----------------------------------------------


echo -e "测试安装环境：$(date '+%Y-%m-%d %H:%M:%S') ... "                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

echo -e "\033[1;36m-----------------------------------------------\033[0m" 
echo -e "\033[1;36m 检查 ：软硬件信息            \033[0m"
echo -e "\033[1;36m-----------------------------------------------\033[0m" 

echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "检查 ：软硬件信息            "                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

# 采集系统软硬件信息

# 获取硬件类型（Model Name）
hardware_type=$(system_profiler SPHardwareDataType | awk -F': ' '/Model Name/{print $2}' | sed 's/^ *//')
# 获取 CPU 的 芯片型号
cpu_chip=$(sysctl -n machdep.cpu.brand_string)
# 获取内存大小
memory_size=$(system_profiler SPHardwareDataType | awk -F': ' '/Memory/{print $2}' | sed 's/^ *//')
# 获取磁盘总容量，只取括号前的值（如 "8 TB"），忽略后面的字节数
disk_capacity=$(system_profiler SPStorageDataType \
        | awk -F': ' '/^ *Capacity/{print $2; exit}' \
        | awk -F'(' '{print $1}' \
        | sed 's/^ *//; s/ *$//')
storage_info="${memory_size} / ${disk_capacity}"
# 获取 OS 的 版本名称 (如 tahoe 26)，仅保留代号部分（如 tahoe）
os_full_name=$(awk '/SOFTWARE LICENSE AGREEMENT FOR macOS/' '/System/Library/CoreServices/Setup Assistant.app/Contents/Resources/en.lproj/OSXSoftwareLicense.rtf' | awk -F 'macOS ' '{print $NF}' | awk '{print substr($0, 0, length($0)-1)}')
os_full_name=$(echo "$os_full_name" | tr '[:upper:]' '[:lower:]')
os_name=$(echo "$os_full_name" | awk '{print $1}')

# 获取操作系统版本号（例如 26.0.1 或 15.0），用于显示但不用于平台键
os_version=""
if command -v sw_vers >/dev/null 2>&1; then
    os_version=$(sw_vers -productVersion 2>/dev/null || echo "")
fi
# 获取硬件序列号
hardware_sn=$(system_profiler SPHardwareDataType | awk -F': ' '/Serial Number/{print $2}' | sed 's/^ *//')
# 获取当前的名称信息，用于显示计算机名称
computer_name=$(scutil --get ComputerName 2>/dev/null || true)
local_host_name=$(scutil --get LocalHostName 2>/dev/null || true)
host_name_output=$(scutil --get HostName 2>/dev/null || true)
host_name=""
if [ -n "$host_name_output" ]; then
    host_name="${host_name_output#HostName*: }"
    if [[ "$host_name" = "not set" ]]; then
        host_name=""
    fi
fi

# 初始化 sync_message 为空
sync_message=""

echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 打印软硬件信息
printf "\033[1;34m[INFO]\033[0m "
printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "硬件类型    = '$hardware_type'" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

printf "\033[1;34m[INFO]\033[0m "
printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "芯片型号    = '$cpu_chip'" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

printf "\033[1;34m[INFO]\033[0m "
printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "存储容量    = '$storage_info'" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

printf "\033[1;34m[INFO]\033[0m "
printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
# 在 OS 行末尾附加版本号信息，以便显示但不影响平台键
if [ -n "$os_version" ]; then
    # 显示代号和版本号，避免影响平台键
    echo -e "OS 版本     = '$os_name / v$os_version' " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
else
    echo -e "OS 版本     = '$os_name'" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
fi

printf "\033[1;34m[INFO]\033[0m "
printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "硬件序列号  = '$hardware_sn'" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 计算机名称显示（检查是否一致）
if [ -n "$host_name" ] && [ "$computer_name" = "$host_name" ] && [ "$local_host_name" = "$host_name" ]; then
    printf "\033[1;34m[INFO]\033[0m "
    printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "计算机名称  = '$host_name'  ( HostName \ ComputerName \ LocalHostName )" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
else
    if [ -n "$host_name" ]; then
        if [ "$computer_name" != "$host_name" ]; then
            printf "\033[1;34m[INFO]\033[0m "
            printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
            echo -e "计算机名称  = '$computer_name'   （HostName = '$host_name'）" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        fi
        if [ "$local_host_name" != "$host_name" ]; then
            printf "\033[1;34m[INFO]\033[0m "
            printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
            echo -e "本地主机名称= '$local_host_name'   （HostName = '$host_name'）" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        fi
        if [ "$computer_name" != "$host_name" ] || [ "$local_host_name" != "$host_name" ]; then
            sudo $SUDO_N_FLAG scutil --set ComputerName "$host_name" > /dev/null 2>&1
            sudo $SUDO_N_FLAG scutil --set LocalHostName "$host_name" > /dev/null 2>&1
            sync_message="主机名称 已同步"
        fi
    else
        echo -e "\033[1;34m[WARN] ⚠️ HostName 未设置，无法同步 ComputerName 与 LocalHostName。请运行：sudo scutil --set HostName \"$local_host_name\" 后再执行脚本。 \033[0m" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        echo -e "[WARN] ⚠️ HostName 未设置，无法同步 ComputerName 与 LocalHostName。请运行：sudo scutil --set HostName \"$local_host_name\" 后再执行脚本。" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    fi
fi

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 打印软硬件检测完成 OK
echo -e "\033[1;36m[OK] 硬件检测 已完成\033[0m "
echo -e "[OK] 硬件检测 已完成" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

# 如果进行了主机名同步，则打印 OK 消息
if [ -n "$sync_message" ]; then
    echo -e "\033[1;36m[OK] $sync_message\033[0m "
    echo -e "[OK] $sync_message" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
fi

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# -----------------------------------------------
# 检查 ：工作目录（权限） 是否 正确分配
# -----------------------------------------------

echo -e "\033[1;36m-----------------------------------------------\033[0m" 
echo -e "\033[1;36m 检查 ：工作目录 & 权限            \033[0m"
echo -e "\033[1;36m-----------------------------------------------\033[0m" 

echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "检查 ：工作目录 & 权限            "                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

printf "\033[1;34m[INFO]\033[0m "
printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "根目录      = '$HOME'  (当前用户)" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

printf "\033[1;34m[INFO]\033[0m "
printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "工作目录    = '$(pwd)'  (当前脚本)" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

printf "\033[1;34m[INFO]\033[0m "
printf "[INFO] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "当前用户    = '$USER'" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"


echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 切换工作目录
current_dir=$(pwd)
if [ "$HOME" != "$current_dir" ]; then
    cd "$HOME"
    echo -e "\033[1;36m[OK] 工作目录 已切换为 : '$(pwd)' \033[0m "
    echo -e "[OK] 工作目录 已切换为 : '$(pwd)' " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
else
    echo -e "\033[1;36m[OK] 工作目录 无需切换 \033[0m "
    echo -e "[OK] 工作目录 无需切换 " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
fi

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"



# -----------------------------------------------
# 检查 1 ：HomeBrew 是否安装（并更新）
# -----------------------------------------------

echo -e "\033[1;36m-----------------------------------------------\033[0m" 
echo -e "\033[1;36m 检测 “HomeBrew与系统架构” 是否匹配         \033[0m"
echo -e "\033[1;36m-----------------------------------------------\033[0m" 

echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "检测 “HomeBrew与系统架构” 是否匹配"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

# 检测系统架构

architecture=$(uname -m)

if [ "$architecture" = "arm64" ]; then

    # 检查 HomeBrew 是否已安装
    if ! command -v brew > /dev/null 2>&1 ; then

        printf  "\033[1;34m[INFO]\033[0m "
        printf  "[INFO] "                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "未检测到 HomeBrew，开始安装 HomeBrew ... "                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/HomeBrew/install/HEAD/install.sh)"
        
        # 添加 HomeBrew 到环境变量
        echo -e 'eval "$(/opt/homebrew/bin/brew shellenv)"' >> ~/.zprofile
        eval "$(/opt/homebrew/bin/brew shellenv)"
        
        printf  "\033[1;34m[INFO]\033[0m "
        printf  "[INFO] "                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "HomeBrew 安装完成。"                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        echo -e ""                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        exit 1

    fi

    # 获取 HomeBrew 的 安装路径
    brew_path=$(brew --prefix)
    printf  "\033[1;34m[INFO]\033[0m "
    printf  "[INFO] "                                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "HomeBrew目录 = '$brew_path'"                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 获取 CPU 的 处理器指令集
    cpu_isa=$(uname -m)
    printf  "\033[1;34m[INFO]\033[0m "
    printf  "[INFO] "                                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "CPU   指令集 = '$cpu_isa'"                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    if [[ $cpu_isa == "arm64" && $brew_path == "/opt/homebrew" ]]; then

        echo -e "\033[1;36m[OK] HomeBrew 无需更改  \033[0m"
        echo -e "[OK] HomeBrew 无需更改  "                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        # 更新 HomeBrew
        echo -e ""                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        echo -e ""                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

        echo -e "\033[1;36m-----------------------------------------------\033[0m" 
        echo -e "\033[1;36m 更新 HomeBrew 工具 \033[0m"
        echo -e "\033[1;36m-----------------------------------------------\033[0m" 

        echo -e "-------------------------------------------"                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "更新 HomeBrew 工具 "                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "-------------------------------------------"                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

        echo -e ""                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

        # 检查是否以 root 身份运行
        # 初始化退出码变量，用于统计 HomeBrew 更新和 analytics 操作的执行结果
        brew_update_rc=0
        brew_analytics_rc=0
        if [ "$(id -u)" -eq 0 ]; then
            # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
            targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
            echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 HomeBrew 自更新 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            # 以目标用户身份执行 HomeBrew 命令：更新索引
            sudo -n -H -u "$targetUser" brew update --force 2>&1 |
                tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            brew_update_rc=${PIPESTATUS[0]}
            # 关闭匿名使用统计，提升隐私
            echo -e "✓  设置 HomeBrew analytics off" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            sudo -n -H -u "$targetUser" brew analytics off 2>&1 |
                tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            brew_analytics_rc=${PIPESTATUS[0]}
           ## 执行 brew doctor 进行环境自检，不影响整体退出码
           #echo -e "✓  执行 brew doctor 自检" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
           #sudo -H -u "$targetUser" brew doctor || true                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        else
            echo -e "✓   当前用户 '$USER' 为普通权限，直接运行 HomeBrew 自更新 ... "             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            brew update --force 2>&1 |
                tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            brew_update_rc=${PIPESTATUS[0]}
            # 关闭匿名使用统计，提升隐私
            echo -e "✓  设置 HomeBrew analytics off" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            brew analytics off 2>&1 |
                tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            brew_analytics_rc=${PIPESTATUS[0]}
           ## 执行 brew doctor 进行环境自检，不影响整体退出码
           #echo -e "✓  执行 brew doctor 自检" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
           #brew doctor || true                                                         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        fi

        echo -e ""  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

        # 根据更新和 analytics 的退出码输出总结信息
        if [ $brew_update_rc -eq 0 ] && [ $brew_analytics_rc -eq 0 ]; then
            echo -e '\033[1;36m[OK] 更新 HomeBrew 工具 已完成\033[0m '
            echo -e '[OK] 更新 HomeBrew 工具 已完成' | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        else
            echo -e '\033[1;31m[ERROR] 更新 HomeBrew 工具 失败 ❌\033[0m '
            echo -e '[ERROR] 更新 HomeBrew 工具 失败 ❌' | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        fi

       #exit 1

     elif [[ $cpu_isa == "arm64" && $brew_path == "/usr/local" ]]; then

        printf  "\033[1;31m[ERROR]\033[0m "
        printf  "[ERROR] "                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "检测到当前 HomeBrew 为 x86_64 版本，准备切换为 ARM 版本  ❌"           | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        
        # exit 1   # 调试使用！！！

        # 提示用户确认卸载 x86_64 版本的 HomeBrew
        #read -p "此操作将卸载 x86_64 版本的 HomeBrew，并安装 ARM 版本。是否继续？(y/N): " confirm
        #if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        #    print_info "取消操作。"
        #    exit 1
        #fi

        # 卸载 x86_64 版本的 HomeBrew
        echo -e "✓   正在卸载 x86_64 版本的 HomeBrew ... "                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/HomeBrew/install/HEAD/uninstall.sh)"                         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        
        # 安装 ARM 版本的 HomeBrew
        echo -e "✓   正在安装 ARM 版本的 HomeBrew ... "                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 非交互式安装
        NONINTERACTIVE=1 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/HomeBrew/install/HEAD/install.sh)"         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        
        # 添加 HomeBrew 到环境变量
        echo -e 'eval "$(/opt/homebrew/bin/brew shellenv)"' >> ~/.zprofile
        eval "$(/opt/homebrew/bin/brew shellenv)"
        
        echo -e "✓  ARM 版本的 HomeBrew 安装完成。"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

        # 获取 HomeBrew 的安装路径
        brew_newpath=$(which brew)
        echo -e "✓  检测到 HomeBrew 安装路径: $brew_newpath"                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        echo -e ""                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

        if [[ $brew_newpath == /opt/homebrew/* ]]; then
            printf  "\033[1;32m[OK]\033[0m "
            printf  "[OK]   "                                                           | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
            echo -e "验证结果：当前 HomeBrew 为 ARM 版本。"                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
           #echo -e ""                                                                  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        elif [[ $brew_newpath == /usr/local/* ]]; then
            printf  "\033[1;31m[ERROR]\033[0m "
            printf  "[ERROR] "                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
            echo -e "验证结果：检测到当前 HomeBrew 为 x86_64 版本。退出"                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
           #echo -e ""                                                                  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        else
            printf  "\033[1;31m[ERROR]\033[0m "
            printf  "[ERROR] "                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
            echo -e "验证结果：检测未知版本。退出"                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
           #echo -e ""                                                                  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        fi

    else

        print_error "未知的 HomeBrew 安装路径: $brew_path"                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
       #echo -e ""                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    fi

else

    printf "当前系统不是 ARM 架构 (Apple Silicon)，本脚本暂不支持。"                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
   #echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    exit 1 

fi

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 





# ------------------------------------------------
# 检查 2 ：其他HomeBrew工具 是否安装（并更新）
# ------------------------------------------------

# 调用检查时间范围函数
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

# 使用安全方式检查四个必备的 HomeBrew 工具（jq、coreutils、parallel、aria2）是否已安装。
# 当脚本以 root 身份运行时降权执行 brew list 以获取正确的安装列表；否则直接执行 brew list。
need_install_other_tools=false
brew_list_output=""
if [ "$(id -u)" -eq 0 ]; then
    targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
    brew_list_output=$(sudo -n -E -H -u "$targetUser" env PATH="/opt/homebrew/bin:/usr/local/bin:$PATH" brew list 2>/dev/null || true)
else
    brew_list_output=$(brew list 2>/dev/null || true)
fi
for tool in jq coreutils parallel aria2; do
    if ! echo "$brew_list_output" | grep -q "^${tool}$"; then
        need_install_other_tools=true
        break
    fi
done
if [ "$need_install_other_tools" = true ]; then
    echo -e ""                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    echo -e "\033[1;36m-----------------------------------------------\033[0m"
    echo -e "\033[1;36m 安装 其他必备工具 \033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m"

    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "安装 其他必备工具 "                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
fi

# 定义辅助函数：根据安装列表决定是否执行 brew install
install_if_missing() {
    local pkg="$1"
    local list="$2"
    if echo "$list" | grep -q "^${pkg}$"; then
        return 0
    fi
    # 输出安装提示
    printf  "\033[1;34m[INFO]\033[0m "
    echo -e "[安装] $pkg ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 根据权限执行安装
    if [ "$(id -u)" -eq 0 ]; then
        targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        sudo -n -E -H -u "$targetUser" env PATH="/opt/homebrew/bin:/usr/local/bin:$PATH" brew install "$pkg" 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    else
        brew install "$pkg" 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    fi
    echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
}

# 逐个检查并安装工具
install_if_missing "aria2" "$brew_list_output"
install_if_missing "parallel" "$brew_list_output"
install_if_missing "coreutils" "$brew_list_output"
install_if_missing "jq" "$brew_list_output"

# 检查并安装 buo/cask-upgrade tap
taps_output=""
if [ "$(id -u)" -eq 0 ]; then
    taps_output=$(sudo -n -E -H -u "$targetUser" env PATH="/opt/homebrew/bin:/usr/local/bin:$PATH" brew tap 2>/dev/null || true)
else
    taps_output=$(brew tap 2>/dev/null || true)
fi
if ! echo "$taps_output" | grep -q '^buo/cask-upgrade$'; then
    printf  "\033[1;34m[INFO]\033[0m "
    echo -e "[安装] buo/cask-upgrad ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    if [ "$(id -u)" -eq 0 ]; then
        sudo -n -E -H -u "$targetUser" env PATH="/opt/homebrew/bin:/usr/local/bin:$PATH" brew tap buo/cask-upgrade 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    else
        brew tap buo/cask-upgrade 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    fi
    echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
fi



# -----------------------------------------------
# 更新 Sparkle 工具
# -----------------------------------------------

# 调用检查时间范围函数
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

# 判断 Sparkle 是否已安装（cask）
sparkle_installed=false
{
    sparkle_list_output=""
    if [ "$(id -u)" -eq 0 ]; then
        sparkle_targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        sparkle_list_output=$(sudo -n -E -H -u "$sparkle_targetUser" env PATH="/opt/homebrew/bin:/usr/local/bin:$PATH" brew list --cask 2>/dev/null || true)
    else
        sparkle_list_output=$(brew list --cask 2>/dev/null || true)
    fi
    if echo "$sparkle_list_output" | grep -q '^sparkle$'; then
        sparkle_installed=true
    fi
}

################################################################################
# 函数：run_fsinstaller_if_needed
#
# 某些 HomeBrew Cask（例如 Paragon 系列）在安装或升级后会提示用户手动运行
# “FSInstaller.app” 来完成安装。本函数尝试根据 brew 输出临时文件或日志查找
# FSInstaller 路径，若存在则移除隔离标记并在后台启动安装器。
# 参数：
#   $1 - Cask 名称
#   $2 - 临时输出文件（若存在）
#   $3 - 日志文件（若存在）
run_fsinstaller_if_needed() {
    local __cask_name="$1"
    local __tmpfile="$2"
    local __logfile="$3"
    local __installer_path=""

    # 调试输出：记录函数调用及传入参数
    if [ "${DEBUG_SCRIPT:-false}" = true ]; then
        echo -e "[DEBUG] run_fsinstaller_if_needed: cask=\"${__cask_name}\", tmpfile=\"${__tmpfile}\", logfile=\"${__logfile}\"" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    fi

    # 尝试从临时文件中解析 FSInstaller 路径
    if [[ -n "$__tmpfile" && -f "$__tmpfile" ]]; then
        __installer_path=$(grep -oE "/[^ ]*/${__cask_name}/[^ ]*/FSInstaller\.app" "$__tmpfile" | head -n 1 || true)
    fi
    # 从日志文件中回溯查找
    if [[ -z "$__installer_path" && -n "$__logfile" && -f "$__logfile" ]]; then
        __installer_path=$(grep -oE "/[^ ]*/${__cask_name}/[^ ]*/FSInstaller\.app" "$__logfile" | tail -n 1 || true)
    fi
    # 如果仍未找到，则在 Caskroom 目录中查找
    if [[ -z "$__installer_path" ]]; then
        local __caskroom_base
        __caskroom_base=$(brew --prefix)/Caskroom
        if [[ -d "$__caskroom_base/${__cask_name}" ]]; then
            __installer_path=$(find "$__caskroom_base/${__cask_name}" -maxdepth 3 -type d -name "FSInstaller.app" 2>/dev/null | sort -r | head -n 1 || true)
        fi
    fi
    # 找到安装器路径后执行安装
    if [[ -n "$__installer_path" && -d "$__installer_path" ]]; then
        if [[ $(id -u) -eq 0 ]]; then
            local __targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
            sudo -n -u "$__targetUser" xattr -dr com.apple.quarantine "$__installer_path" || true
            sudo -n -u "$__targetUser" open -n "$__installer_path" >/dev/null 2>&1 &
        else
            xattr -dr com.apple.quarantine "$__installer_path" || true
            open -n "$__installer_path" >/dev/null 2>&1 &
        fi
        echo -e "⚠️  检测到 ${__cask_name} 需要手动安装，已尝试后台启动安装器：${__installer_path}" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    else
        # 调试输出：未找到手动安装器
        if [ "${DEBUG_SCRIPT:-false}" = true ]; then
            echo -e "[DEBUG] run_fsinstaller_if_needed: No FSInstaller.app found for ${__cask_name}" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        fi
    fi
}

# 将 run_fsinstaller_if_needed 导出到子进程。
# 由于函数定义在此处才出现，故需在此处导出，避免在脚本顶部导出时出现
# "export: run_fsinstaller_if_needed: not a function" 的错误。
export -f run_fsinstaller_if_needed


echo -e "\033[1;36m-----------------------------------------------\033[0m"
echo -e "\033[1;36m 更新 Sparkle 工具 \033[0m"
echo -e "\033[1;36m-----------------------------------------------\033[0m"

echo -e "-------------------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "更新 Sparkle 工具 " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 初始化 Sparkle 工具更新退出码
sparkle_update_rc=0

if [ "$sparkle_installed" = true ]; then
    # 已安装，执行更新
    if [ "$(id -u)" -eq 0 ]; then
        targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 Sparkle 自更新 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        sudo -n -H -u "$targetUser" brew upgrade --greedy --cask sparkle 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        sparkle_update_rc=${PIPESTATUS[0]}
    else
        echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 Sparkle 自更新 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        brew upgrade --greedy --cask sparkle 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        sparkle_update_rc=${PIPESTATUS[0]}
    fi
else
    # 未安装，执行安装
    if [ "$(id -u)" -eq 0 ]; then
        targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        echo -e "✓  Sparkle 未安装, Root权限 降权至 普通权限 ( $targetUser ) 后 , 运行 brew install --cask sparkle 进行安装 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        sudo -n -H -u "$targetUser" brew install --cask sparkle 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        sparkle_update_rc=${PIPESTATUS[0]}
    else
        echo -e "✓  Sparkle 未安装, 当前用户 '$USER' 为普通权限, 运行 brew install --cask sparkle 进行安装 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        brew install --cask sparkle 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        sparkle_update_rc=${PIPESTATUS[0]}
    fi
fi

echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
if [ $sparkle_update_rc -eq 0 ]; then
    echo -e '\033[1;36m[OK] 更新 Sparkle 工具 已完成\033[0m '
    echo -e '[OK] 更新 Sparkle 工具 已完成' | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    sparkle_available=true
else
    echo -e '\033[1;31m[ERROR] 更新 Sparkle 工具 失败 ❌\033[0m '
    echo -e '[ERROR] 更新 Sparkle 工具 失败 ❌' | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    sparkle_available=false
fi

echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# -----------------------------------------------
# 检查 3 ：MAS 是否安装（并更新）
# -----------------------------------------------

# 调用检查时间范围函数
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

# 判断 mas 是否已安装：在 root 环境降权执行 brew list --formula
mas_installed=false
{
    mas_list_output=""
    if [ "$(id -u)" -eq 0 ]; then
        mas_targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        mas_list_output=$(sudo -n -E -H -u "$mas_targetUser" env PATH="/opt/homebrew/bin:/usr/local/bin:$PATH" brew list --formula 2>/dev/null || true)
    else
        mas_list_output=$(brew list --formula 2>/dev/null || true)
    fi
    if echo "$mas_list_output" | grep -q '^mas$'; then
        mas_installed=true
    fi
}

if [ "$mas_installed" = true ]; then

    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "\033[1;36m 更新 MAS 工具 \033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 

    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "更新 MAS 工具"                                                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    # 检查是否以 root 身份运行
    mas_update_rc=0
    if [ "$(id -u)" -eq 0 ]; then
        # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
        targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 MAS 自更新 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 以目标用户身份执行 HomeBrew 命令
        sudo -n -H -u "$targetUser" brew upgrade --greedy mas 2>&1 |
            tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        mas_update_rc=${PIPESTATUS[0]}
    else
        echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 MAS 自更新 ... "            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        brew upgrade --greedy mas 2>&1 |
            tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        mas_update_rc=${PIPESTATUS[0]}
    fi

    echo -e  "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 输出 MAS 更新结果：只有当更新命令返回 0 时标记为成功
    if [ $mas_update_rc -eq 0 ]; then
        # 打印绿色 [OK] 提示（彩色输出仅在控制台显示）
        echo -e  '\033[1;36m[OK] 更新 MAS 工具 已完成\033[0m '
        # 在日志中记录 [OK] 状态但不重复显示到控制台
        echo -e  '[OK] 更新 MAS 工具 已完成' | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    else
        # 打印红色 [ERROR] 提示（彩色输出仅在控制台显示）
        echo -e  '\033[1;31m[ERROR] 更新 MAS 工具 失败 ❌\033[0m '
        # 在日志中记录 [ERROR] 状态但不重复显示到控制台
        echo -e  '[ERROR] 更新 MAS 工具 失败 ❌' | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    fi

else

    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "\033[1;36m MAS 未安装，开始安装 \033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "MAS 未安装，开始安装"                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

    # 检查是否以 root 身份运行
    mas_install_rc=0
    if [ "$(id -u)" -eq 0 ]; then
        # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
        targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 MAS 安装 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 以目标用户身份执行 HomeBrew 命令
        sudo -n -H -u "$targetUser" bash -c 'brew install mas 2>&1'              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        mas_install_rc=${PIPESTATUS[0]}
    else
        echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 MAS 安装 ... "                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        brew install mas 2>&1                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        mas_install_rc=${PIPESTATUS[0]}
    fi

    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    if [ $mas_install_rc -eq 0 ]; then
        echo -e "MAS 安装成功。"                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    else
        echo -e "MAS 安装失败。"                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    fi

fi

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 





# -----------------------------------------------
# 检查 4 ：MacPorts 是否安装（并更新）
# -----------------------------------------------

# 调用检查时间范围函数
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

if command -v /opt/local/bin/port >/dev/null 2>&1; then

    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "\033[1;36m 更新 MacPorts 工具 \033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "-------------------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "更新 MacPorts 工具  "       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "-------------------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e ""                         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 保证 CLT 收据存在，否则跳过 MacPorts 更新
    macports_update_rc=0
    if ensure_clt_or_skip_macports; then
        echo -e "✓  使用Root权限(sudo命令), 运行 MacPorts 自更新 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # MacPorts 基础更新：仅运行自更新以更新 MacPorts base 和 ports 树
        sudo $SUDO_N_FLAG /opt/local/bin/port selfupdate 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        macports_update_rc=${PIPESTATUS[0]}
    fi
    # 输出 MacPorts 更新结果（即便没有执行更新，也视为成功）。

    echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 仅当自更新命令返回 0 时视为成功，其余情况标记为错误。
    if [ $macports_update_rc -eq 0 ]; then
        # 打印绿色 [OK] 提示
        echo -e '\033[1;36m[OK] 更新 MacPorts 工具 已完成\033[0m '
        # 在日志中记录 [OK]
        echo -e '[OK] 更新 MacPorts 工具 已完成' | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    else
        # 打印红色 [ERROR] 提示
        echo -e  '\033[1;31m[ERROR] 更新 MacPorts 工具 失败 ❌\033[0m '
        # 在日志中记录 [ERROR]
        echo -e  '[ERROR] 更新 MacPorts 工具 失败 ❌' | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    fi

else
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "\033[1;36m MacPorts 未安装，开始安装 \033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "-------------------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "MacPorts 未安装，开始安装  "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "-------------------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null


    if ensure_clt_or_skip_macports; then
        macos_version=$(sw_vers -productVersion)
        major_version=${macos_version%%.*}

        license_file="/System/Library/CoreServices/Setup Assistant.app/Contents/Resources/en.lproj/OSXSoftwareLicense.rtf"
        raw_codename=$(awk -F 'macOS ' '/SOFTWARE LICENSE AGREEMENT FOR macOS/ {print $NF}' "$license_file" \
                        | sed -E 's/[[:punct:]]*$//' | sed -E 's/[0-9].*$//' | tr '[:upper:]' '[:lower:]' | xargs)
        codename_camel=$(echo "$raw_codename" | awk '{for(i=1;i<=NF;i++){printf toupper(substr($i,1,1)) substr($i,2)}}')

        latest_version=$(curl -s https://api.github.com/repos/macports/macports-base/releases/latest \
                         | sed -n 's/.*\"tag_name\": \"v\\([0-9.]*\\)\".*/\\1/p')
        [ -z "$latest_version" ] && latest_version="2.11.5"

        pkg_name="MacPorts-${latest_version}-${major_version}-${codename_camel}.pkg"
        pkg_url="https://github.com/macports/macports-base/releases/download/v${latest_version}/${pkg_name}"
        echo "准备安装 MacPorts，下载地址：$pkg_url"

        curl -L -o /tmp/macports.pkg "$pkg_url" && \
        sudo $SUDO_N_FLAG /usr/sbin/installer -pkg /tmp/macports.pkg -target / && \
        /bin/rm -f /tmp/macports.pkg
    fi

fi


echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 







# -----------------------------------------------
# 检查 5 ：TopGrade 是否安装（并更新）
# -----------------------------------------------


# 调用检查时间范围函数
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

# 判断 TopGrade 是否已安装：在 root 环境降权执行 brew list --formula
topgrade_installed=false
{
    tg_list_output=""
    if [ "$(id -u)" -eq 0 ]; then
        tg_targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        tg_list_output=$(sudo -n -E -H -u "$tg_targetUser" env PATH="/opt/homebrew/bin:/usr/local/bin:$PATH" brew list --formula 2>/dev/null || true)
    else
        tg_list_output=$(brew list --formula 2>/dev/null || true)
    fi
    if echo "$tg_list_output" | grep -q '^topgrade$'; then
        topgrade_installed=true
    fi
}

if [ "$topgrade_installed" = true ]; then

    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "\033[1;36m 更新 TopGrade 工具 \033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "更新 TopGrade 工具"                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    # 检查是否以 root 身份运行
    topgrade_update_rc=0
    if [ "$(id -u)" -eq 0 ]; then
        # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
        targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 TopGrade 自更新 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 以目标用户身份执行 HomeBrew 命令
        sudo -n -H -u "$targetUser" brew upgrade --greedy --force topgrade 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        topgrade_update_rc=${PIPESTATUS[0]}
    else
        echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 TopGrade 自更新 ... "       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        brew upgrade --greedy --force topgrade 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        topgrade_update_rc=${PIPESTATUS[0]}
    fi
    
    echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    
    # 输出 TopGrade 更新结果：成功或失败
    if [ $topgrade_update_rc -eq 0 ]; then
        # 打印绿色 [OK] 提示
        echo -e '\033[1;36m[OK] 更新 TopGrade 工具 已完成\033[0m '
        # 在日志中记录 [OK] 状态
        echo -e '[OK] 更新 TopGrade 工具 已完成' | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    else
        # 打印红色 [ERROR] 提示
        echo -e '\033[1;31m[ERROR] 更新 TopGrade 工具 失败 ❌\033[0m '
        # 在日志中记录 [ERROR] 状态
        echo -e '[ERROR] 更新 TopGrade 工具 失败 ❌' | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    fi

else

    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "\033[1;36m TopGrade 未安装，开始安装 \033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "TopGrade 未安装，开始安装"                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    # 检查是否以 root 身份运行
    topgrade_install_rc=0
    if [ "$(id -u)" -eq 0 ]; then
        # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
        targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 topgrade 安装 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 以目标用户身份执行 HomeBrew 命令
        sudo -n -H -u "$targetUser" bash -c 'brew install topgrade 2>&1'         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        topgrade_install_rc=${PIPESTATUS[0]}
    else
        echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 topgrade 安装 ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        brew install topgrade 2>&1                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        topgrade_install_rc=${PIPESTATUS[0]}
    fi
    
    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    if [ $topgrade_install_rc -eq 0 ]; then
        echo -e "✅ TopGrade 安装成功。"                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        echo -e ""                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    else
        echo -e "❌ TopGrade 安装失败。"                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    fi

fi

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 




# ------------------------------------------------
# 检查 6 ：MacUpdater 是否安装（并更新）
# ------------------------------------------------


# 调用检查时间范围函数
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

# 判断 MacUpdater 是否已安装：在 root 环境降权执行 brew list --cask
macupdater_installed=false
{
    mu_list_output=""
    if [ "$(id -u)" -eq 0 ]; then
        mu_targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        mu_list_output=$(sudo -n -E -H -u "$mu_targetUser" env PATH="/opt/homebrew/bin:/usr/local/bin:$PATH" brew list --cask 2>/dev/null || true)
    else
        mu_list_output=$(brew list --cask 2>/dev/null || true)
    fi
    if echo "$mu_list_output" | grep -q '^macupdater$'; then
        macupdater_installed=true
    fi
}

if [ "$macupdater_installed" = true ]; then
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "\033[1;36m 更新 MacUpdater 工具 \033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "更新 MacUpdater 工具"                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
    # 检查是否以 root 身份运行
    macupdater_update_rc=0
    if [ "$(id -u)" -eq 0 ]; then
        # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
        targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 MacUpdater 自更新 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 以目标用户身份执行 HomeBrew 命令，并显式传递语言配置
        sudo -n -H -u "$targetUser" env HOMEBREW_CASK_OPTS="$HOMEBREW_CASK_OPTS" brew upgrade --greedy --cask macupdater 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        macupdater_update_rc=${PIPESTATUS[0]}
    else
        echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 MacUpdater 自更新 ... "     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        env HOMEBREW_CASK_OPTS="$HOMEBREW_CASK_OPTS" brew upgrade --greedy --cask macupdater 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        macupdater_update_rc=${PIPESTATUS[0]}
    fi

    echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 输出 MacUpdater 更新结果：成功或失败
    if [ $macupdater_update_rc -eq 0 ]; then
        # 打印绿色 [OK] 提示
        echo -e '\033[1;36m[OK] 更新 MacUpdater 工具 已完成\033[0m '
        # 在日志中记录 [OK] 状态
        echo -e '[OK] 更新 MacUpdater 工具 已完成' | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    else
        # 打印红色 [ERROR] 提示
        echo -e '\033[1;31m[ERROR] 更新 MacUpdater 工具 失败 ❌\033[0m '
        # 在日志中记录 [ERROR] 状态
        echo -e '[ERROR] 更新 MacUpdater 工具 失败 ❌' | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    fi

else

    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "\033[1;36m MacUpdater 未安装，开始安装 \033[0m"
    echo -e "\033[1;36m-----------------------------------------------\033[0m" 
    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "MacUpdater 未安装，开始安装 "                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "-------------------------------------------"                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    
    # 检查是否以 root 身份运行
    macupdater_install_rc=0
    if [ "$(id -u)" -eq 0 ]; then
        # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
        targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 MacUpdater 安装 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 以目标用户身份执行 HomeBrew 命令
        # 显式传递语言配置，避免 sudo 环境丢失 HOMEBREW_CASK_OPTS
        sudo -n -H -u "$targetUser" env HOMEBREW_CASK_OPTS="$HOMEBREW_CASK_OPTS" brew install --cask macupdater 2>&1       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        macupdater_install_rc=${PIPESTATUS[0]}
    else
        echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 MacUpdater 安装 ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        env HOMEBREW_CASK_OPTS="$HOMEBREW_CASK_OPTS" brew install --cask macupdater 2>&1                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        macupdater_install_rc=${PIPESTATUS[0]}
    fi
    
    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    if [ $macupdater_install_rc -eq 0 ]; then
        echo -e "✅ MacUpdater 安装成功。"                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    else
        echo -e "❌ MacUpdater 安装失败。"                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    fi
fi

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 




# ----------------------------------
# MacOS System Update
# ----------------------------------

# 移除无效的 SoftwareUpdate_NO_INTERACTIVE 环境变量（并不被软件识别）
# export SoftwareUpdate_NO_INTERACTIVE=1

echo -e "\033[1;36m-----------------------------------------------\033[0m"  
echo -e "\033[1;36m 更新 MacOS 系统                   \033[0m"  
echo -e "\033[1;36m-----------------------------------------------\033[0m"  

echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "更新 MacOS 系统"                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 等待3秒，开始执行 
#sleep 3     

# 调用检查时间范围函数  
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE" 

# 自动执行：SoftwareUpdate （并捕获输出）   
echo -e "✓ 检测 MacOS系统 是否存在 新版本 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  

# Run the update scan and capture output (stderr included), logging it as well
# 调用 softwareupdate 扫描可用更新。
# 使用 sudo，并根据脚本以 root 运行与否附加 -n 选项，
# 防止在无人值守情况下等待密码；普通用户运行则保持交互。
MacOSSystemUpdate_output=$(sudo $SUDO_N_FLAG softwareupdate --list 2>&1)
echo -e "$MacOSSystemUpdate_output" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  
#echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  

# Check scan output for "No new software available."
if echo "$MacOSSystemUpdate_output" | grep -F -q "No new software available."; then  
    # No updates available – skip download/install, output "no update needed"
    echo -e "✓  当前没有需要安装的 MacOS 系统更新 !!!" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
else  
    # Updates are available – proceed with download (and prompt for install)
    echo -e "✓  下载 MacOS系统 更新包 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  
    # 下载所有可用更新包，但不自动安装（去除无效的 --agree-to-license 参数）
    # 使用 sudo 调用下载并根据 root 状态附加 -n 选项。
   #sudo -n softwareupdate --download --all --verbose 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

   #echo -e "✓  安装 MacOS系统 更新包 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  
   #sudo $SUDO_N_FLAG softwareupdate --install --all --force --agree-to-license --verbose  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  
   #macos_system_update_ec=${PIPESTATUS[0]}
    ## 分析更新结果并输出提示
   #if [[ $macos_system_update_ec -eq 0 ]] && ! grep -qiE "failed|error" "$LOG_FULL_LAST"; then
   #    echo "✅  更新成功 ：MacOS ${OLD_VER} -> ${TARGET_VER}  （ 请重启电脑‼️‼️ ）" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
   #else
   #    echo "❌  更新失败 ：MacOS ${OLD_VER} -> ${TARGET_VER}" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
   #fi

   #echo -e "⚠️【检测到系统更新】！！如需仅下载更新包，可手动运行：softwareupdate --download --all 。若需安装，请手动运行： softwareupdate --install --all --force --verbose " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    show_sysupdate_popup          # <<< 新增：弹 GUI 提示 
fi   

echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"    # blank line for separation  

targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"  

# 检查是否以 root 身份运行 (Check if running as root)
#if [ "$(id -u)" -eq 0 ]; then  
#else  
#fi  

echo -e "\033[1;36m[OK] MacOS 系统更新检测  已完成  \033"  
echo -e "[OK]  MacOS 系统更新检测  已完成  " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null  

echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  





# ----------------------------------
# 记录：开始时间
# ----------------------------------

# 等待3秒，开始执行
#sleep 3  

# 记录当前时间戳（到$LOG_FILE）
echo -e "-------------------------------------------------"                             | tee -a "$LOG_FILE"  > /dev/null
echo -e "开始更新 APP: $(date)"                                                         | tee -a "$LOG_FILE"  > /dev/null


# 记录当前时间戳（到$$LOG_FULL_FILE），
echo -e  ""                                                                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

echo -e "\033[1;34m-----------------------------------------------\033[0m" 
echo -e "\033[1;34m 开始更新 APP: $(date)                         \033[0m"
echo -e "\033[1;34m-----------------------------------------------\033[0m" 
echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "开始更新 APP: $(date)"                                                         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

echo -e  ""                                                                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e  ""                                                                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"




# 此后，开始升级第三方APP！！！！！！此前都是在，检测环境 和更新 升级程序本身。



# -----------------------------------------------
# 在更新操作前：备份桌启动台布局（LaunchPad）
# -----------------------------------------------

echo -e "\033[1;32m-----------------------------------------------\033[0m" 
echo -e "\033[1;32m 备份 启动台布局（LaunchPad）                    \033[0m"
echo -e "\033[1;32m-----------------------------------------------\033[0m" 

echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "备份 启动台布局（LaunchPad）"                                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null


echo -e ""                                                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

# 备份 LaunchPad 和 启动台布局

if [ "$(id -u)" -eq 0 ]; then

    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 获取启动台布局 所需的 \$targetUser 与 路径 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 获取目标普通用户（优先用 SUDO_USER，否则取当前控制台登录用户）
    targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
    targetHome=$(eval echo -e "~$targetUser")    # 目标用户的 $HOME
    USER_NAME="$targetUser"
    HOME="$targetHome"                        # 覆盖当前shell的HOME

    # 获取目标用户的 TMPDIR 路径（使用 getconf）
userTmpDir=$(sudo -n -H -u "$targetUser" getconf DARWIN_USER_TEMP_DIR)
    userTmpDir="${userTmpDir%/}"                        # 移除末尾斜杠，标准化路径

else

    echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 获取 启动台布局 所需的 \$TMPDIR \$TMPDIR ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    USER_NAME="$USER"
    userTmpDir="$TMPDIR"

fi

# 记录目标用户及其TMPDIR路径到日志
echo -e "活跃用户 = $USER_NAME " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e "用户路径 = $userTmpDir" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# USER_ID=$(basename "$(dirname "$userTmpDir")")      # 提取TMPDIR路径中的随机目录ID
# PARENT_DIR=$(find /System/Volumes/Data/private/var/folders/ -maxdepth 2 -type d -name "$USER_ID" -print -quit 2>/dev/null)
# BACKUP_PATH="$ICLOUD_PATH/BACKUP/$COMPUTER_NAME/$USER_NAME"
# BACKUP_DATE=$(date +%Y-%m-%d)
# PATH_DesktopLayout_BACKUP="$BACKUP_PATH/DesktopLayout/$BACKUP_DATE"

USER_ID=$(basename "$(dirname "$userTmpDir")")      # 提取TMPDIR路径中的随机目录ID
PARENT_DIR=$(find /System/Volumes/Data/private/var/folders/ -maxdepth 2 -type d -name "$USER_ID" -print -quit 2>/dev/null)
# 根据新的目录规则生成 BACKUP 路径。以设备标识目录（型号名称-芯片名称-序列号）为基础，并包含用户名目录。
BACKUP_BASE="$ICLOUD_PATH/BACKUP/${DEVICE_DIR}"
# 如果 BACKUP_BASE 末尾已包含用户名，则不再追加；否则追加用户名目录。
if [[ "$BACKUP_BASE" == */"$USER_NAME" ]]; then
    BACKUP_PATH="$BACKUP_BASE"
else
    BACKUP_PATH="$BACKUP_BASE/$USER_NAME"
fi
BACKUP_DATE=$(date +%Y-%m-%d)
PATH_DesktopLayout_BACKUP="$BACKUP_PATH/DesktopLayout/$BACKUP_DATE"


# LaunchPad plist 位于 Library/Preferences
PATH_DesktopLayout_plist_SOURCE="$HOME/Library/Preferences"
# LaunchPad DB 位于 PARENT_DIR/0/com.apple.dock.launchpad/db/db
PATH_DesktopLayout_db_SOURCE="$PARENT_DIR/0"

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

printf  "\033[1;34m[Info]\033[0m "
printf  "[Info] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "启动台布局 备份路径：'$PATH_DesktopLayout_BACKUP'"                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

printf  "\033[1;34m[Info]\033[0m "
printf  "[Info] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "启动台布局 恢复路径: '$PATH_DesktopLayout_db_SOURCE'"                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

mkdir -p "$PATH_DesktopLayout_BACKUP"
errorFlag=0  # 初始化错误标志

# 备份 com.apple.spaces.plist
cp -rf "$PATH_DesktopLayout_plist_SOURCE/com.apple.spaces.plist" "$PATH_DesktopLayout_BACKUP/"
if [ $? -ne 0 ]; then
    echo -e "\033[1;33m[Warn]   com.apple.spaces.plist 备份失败 ⚠️ \033[0m"
    echo -e "[Warn]   com.apple.spaces.plist 备份失败 ⚠️ " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    errorFlag=1
fi

# 备份 com.apple.dock.plist
cp -rf "$PATH_DesktopLayout_plist_SOURCE/com.apple.dock.plist" "$PATH_DesktopLayout_BACKUP/"
if [ $? -ne 0 ]; then
    echo -e "\033[1;33m[Warn]   com.apple.dock.plist 备份失败 ⚠️ \033[0m"
    echo -e "[Warn]   com.apple.dock.plist 备份失败 ⚠️ " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    errorFlag=1
fi

# 备份 LaunchPad 数据库目录
sudo $SUDO_N_FLAG cp -rf "$PATH_DesktopLayout_db_SOURCE/com.apple.dock.launchpad" "$PATH_DesktopLayout_BACKUP/"
if [ $? -ne 0 ]; then
    echo -e "\033[1;33m[Warn]   com.apple.dock.launchpad 目录备份失败 ⚠️ \033[0m"
    echo -e "[Warn]   com.apple.dock.launchpad 目录备份失败 ⚠️ " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    errorFlag=1
fi

# 设置权限（如有需要也可检查 chmod 的返回码）
cd "$PATH_DesktopLayout_BACKUP"
    # 对 LaunchPad 数据目录设置权限。若脚本以 root 身份运行，则附加
    # SUDO_N_FLAG（-n）以避免在后台执行时等待输入；若为普通用户，则不传递 -n
    sudo $SUDO_N_FLAG chmod -R 755 "./com.apple.dock.launchpad"

echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 根据 errorFlag 输出最终结果
if [ $errorFlag -eq 0 ]; then
    echo -e "\033[1;32m[OK] 备份 启动台布局  运行已完成 ✅ \033[0m"
    echo -e "[OK]   备份 启动台布局  运行已完成 ✅ " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
else
    echo -e "\033[1;33m[Warn] 备份 启动台布局  运行已完成，但部分项目失败 ⚠️ \033[0m"
    echo -e "[Warn]   启动台布局 备份完成，但部分项目失败 ⚠️ " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
fi

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 










# ----------------------------------
# 开始执行：HomeBrew
# ----------------------------------

export HOMEBREW_NO_INTERACTIVE=1

echo -e "\033[1;32m-----------------------------------------------\033[0m" 
echo -e "\033[1;32m 运行 HomeBrew                             \033[0m"
echo -e "\033[1;32m-----------------------------------------------\033[0m" 

echo -e "-------------------------------------------"                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "运行 HomeBrew"                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------"                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null


# 等待3秒，开始执行
#sleep 3  

# 调用检查时间范围函数
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

echo -e ""                                                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

printf  "\033[1;34m[List]\033[0m "
printf  "[List] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "HomeBrew 应用列表 ... "                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
#( brew upgrade --debug --verbose --greedy )

# 检查是否以 root 身份运行
if [ "$(id -u)" -eq 0 ]; then

    # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
    targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 brew list ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 4️⃣ 所有项目（公式 + Cask）
brew_formula_count=$(sudo -n -H -u "$targetUser" bash -lc 'brew list --formula -1 | wc -l' )
brew_cask_count=$(sudo -n -H -u "$targetUser" bash -lc 'brew list --cask -1 | wc -l' )

else

    echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 brew list ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    # 所有项目（公式 + Cask）
    brew_formula_count=$(brew list --formula -1 | wc -l)
    brew_cask_count=$(brew list --cask -1 | wc -l)

fi


# 计算 APP 数量（假设 brew_installed_apps 是 brew list 的正常输出）
brew_cask_count=$((( brew_cask_count * 2 ) /2 ))
brew_formula_count=$((( brew_formula_count *2 ) /2 ))
brew_app_count=$(( brew_formula_count + brew_cask_count ))
echo -e "✅  APP 数量（ HomeBrew Formula ） ：$brew_formula_count  "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e "✅  APP 数量（ HomeBrew Cask    ） ：$brew_cask_count  "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e "✅  APP 数量（ HomeBrew         ） ：$brew_app_count  "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"


echo -e ""                                                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 


printf  "\033[1;34m[Scan]\033[0m "
printf  "[Scan] "                                                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "HomeBrew 扫描更新 ... "                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

if [ "$(id -u)" -eq 0 ]; then
  targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
  echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 brew outdated --greedy ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
  brew_outdated=$(
    sudo -n -H -u "$targetUser" bash -lc 'brew outdated --greedy' 2>/dev/null | awk '{print $1}'
  )
  brew_outdated_formulas=$(
    sudo -n -H -u "$targetUser" bash -lc 'brew outdated --formula --greedy' 2>/dev/null | awk '{print $1}'
  )
  brew_outdated_casks=$(
    sudo -n -H -u "$targetUser" bash -lc 'brew outdated --cask --greedy' 2>/dev/null | awk '{print $1}'
  )
else
  echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 brew outdated --greedy ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
  brew_outdated=$(
    brew outdated --greedy 2>/dev/null | awk '{print $1}'
  )
  brew_outdated_formulas=$(
    brew outdated --formula --greedy 2>/dev/null | awk '{print $1}'
  )
  brew_outdated_casks=$(
    brew outdated --cask --greedy 2>/dev/null | awk '{print $1}'
  )
fi

# 兼容 bash 3.2：逐行构建数组（避免 read -a 只读到第一行）
packages_brew=()
while IFS= read -r pkg; do
  [[ -n "$pkg" ]] && packages_brew+=("$pkg")
done <<< "$brew_outdated"

packages_brew_formulas=()
while IFS= read -r pkg; do
  [[ -n "$pkg" ]] && packages_brew_formulas+=("$pkg")
done <<< "$brew_outdated_formulas"

packages_brew_casks=()
while IFS= read -r pkg; do
  [[ -n "$pkg" ]] && packages_brew_casks+=("$pkg")
done <<< "$brew_outdated_casks"

# 分类打印（先判定 cask，再判定 formula）
for pkg in "${packages_brew[@]}"; do
  if printf '%s\n' "${packages_brew_casks[@]}"     | grep -qxF -- "$pkg"; then
    echo -e "✔︎  检测到新版本 [cask]    : $pkg"   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
  elif printf '%s\n' "${packages_brew_formulas[@]}" | grep -qxF -- "$pkg"; then
    echo -e "✔︎  检测到新版本 [formula] : $pkg" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
  else
    echo -e "✔︎  检测到新版本 [unknown] : $pkg" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
  fi
done



# 在获取 brew_outdated 列表并组装 packages_brew_formulas/casks 之后添加：
updated_list=()   # 初始化数组，用于保存每个更新项的结果

# 如果有需要更新的 HomeBrew 软件包，则执行下载
if [ ${#packages_brew[@]} -ne 0 ]; then

    echo -e ""                                                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 第 2 步：并行下载（提高下载速度）
    printf "\033[1;34m[Download]\033[0m "
    printf "[Download] "                                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "开始下载：HomeBrew Formula / Cask（ 并行 ） ... "                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 在下载前打印 SHA256 检查信息
    if [ "$(id -u)" -eq 0 ]; then
        # root 权限需降权执行 sha256 检查
        targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        echo -e "✔︎  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 SHA256 检查 ，是否有 已缓存的安装包 ... "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    else
        # 普通用户直接运行 SHA256 检查
        echo -e "✔︎  当前用户 '$USER' 为普通权限 , 直接运行 SHA256 检查 ，是否有 已缓存的安装包 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    fi

    # 初始化缓存列表，用于后续汇总输出
    cached_formulas=()
    cached_casks=()
    # 记录每个缓存条目的详细信息（包名与 sha），供后续打印
    cached_formula_entries=()
    cached_cask_entries=()

    # 构造平台键：Apple Silicon 带前缀，Intel 不带前缀
    platform_key=""
        if [ -n "$os_name" ]; then
          if [ "$cpu_isa" = "arm64" ]; then
            platform_key="${cpu_isa}_${os_name}"   # 例如 "arm64_sonoma"
          else
            platform_key="$os_name"            # 例如 "sonoma"
          fi
        fi
        
        # 为保证并行下载环境获取正确的平台键，需将 platform_key 导出到环境中。
        # 否则在非 root 用户并行执行 fetch_brew_formula 时，platform_key 会丢失，
        # 导致 brew_expected_sha 使用错误的 fallback 值，从而出现校验码不匹配的警告。
        export platform_key



    # 筛选需要下载的 formula 软件包：如果缓存中已有完整的新版本则跳过
    packages_to_fetch_formulas=()
    for pkg_brew_formula in "${packages_brew_formulas[@]}"; do

        [[ -z "$pkg_brew_formula" ]] && continue  # 跳过空名称项（以防万一）

        #brew_cache_path=$(brew --cache --formula "$pkg_brew_formula")
        # 获取 HomeBrew 缓存包路径（在 Root 权限下通过目标用户环境获取正确路径）
        if [ "$(id -u)" -eq 0 ]; then
            targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
            brew_cache_path=$(sudo -n -H -u "$targetUser" /bin/bash -lc "brew --cache --formula \"$pkg_brew_formula\"" 2>/dev/null)
        else
            brew_cache_path=$(brew --cache --formula "$pkg_brew_formula")
        fi
        #echo -e "brew_cache_path = $brew_cache_path"                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        
        if [ -f "$brew_cache_path" ]; then
            ################################################################
            # 修正：brew --cache 可能返回 bottle_manifest.json 路径，这不是实际瓶子文件
            # manifest 与真正的 .bottle.tar.gz 文件的 SHA256 不一致，导致误判
            # 如果检测到 manifest 文件，则尝试在同目录寻找匹配包名的 .bottle*.tar.gz 文件
            ################################################################
            if [[ "$brew_cache_path" == *.bottle_manifest.json ]]; then
                cache_dir="$(dirname "$brew_cache_path")"
                # 使用通配符查找匹配的瓶子文件
                candidate=""
                for f in "$cache_dir"/*"${pkg_brew_formula}"*.bottle*.tar.gz; do
                    # 只取第一个匹配
                    candidate="$f"
                    break
                done
                if [ -n "$candidate" ] && [ -f "$candidate" ]; then
                    brew_cache_path="$candidate"
                fi
            fi
            local_sha=$(shasum -a 256 "$brew_cache_path" | awk '{print $1}')
            ############################################
            # 计算 brew_expected_sha —— 自动降权 + 双日志输出
            ############################################
            if [ "$(id -u)" -eq 0 ]; then
                # 1. 解析目标普通用户（Lingon 经 sudo 调用时 SUDO_USER 存在）
                targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"

                # 2. 日志提示
                #echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_formula 的 SHA256 查询 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

                # 3. 在目标用户登录环境中执行 brew info 获取 JSON
                json=$(sudo -n -H -u "$targetUser" /bin/bash -lc "brew info --json=v2 \"$pkg_brew_formula\"" 2>/dev/null)
            else
                # ------- 已是普通用户 -------
                #echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 $pkg_brew_formula 的 SHA256 查询 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

                # 在当前用户环境中执行 brew info 获取 JSON
                json=$(brew info --json=v2 "$pkg_brew_formula" 2>/dev/null)
            fi

            # 提取对应的 SHA256（优先当前平台的 bottle，其次通用 bottle，最后源码 checksum）
            brew_expected_sha=""
            if [ -n "$json" ]; then
                if [ -n "$platform_key" ]; then
                    brew_expected_sha=$(/usr/bin/plutil -extract "formulae.0.bottle.stable.files.${platform_key}.sha256" \
                                 raw -o - - <<< "$json" 2>/dev/null)
                fi
                if [ -z "$brew_expected_sha" ]; then
                    brew_expected_sha=$(/usr/bin/plutil -extract "formulae.0.bottle.stable.files.all.sha256" \
                                 raw -o - - <<< "$json" 2>/dev/null)
                fi
                if [ -z "$brew_expected_sha" ]; then
                    brew_expected_sha=$(/usr/bin/plutil -extract "formulae.0.urls.stable.checksum" \
                                 raw -o - - <<< "$json" 2>/dev/null)
                fi
            fi

            if [ -n "$brew_expected_sha" ] && [ "$local_sha" = "$brew_expected_sha" ]; then
                # 该 formula 已有最新缓存，记录到缓存列表和详细条目，后续汇总输出
                cached_formulas+=("$pkg_brew_formula")
                cached_formula_entries+=("$pkg_brew_formula|$brew_expected_sha")
                continue  # 略过重新下载
            else
                echo -e "⚠️  [SHA256异常] $pkg_brew_formula [formula]" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                echo -e "   -  已下载包 ：$local_sha "    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                echo -e "   -  homebrew ：$brew_expected_sha " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            fi
        fi

        packages_to_fetch_formulas+=("$pkg_brew_formula")

    done


    # 筛选需要下载的 cask 软件包：如果缓存中已有完整的新版本则跳过
    packages_to_fetch_casks=()
    for pkg_brew_cask in "${packages_brew_casks[@]}"; do

        [[ -z "$pkg_brew_cask" ]] && continue  # 跳过空名称项

        #brew_cache_path=$(brew --cache --cask "$pkg_brew_cask")
        # 获取 HomeBrew 缓存包路径（在 Root 权限下通过目标用户环境获取正确路径）
        if [ "$(id -u)" -eq 0 ]; then
            targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
            brew_cache_path=$(sudo -n -H -u "$targetUser" /bin/bash -lc "brew --cache --cask \"$pkg_brew_cask\"" 2>/dev/null)
        else
            brew_cache_path=$(brew --cache --cask "$pkg_brew_cask")
        fi
        #echo -e "brew_cache_path = $brew_cache_path"                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

        if [ -f "$brew_cache_path" ]; then
            local_sha=$(shasum -a 256 "$brew_cache_path" | awk '{print $1}')
            ############################################
            # 计算 brew_expected_sha —— 自动降权 + 双日志输出
            ############################################
            if [ "$(id -u)" -eq 0 ]; then
                # 1. 解析目标普通用户（Lingon 经 sudo 调用时 SUDO_USER 存在）
                targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"

                # 2. 日志提示
                #echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_cask 的 SHA256 查询 ... "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

                # 3. 在目标用户登录环境中执行 brew info 获取 JSON
                json=$(sudo -n -H -u "$targetUser" /bin/bash -lc "brew info --json=v2 \"$pkg_brew_cask\"" 2>/dev/null)
            else
                # ------- 已是普通用户 -------
                #echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 $pkg_brew_cask 的 SHA256 查询 ... "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

                # 在当前用户环境中执行 brew info 获取 JSON
                json=$(brew info --json=v2 "$pkg_brew_cask" 2>/dev/null)
            fi

            # 提取 cask 的 SHA256（某些 cask 可能无 SHA 信息，例如 :latest 或 auto_updates）
            brew_expected_sha=""
            if [ -n "$json" ]; then
                brew_expected_sha=$(/usr/bin/plutil -extract "casks.0.sha256" raw -o - - <<< "$json" 2>/dev/null)
            fi

            # 处理 cask 的 SHA256: 如果为 null/no_check 或为空，则认为无需校验并视为已缓存
            if [[ "$brew_expected_sha" == "null" || -z "$brew_expected_sha" || "$brew_expected_sha" == "no_check" ]]; then
                cached_casks+=("$pkg_brew_cask")
                # 保存详细信息标记为 no_check
                cached_cask_entries+=("$pkg_brew_cask|no_check")
                continue
            fi
            if [ "$local_sha" = "$brew_expected_sha" ]; then
                # cask 已有最新缓存，记录到缓存列表
                cached_casks+=("$pkg_brew_cask")
                cached_cask_entries+=("$pkg_brew_cask|$brew_expected_sha")
                continue
            fi
        fi

        packages_to_fetch_casks+=("$pkg_brew_cask")

    done


    # 根据缓存列表打印缓存摘要。如果存在缓存条目则打印详细信息；否则提示无缓存。
    if [ ${#cached_formula_entries[@]} -eq 0 ] && [ ${#cached_cask_entries[@]} -eq 0 ]; then
        echo -e "✔︎  无缓存的安装包" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    else
        # 打印 formula 缓存详细信息
        for entry in "${cached_formula_entries[@]}"; do
            # 分割 entry 为 pkg 和 sha，两部分之间以第一个竖线分隔
            pkg="${entry%%|*}"
            sha="${entry#*|}"
            echo -e "✅  [已缓存] 最新版 ｜ SHA256 ：$sha ｜ [formula] ：$pkg  " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        done
        # 打印 cask 缓存详细信息
        for entry in "${cached_cask_entries[@]}"; do
            # 分割 entry 为 pkg 和 sha，两部分之间以第一个竖线分隔
            pkg="${entry%%|*}"
            sha="${entry#*|}"
            # 如果 sha 标记为 no_check 或为空，则打印无校验版
            if [ "$sha" = "no_check" ] || [ -z "$sha" ] || [ "$sha" = "null" ]; then
                echo -e "✅  [已缓存] 无校验版 ｜ [cask] ：：$pkg " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            else
                echo -e "✅  [已缓存] 最新版 ｜ SHA256 ：$sha ｜    [cask] ：$pkg  " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            fi
        done
    fi
    # 输出分隔线，表示缓存检查结束
   #echo -e "------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 输出并行下载提示信息，根据身份决定降权或直接运行
    if [ "$(id -u)" -eq 0 ]; then
        targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 并行下载（parallel download）安装包  ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    else
        echo -e "✓  当前用户 '$USER' 为普通权限 , 直接运行 并行下载（parallel download）安装包  ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    fi



    # 并行下载需要更新的 formula 和 cask（使用 --retry 自动校验缓存有效性） 注意，与 下面的 parallel 方案 二选一。建议使用Parallel，因为速度更快。
    # printf '%s\n' "${packages_to_fetch_formulas[@]}" | xargs -n1 -P16 brew fetch --formula --retry         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # printf '%s\n' "${packages_to_fetch_casks[@]}"    | xargs -n1 -P8 brew fetch --cask --retry             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 确保 GNU Parallel 已安装（macOS 可通过 HomeBrew 安装）
    if ! command -v parallel &>/dev/null; then

          # 安装 GNU Parallel 并行执行工具 [oai_citation:3‡formulae.brew.sh](https://formulae.brew.sh/formula/parallel#:~:text=Install%20command%3A)
          # 检查是否以 root 身份运行
          if [ "$(id -u)" -eq 0 ]; then
              # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
              targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
              echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 parallel 安装 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
              # 以目标用户身份执行 HomeBrew 命令
              sudo -n -H -u "$targetUser" bash -c 'brew install parallel 2>&1'         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
          else
              echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 parallel 安装 ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
              brew install parallel 2>&1                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
          fi

    fi

    # run_as_normal_user 和 maybe_run_as_normal_user 的定义已移动到脚本的顶层，避免在使用前未定义。
    export LOG_FULL_LAST LOG_FULL_FILE   # 让 sudo -E 能继承日志路径

    # -----------------------------------------------------------------------------
    # 新增：定义下载函数用于并行下载 formula 和 cask，支持重试并记录失败链接
    #
    # 这两个函数会被 GNU parallel 调用以下载对应的软件包。当下载失败时，会按
    # DOWNLOAD_MAX_RETRIES 指定的次数进行重试，并在最终失败时把包名和
    # 下载链接追加写入失败记录文件，供后续安装阶段判断是否跳过升级。
    fetch_brew_formula() {
        local pkg="$1"
        local success=0
        local tmpfile
        tmpfile=$(mktemp)
        # 下载失败重试次数与校验失败重试次数
        local max_download_retry=${DOWNLOAD_MAX_RETRIES:-5}
        local max_sha_retry=${SHA_MISMATCH_MAX_RETRIES:-1}
        local download_attempt=0
        local sha_attempt=0
        # 循环尝试：根据错误类型分别重试
        while true; do
            download_attempt=$((download_attempt + 1))
            # 在首次下载与重试之间增加头部提示，便于区分本次尝试是初次还是重试
            if [ "$download_attempt" -eq 1 ]; then
                # 第一次下载
                echo -e "✔︎  开始下载 [formula] ：$pkg" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            else
                # 重试下载
                echo -e "✔︎  重试中   [formula] ：$pkg" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            fi
            # 调用 brew fetch 下载 formula，去重输出并过滤掉 Bottle Manifest 行，仅保留实际瓶子下载信息
            brew fetch --formula --retry "$pkg" 2>&1 \
                | awk '!seen[$0]++' \
                | grep -v 'Bottle Manifest' \
                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" \
                | tee "$tmpfile" >/dev/null
            fetch_exit=${PIPESTATUS[0]}
            if [ $fetch_exit -ne 0 ]; then
                # 下载失败
                if [ $download_attempt -lt $max_download_retry ]; then
                    sleep 1
                    continue
                else
                    # 达到下载重试上限
                    success=0
                    break
                fi
            fi
            # 下载成功后，校验 SHA
            local brew_cache_path=""
            local brew_expected_sha=""
            local registry_sha=""
            local json=""
            if [ "$(id -u)" -eq 0 ]; then
                local targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
                brew_cache_path=$(sudo -n -H -u "$targetUser" /bin/bash -lc "brew --cache --formula \"$pkg\"" 2>/dev/null)
                json=$(sudo -n -H -u "$targetUser" /bin/bash -lc "brew info --json=v2 \"$pkg\"" 2>/dev/null)
            else
                brew_cache_path=$(brew --cache --formula "$pkg")
                json=$(brew info --json=v2 "$pkg" 2>/dev/null)
            fi
            if [ -n "$brew_cache_path" ] && [ -f "$brew_cache_path" ]; then
                ################################################################
                # 修正：brew --cache 可能返回的是 bottle_manifest.json 文件
                # manifest 的 SHA 与真正的瓶子文件不同，需查找对应的 .bottle*.tar.gz
                ################################################################
                if [[ "$brew_cache_path" == *.bottle_manifest.json ]]; then
                    cache_dir="$(dirname "$brew_cache_path")"
                    candidate=""
                    for f in "$cache_dir"/*"${pkg}"*.bottle*.tar.gz; do
                        candidate="$f"
                        break
                    done
                    if [ -n "$candidate" ] && [ -f "$candidate" ]; then
                        brew_cache_path="$candidate"
                    fi
                fi
                local local_sha
                local_sha=$(shasum -a 256 "$brew_cache_path" | awk '{print $1}')
                # 解析 brew_expected_sha 来自 formula JSON
                if [ -n "$json" ]; then
                    if [ -n "$platform_key" ]; then
                        brew_expected_sha=$(/usr/bin/plutil -extract "formulae.0.bottle.stable.files.${platform_key}.sha256" raw -o - - <<< "$json" 2>/dev/null || true)
                    fi
                    if [ -z "$brew_expected_sha" ]; then
                        brew_expected_sha=$(/usr/bin/plutil -extract "formulae.0.bottle.stable.files.all.sha256" raw -o - - <<< "$json" 2>/dev/null || true)
                    fi
                    if [ -z "$brew_expected_sha" ]; then
                        brew_expected_sha=$(/usr/bin/plutil -extract "formulae.0.urls.stable.checksum" raw -o - - <<< "$json" 2>/dev/null || true)
                    fi
                fi
                # 从 brew fetch 输出中获取 GHCR blob 的 sha256 digest
                registry_sha=$(grep -oE 'blobs/sha256:[0-9a-f]+' "$tmpfile" | tail -n1 | sed 's/.*blobs\/sha256://')
                # -------- 校验逻辑 --------
                # 1) JSON 命中且一致 → 成功
                if [ -n "$brew_expected_sha" ] && [ "$local_sha" = "$brew_expected_sha" ]; then
                    success=1
                    break
                fi
                # 2) 如果 registry sha 存在且一致 → 成功（JSON 可能延迟）
                if [ -n "$registry_sha" ] && [ "$local_sha" = "$registry_sha" ]; then
                    echo -e "[INFO] $pkg 校验通过（使用 registry 校验；formula API 可能延迟）" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    success=1
                    break
                fi
                # 3) 若二者均不匹配，重试或报警
                sha_attempt=$((sha_attempt + 1))
                if [ $sha_attempt -lt $max_sha_retry ]; then
                    rm -f "$brew_cache_path"
                    sleep 1
                    continue
                fi
                # 三方值输出，供排查
                [ -z "$brew_expected_sha" ] && brew_expected_sha="(未获取)"
                [ -z "$registry_sha" ] && registry_sha="(未获取)"
                echo -e "      expected(formula)=$brew_expected_sha" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                echo -e "      expected(registry)=$registry_sha"     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                echo -e "      local=$local_sha"                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                success=2
                break
            else
                success=1
                break
            fi
        done
        # 根据成功与否记录结果：成功(1/2)则写入成功文件，其余视为失败
        if [ "$success" -eq 1 ] || [ "$success" -eq 2 ]; then
            # 成功下载 formula，将包名记录到成功文件。此处不输出成功信息，由汇总阶段统一处理
            echo "$pkg" >> "$SUCCESS_FETCH_FORMULAS_FILE"
        else
            echo -e "❌  下载失败 [formula] ：$pkg " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            # 提取最后出现的 URL（若无则为空）
            # 在提取下载链接前确认临时文件存在，避免 grep 对已删除文件报错
            if [[ -f "$tmpfile" ]]; then
                url=$(grep -oE 'https?://[^[:space:]]+' "$tmpfile" 2>/dev/null | tail -n1 || true)
            else
                url=""
            fi
            echo "$pkg|$url" >> "$FAILED_FETCH_FORMULAS_FILE"
        fi
        rm -f "$tmpfile"
    }
    export -f fetch_brew_formula

    fetch_brew_cask() {
        local pkg="$1"
        local success=0
        local tmpfile
        # 提前声明用于跨迭代的校验码变量
        local local_sha=""
        local brew_expected_sha=""
        tmpfile=$(mktemp)
        # 下载失败重试次数与校验失败重试次数
        local max_download_retry=${DOWNLOAD_MAX_RETRIES:-5}
        local max_sha_retry=${SHA_MISMATCH_MAX_RETRIES:-1}
        local download_attempt=0
        local sha_attempt=0
        while true; do
            download_attempt=$((download_attempt + 1))
            # 调用 brew fetch 下载 cask 时不再传递 --language 选项。
            # brew fetch 不支持 --language，同时如果通过 HOMEBREW_CASK_OPTS 传入语言选项
            # 会导致 "invalid option: --language" 错误。为避免此问题，在下载阶段显式
            # 清空 HOMEBREW_CASK_OPTS 环境变量，保证 brew fetch 只接受必要参数。
            # 在首次下载与重试之间增加头部提示
            if [ "$download_attempt" -eq 1 ]; then
                echo -e "✔︎  开始下载 [cask]    ：$pkg" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            else
                echo -e "✔︎  重试中   [cask]    ：$pkg" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            fi
            # 调用 brew fetch 下载 cask，去重输出并过滤 Bottle Manifest 行
            env HOMEBREW_CASK_OPTS="" brew fetch --cask --retry "$pkg" 2>&1 \
                | awk '!seen[$0]++' \
                | grep -v 'Bottle Manifest' \
                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" \
                | tee "$tmpfile" >/dev/null
            fetch_exit=${PIPESTATUS[0]}
            if [ $fetch_exit -ne 0 ]; then
                if [ $download_attempt -lt $max_download_retry ]; then
                    sleep 1
                    continue
                else
                    success=0
                    break
                fi
            fi
            # 下载成功后校验 SHA
            local brew_cache_path=""
            # brew_expected_sha 在循环外已声明，用于记录上一次迭代的期望值
            local json=""
            if [ "$(id -u)" -eq 0 ]; then
                local targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
                brew_cache_path=$(sudo -n -H -u "$targetUser" /bin/bash -lc "brew --cache --cask \"$pkg\"" 2>/dev/null)
                json=$(sudo -n -H -u "$targetUser" /bin/bash -lc "brew info --json=v2 \"$pkg\"" 2>/dev/null)
            else
                brew_cache_path=$(brew --cache --cask "$pkg")
                json=$(brew info --json=v2 "$pkg" 2>/dev/null)
            fi
            if [ -n "$brew_cache_path" ] && [ -f "$brew_cache_path" ]; then
                local_sha=$(shasum -a 256 "$brew_cache_path" | awk '{print $1}')
                if [ -n "$json" ]; then
                    brew_expected_sha=$(/usr/bin/plutil -extract "casks.0.sha256" raw -o - - <<< "$json" 2>/dev/null)
                fi
                # 如果期望校验码为 null/no_check，则认为无需校验并视为成功
                if [[ -n "$brew_expected_sha" && "$brew_expected_sha" != "null" && "$brew_expected_sha" != "no_check" && "$local_sha" != "$brew_expected_sha" ]]; then
                    sha_attempt=$((sha_attempt + 1))
                    if [ $sha_attempt -lt $max_sha_retry ]; then
                        rm -f "$brew_cache_path"
                        sleep 1
                        continue
                    fi
                    success=2
                    break
                else
                    success=1
                    break
                fi
            else
                success=1
                break
            fi
        done
        # 根据成功与否记录结果：成功(1/2)则写入成功文件，其余视为失败
        if [ "$success" -eq 1 ] || [ "$success" -eq 2 ]; then
            # 成功下载 cask，将包名记录到成功文件。此处不输出成功信息，由汇总阶段统一处理
            echo "$pkg" >> "$SUCCESS_FETCH_CASKS_FILE"
        else
            echo -e "❌  下载失败 [cask] ：$pkg " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            # 在提取下载链接前确认临时文件存在，避免 grep 对已删除文件报错
            if [[ -f "$tmpfile" ]]; then
                url=$(grep -oE 'https?://[^[:space:]]+' "$tmpfile" 2>/dev/null | tail -n1 || true)
            else
                url=""
            fi
            echo "$pkg|$url" >> "$FAILED_FETCH_CASKS_FILE"
        fi
        rm -f "$tmpfile"
    }
    export -f fetch_brew_cask
    # -----------------------------------------------------------------------------


    # ---------------- ① 并行下载 formula/cask ----------------
    # 采用临时函数文件配合 GNU parallel 的 :::: 文件输入方式。在 root 环境下通过 run_as_normal_user 调用 parallel，避免 sudo 环境丢失函数定义。
    total_formula_count=${#packages_to_fetch_formulas[@]}
    total_cask_count=${#packages_to_fetch_casks[@]}
    if [ $total_formula_count -gt 0 ] || [ $total_cask_count -gt 0 ]; then
      # 将下载函数定义写入临时文件
      # 在 /tmp 下创建函数定义文件，避免目录权限限制导致普通用户无法读取
      functions_file=$(mktemp "/tmp/brew_functions.XXXXXX")
      {
        # 为并行下载注入必要的函数定义，同时定义 platform_key 变量供函数使用
        # platform_key 已在前文计算（如 arm64_sonoma）
        echo "platform_key='${platform_key}'"
        declare -f fetch_brew_formula
        declare -f fetch_brew_cask
      } > "$functions_file"
      # 默认 mktemp 创建的文件权限为 600（仅 root 可读），在 root 模式下需要让普通用户可以读取
      chmod 644 "$functions_file"
      # 如果存在 formula 或 cask 需要下载，准备文件列表
      if [ $total_formula_count -gt 0 ]; then
        formula_list_file=$(mktemp)
        printf '%s\n' "${packages_to_fetch_formulas[@]}" > "$formula_list_file"
      fi
      if [ $total_cask_count -gt 0 ]; then
        cask_list_file=$(mktemp)
        printf '%s\n' "${packages_to_fetch_casks[@]}" > "$cask_list_file"
      fi
      # 根据是否 root 选择执行方式
      if [ "$(id -u)" -eq 0 ]; then
        # 在 root 模式下，使用 xargs + run_as_normal_user 执行并行下载。为每个软件包生成一个小脚本，在脚本内部调用
        # run_as_normal_user 将下载函数在普通用户环境下执行。这样可以避免 sudo 在并行环境下的复杂权限问题。
        if [ $total_formula_count -gt 0 ]; then
          # 创建临时脚本用于 formula 下载
          xargs_formula_script=$(mktemp "/tmp/brew_xargs_formula.XXXXXX")
          cat > "$xargs_formula_script" <<'EOF'
#!/bin/bash
pkg="$1"
functions_file="$2"
# 调用 run_as_normal_user 将下载函数在普通用户环境下执行
run_as_normal_user bash -lc "source \"${functions_file}\"; fetch_brew_formula \"${pkg}\""
EOF
          chmod +x "$xargs_formula_script"
          # 使用 xargs 在 root 环境下并行运行脚本。传入包名和函数文件路径
          printf '%s\n' "${packages_to_fetch_formulas[@]}" | xargs -n1 -P"$PARALLEL_JOBS" -I {} bash "$xargs_formula_script" "{}" "$functions_file"
          rm -f "$xargs_formula_script"
        fi
        if [ $total_cask_count -gt 0 ]; then
          xargs_cask_script=$(mktemp "/tmp/brew_xargs_cask.XXXXXX")
          cat > "$xargs_cask_script" <<'EOF'
#!/bin/bash
pkg="$1"
functions_file="$2"
run_as_normal_user bash -lc "source \"${functions_file}\"; fetch_brew_cask \"${pkg}\""
EOF
          chmod +x "$xargs_cask_script"
          printf '%s\n' "${packages_to_fetch_casks[@]}" | xargs -n1 -P"$PARALLEL_JOBS" -I {} bash "$xargs_cask_script" "{}" "$functions_file"
          rm -f "$xargs_cask_script"
        fi
      else
        # 非 root 时，不使用临时函数文件，直接调用导出的函数进行并行下载。
        # fetch_brew_formula 与 fetch_brew_cask 已在前文通过 export -f 导出，可直接供 GNU parallel 调用。
        if [ $total_formula_count -gt 0 ]; then
          "$PARALLEL_BIN" --will-cite --line-buffer --unsafe -j"$PARALLEL_JOBS" fetch_brew_formula ::: "${packages_to_fetch_formulas[@]}"
        fi
        if [ $total_cask_count -gt 0 ]; then
          "$PARALLEL_BIN" --will-cite --line-buffer --unsafe -j"$PARALLEL_JOBS" fetch_brew_cask ::: "${packages_to_fetch_casks[@]}"
        fi
      fi
      # 清理临时文件
      rm -f "$functions_file"
      # 使用参数展开的默认值以避免 set -u 下未定义变量导致报错
      [ -n "${formula_list_file:-}" ] && rm -f "$formula_list_file"
      [ -n "${cask_list_file:-}" ] && rm -f "$cask_list_file"
    fi

    # 下载阶段结束后，汇总成功与失败的数量并高亮输出
    if [ $total_formula_count -gt 0 ] || [ $total_cask_count -gt 0 ]; then
        # 统计失败的数量（文件按行记录失败的软件名|url），不存在文件则视为 0
        failed_formula=0
        failed_cask=0
        if [ -n "$FAILED_FETCH_FORMULAS_FILE" ] && [ -f "$FAILED_FETCH_FORMULAS_FILE" ]; then
            failed_formula=$(wc -l < "$FAILED_FETCH_FORMULAS_FILE" 2>/dev/null || echo 0)
        fi
        if [ -n "$FAILED_FETCH_CASKS_FILE" ] && [ -f "$FAILED_FETCH_CASKS_FILE" ]; then
            failed_cask=$(wc -l < "$FAILED_FETCH_CASKS_FILE" 2>/dev/null || echo 0)
        fi
        # 根据成功记录文件统计成功数量和列表
        success_formula=0
        success_cask=0
        success_formulas_list=()
        success_casks_list=()
        if [ -f "$SUCCESS_FETCH_FORMULAS_FILE" ]; then
            while IFS= read -r _pkg; do
                [ -n "$_pkg" ] && success_formulas_list+=("$_pkg")
            done < "$SUCCESS_FETCH_FORMULAS_FILE"
            success_formula=${#success_formulas_list[@]}
        fi
        if [ -f "$SUCCESS_FETCH_CASKS_FILE" ]; then
            while IFS= read -r _pkg; do
                [ -n "$_pkg" ] && success_casks_list+=("$_pkg")
            done < "$SUCCESS_FETCH_CASKS_FILE"
            success_cask=${#success_casks_list[@]}
        fi
        # 计算失败计数（已在前面计算），计算未知（未成功也未失败）列表
        unknown_formulas=()
        unknown_casks=()
        for pkg in "${packages_to_fetch_formulas[@]}"; do
            # 跳过空包名
            [ -z "$pkg" ] && continue
            # 若在成功列表，则跳过
            if printf '%s\n' "${success_formulas_list[@]}" | grep -q "^$pkg$"; then
                continue
            fi
            # 若在失败文件中，则跳过（该情况会在下方失败列表中显示）
            if [ -f "$FAILED_FETCH_FORMULAS_FILE" ] && grep -q "^$pkg|" "$FAILED_FETCH_FORMULAS_FILE"; then
                continue
            fi
            # 既未成功也未明确失败，视为未知
            unknown_formulas+=("$pkg")
        done
        for pkg in "${packages_to_fetch_casks[@]}"; do
            [ -z "$pkg" ] && continue
            if printf '%s\n' "${success_casks_list[@]}" | grep -q "^$pkg$"; then
                continue
            fi
            if [ -f "$FAILED_FETCH_CASKS_FILE" ] && grep -q "^$pkg|" "$FAILED_FETCH_CASKS_FILE"; then
                continue
            fi
            unknown_casks+=("$pkg")
        done
       ## 如果存在成功的包，则打印成功列表；否则仍然打印一条分隔线，以便后续统计与下载提示之间有隔断
       #if [ ${#success_formulas_list[@]} -gt 0 ] || [ ${#success_casks_list[@]} -gt 0 ]; then
       #    for pkg in "${success_formulas_list[@]}"; do
       #        echo -e "✔︎  下载成功 [formula] : $pkg " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
       #    done
       #    for pkg in "${success_casks_list[@]}"; do
       #        echo -e "✔︎  下载成功 [cask]    : $pkg " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
       #    done
       #fi
        #echo -e "------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 打印成功统计
        echo -e "✔︎  下载成功 [formula] : $success_formula/$total_formula_count" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        echo -e "✔︎  下载成功 [cask]    : $success_cask/$total_cask_count" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 输出失败软件列表 [WARNING]
        if [ "$failed_formula" -gt 0 ]; then
            formula_fail_list=$(cut -d'|' -f1 < "$FAILED_FETCH_FORMULAS_FILE" | xargs)
            echo -e "✘  未完成的 formula 列表：$formula_fail_list" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        fi
        if [ "$failed_cask" -gt 0 ]; then
            cask_fail_list=$(cut -d'|' -f1 < "$FAILED_FETCH_CASKS_FILE" | xargs)
            echo -e "✘  未完成的 cask    列表：$cask_fail_list" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        fi
        # 输出未知软件列表 [WARNING]
        if [ ${#unknown_formulas[@]} -gt 0 ]; then
            echo -e "✘  未完成（未知状态）的 formula 列表：${unknown_formulas[*]}" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        fi
        if [ ${#unknown_casks[@]} -gt 0 ]; then
            echo -e "✘  未完成（未知状态）的 cask    列表：${unknown_casks[*]}" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        fi
    else
        # 如果没有任何下载任务，则输出“所有下载已全部完成”并统计扫描包数量
        echo -e "✓  所有下载已全部完成" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
       #echo -e "------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 计算扫描到的 formula/cask 数量，用于展示安装包统计
        scanned_formula_count=0
        scanned_cask_count=0
        if [ -n "${packages_brew_formulas[*]}" ]; then
            for pkg in "${packages_brew_formulas[@]}"; do
                [ -n "$pkg" ] && scanned_formula_count=$((scanned_formula_count+1))
            done
        fi
        if [ -n "${packages_brew_casks[*]}" ]; then
            for pkg in "${packages_brew_casks[@]}"; do
                [ -n "$pkg" ] && scanned_cask_count=$((scanned_cask_count+1))
            done
        fi
        # 输出安装包统计 [INFO]
        echo -e "✓  安装包 [formula] ：$scanned_formula_count/$scanned_formula_count" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        echo -e "✓  安装包 [cask]    ：$scanned_cask_count/$scanned_cask_count" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    fi

    # echo -e "✅ 所有下载任务 已完成/已退出"                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

    # brew doctor  2>&1                                                                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # exit 1                                                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"          # 用于调试 ！！



    brew_formula_upgrade_exit=false
    brew_formula_reinstall_exit=false
    brew_formula_reinstall_force_exit=false

    # 第 3 步：串行安装（HomeBrew Formula）
    if [ ${#packages_brew_formulas[@]} -ne 0 ] ; then
        echo -e ""                                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        printf "\033[1;34m[Install]\033[0m "
        printf "[Install] "                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "开始更新：HomeBrew Formula（ 串行 ） ... "                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

        # 循环逐个处理每个过期的 HomeBrew Formula
        for pkg_brew_formula in "${packages_brew_formulas[@]}"; do

            # 如果在并行下载阶段检测到该 formula 下载失败，则直接跳过升级
            if [[ -n "$FAILED_FETCH_FORMULAS_FILE" && -f "$FAILED_FETCH_FORMULAS_FILE" ]]; then
                fail_line=$(grep -F "${pkg_brew_formula}|" "$FAILED_FETCH_FORMULAS_FILE" || true)
                if [[ -n "$fail_line" ]]; then
                    fail_url=$(echo "$fail_line" | cut -d'|' -f2-)
                    echo -e "❌  更新失败 [formula] : $pkg_brew_formula (下载失败：$fail_url)" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    updated_list+=("failure|formula|$pkg_brew_formula|fetch_failed:$fail_url")
                   #echo -e "--------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    continue
                fi
            fi

            brew_formula_tmpfile=$(mktemp)

            # ---------- 尝试升级 ----------
            # 检查是否以 root 身份运行
            if [ "$(id -u)" -eq 0 ]; then
                # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
                targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
                echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_formula 升级 ( brew upgrade $pkg_brew_formula --verbose --debug ) ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
                # 以目标用户身份执行 HomeBrew 命令
                sudo -n -H -u "$targetUser" bash -c "brew upgrade $pkg_brew_formula 2>&1" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$brew_formula_tmpfile"
            else
                echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 $pkg_brew_formula 升级 ( brew upgrade $pkg_brew_formula --verbose --debug ) ... "                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
                brew upgrade "$pkg_brew_formula" 2>&1                                                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$brew_formula_tmpfile" 
            fi

            brew_formula_upgrade_exit=${PIPESTATUS[0]}        # 取 brew upgrade 的退出码
            brew_formula_final_exit=$brew_formula_upgrade_exit             # 先假定最终状态 = 升级状态
            brew_formula_relink_exit=false

            # ---------- 新增：SHA-256 校验失败检测 ----------
            # 如果此次升级失败且输出中含有 SHA-256 mismatch，则提取期望和实际校验码并停止后续尝试
            # 允许用户通过 SHA_MISMATCH_MAX_RETRIES 配置尝试次数（默认为 1）
            if [ "$brew_formula_upgrade_exit" -ne 0 ]; then
                # 查找关键字（兼容大小写）。在访问临时文件前先确认其存在，
                # 避免在文件已被删除的情况下触发 “grep: No such file or directory” 错误。
                if [[ -f "$brew_formula_tmpfile" ]] && grep -qiE 'sha[- ]?256 mismatch' "$brew_formula_tmpfile"; then
                    # 抽取期望和实际校验码（若有）。同样在读取前检查文件是否仍存在。
                    if [[ -f "$brew_formula_tmpfile" ]]; then
                        sha_expected=$(grep -i 'Expected:' "$brew_formula_tmpfile" | head -n1 | sed -E 's/.*Expected:[[:space:]]*//I')
                        sha_actual=$(grep -i 'Actual:' "$brew_formula_tmpfile" | head -n1 | sed -E 's/.*Actual:[[:space:]]*//I')
                    else
                        sha_expected=""
                        sha_actual=""
                    fi
                    # 输出警告并停止重试
                    echo -e "⚠️  检测到 SHA-256 校验失败 [formula] $pkg_brew_formula ，停止后续尝试。实际校验码: ${sha_actual:-未知} ，期望校验码: ${sha_expected:-未知}" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    # 记录失败状态，方法为 sha256_mismatch:actual:expected
                    updated_list+=("failure|formula|$pkg_brew_formula|sha256_mismatch:${sha_actual:-unknown}:${sha_expected:-unknown}")
                   #echo -e "--------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    rm -f "$brew_formula_tmpfile"
                    continue   # 跳过后续链接或重装步骤
                fi
            fi

            # ---------- 若升级失败则尝试重装 ----------
            if [ $brew_formula_upgrade_exit -ne 0 ] ; then

                # 第二次尝试升级：通过 brew link 修复 formula APP 链接 （检查输出中是否包含符号链接冲突提示）
                # 先确认临时文件存在，再检查符号链接冲突提示。这样可以避免因文件
                # 被提前删除而触发 grep 的错误信息。
                if [[ -f "$brew_formula_tmpfile" ]] && { grep -q "not symlinked" "$brew_formula_tmpfile" || grep -q "Could not symlink" "$brew_formula_tmpfile"; }; then

                    echo "⚠️ 检测到 $pkg_brew_formula 升级后，符号链接冲突，尝试执行 'brew link --overwrite $pkg_brew_formula' ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    # 检查是否以 root 身份运行
                    if [ "$(id -u)" -eq 0 ]; then
                        # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
                        targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
                        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_formula 重装 ( brew link --overwrite $pkg_brew_formula )  ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        # 以目标用户身份执行 HomeBrew 命令
                        sudo -n -H -u "$targetUser" bash -c "brew link --overwrite $pkg_brew_formula 2>&1"                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    else
                        echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 $pkg_brew_formula 重装 ( brew link --overwrite $pkg_brew_formula ) ... "                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        brew link --overwrite "$pkg_brew_formula" 2>&1                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    fi

                    #brew link --overwrite "$pkg_brew_formula" 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    brew_formula_relink_exit=${PIPESTATUS[0]} 

                    # ---------- 根据最终状态输出结果 ----------
                    if [ $brew_formula_relink_exit -eq 0 ]; then
                        echo "✅  更新成功 [formula] ：$pkg_brew_formula ( 已更新 & 符号链接 ) " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        # 记录成功状态（将$pkg_brew_formula加入成功列表），并跳过后续的重装尝试
                        if [ $brew_formula_upgrade_exit -ne 0 ]; then
                            if [ $brew_formula_relink_exit -eq 0 ]; then
                                brew_formula_method="relink"
                            fi
                        else
                            brew_formula_method="upgrade"
                        fi     
                        #updated_list+=("success|formula|$pkg_brew_formula|$brew_formula_method")
                        if [ $brew_formula_final_exit -eq 0 ] ; then
                            updated_list+=("success|formula|$pkg_brew_formula|$brew_formula_method")
                        else
                            updated_list+=("failure|formula|$pkg_brew_formula|$brew_formula_method")
                        fi
                       #echo -e "--------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        if [ "${DEBUG_SCRIPT:-false}" = true ]; then
                            echo -e "[DEBUG] Removing brew_formula_tmpfile (relink): $brew_formula_tmpfile" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        fi
                        rm -f "$brew_formula_tmpfile"
                        continue   # 进入下一个 formula 处理
                    else
                        echo -e "⚠️  符号链接 失败 [formula] $pkg_brew_formula ，继续尝试 重新安装 ( brew reinstall $pkg_brew_formula --verbose --debug ) ... "                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    fi

                    # 若强制链接仍失败，下面会继续执行重装逻辑
                fi

                # 第三次尝试升级：通过 brew reinstall  升级 formula APP
                echo -e "⚠️ upgrade 失败，尝试 重装 ( brew reinstall $pkg_brew_formula --verbose --debug ) ... "                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                # 检查是否以 root 身份运行
                if [ "$(id -u)" -eq 0 ]; then
                    # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
                    targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
                    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_formula 重装 ( brew reinstall $pkg_brew_formula --verbose --debug )  ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    # 以目标用户身份执行 HomeBrew 命令
                    sudo -n -H -u "$targetUser" bash -c "brew reinstall $pkg_brew_formula 2>&1"                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                else
                    echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 $pkg_brew_formula 重装 ( brew reinstall $pkg_brew_formula --verbose --debug ) ... "                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    brew reinstall "$pkg_brew_formula" 2>&1                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                fi

                brew_formula_reinstall_exit=${PIPESTATUS[0]}  # 取 brew reinstall 的退出码
                brew_formula_final_exit=$brew_formula_reinstall_exit

                # 第四次尝试升级：通过 brew reinstall --force 升级 formula APP
                if [ $brew_formula_reinstall_exit -ne 0 ]; then
                    echo -e "⚠️ reinstall 失败，尝试 强制重装 ( brew reinstall --force $pkg_brew_formula --verbose --debug ) ... "                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    # 检查是否以 root 身份运行
                    if [ "$(id -u)" -eq 0 ]; then
                        # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
                        targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
                        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_formula 强制重装 ( brew reinstall --force $pkg_brew_formula --verbose --debug )  ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        # 以目标用户身份执行 HomeBrew 命令
                        sudo -n -H -u "$targetUser" bash -c "brew reinstall --force $pkg_brew_formula 2>&1"                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    else
                        echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 $pkg_brew_formula 强制重装 ( brew reinstall --force $pkg_brew_formula --verbose --debug ) ... "                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        brew reinstall --force "$pkg_brew_formula" 2>&1                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    fi
                    brew_formula_reinstall_force_exit=${PIPESTATUS[0]}  # 取 brew reinstall 的退出码
                    brew_formula_final_exit=$brew_formula_reinstall_force_exit
                fi
            fi

            # ---------- 根据最终状态输出结果 ----------
            if [ $brew_formula_final_exit -eq 0 ] ; then
                echo -e "✅  更新成功 [formula] ：$pkg_brew_formula "                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            else
                echo -e "❌  更新失败 [formula] ：$pkg_brew_formula "                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            fi

            #brew_formula_method=$([ $brew_formula_upgrade_exit -ne 0 ] && echo "reinstall" || echo "upgrade")
            if [ $brew_formula_upgrade_exit -ne 0 ]; then
                if [ $brew_formula_reinstall_exit -eq 0 ]; then
                    brew_formula_method="reinstall"
                    brew_formula_reinstall_exit=0
                elif [ $brew_formula_reinstall_force_exit -eq 0 ]; then
                    brew_formula_method="reinstall_force"
                    brew_formula_reinstall_exit=0
                fi
            else
                brew_formula_method="upgrade"
            fi    

            #updated_list+=("success|cask|$pkg_brew_formula|$brew_formula_method")
            if [ $brew_formula_final_exit -eq 0 ] ; then
                updated_list+=("success|formula|$pkg_brew_formula|$brew_formula_method")
            else
                updated_list+=("failure|formula|$pkg_brew_formula|$brew_formula_method")
            fi

           #echo -e "--------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            if [ "${DEBUG_SCRIPT:-false}" = true ]; then
                echo -e "[DEBUG] Removing brew_formula_tmpfile (upgrade failure): $brew_formula_tmpfile" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            fi
            rm -f "$brew_formula_tmpfile"

        done

    else

        echo -e ""                                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        printf "\033[1;34m[Install]\033[0m "
        printf "[Install] "                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "无需更新：HomeBrew Formula ... "                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        #echo -e ""                                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    fi






    brew_cask_upgrade_exit=false
    brew_cask_reinstall_exit=false
    brew_cask_reinstall_force_exit=false

    # 第 4 步：串行安装（HomeBrew Cask）
    if [ ${#packages_brew_casks[@]} -ne 0 ] ; then
        echo -e ""                                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        printf  "\033[1;34m[Install]\033[0m "
        printf  "[Install] "                                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo -e "开始更新：HomeBrew Cask（ 串行 ） ... "                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

        # 存储需要关闭和重启的应用程序
        #brew_cask_apps_to_restart=()

        # 逐个安装 每个待更新的 cask app
        for pkg_brew_cask in "${packages_brew_casks[@]}"; do

            # 调试输出：开始处理当前 cask
            if [ "${DEBUG_SCRIPT:-false}" = true ]; then
                echo -e "[DEBUG] Begin processing cask: $pkg_brew_cask" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            fi

            # 如果在并行下载阶段检测到该 cask 下载失败，则直接跳过升级
            if [[ -n "$FAILED_FETCH_CASKS_FILE" && -f "$FAILED_FETCH_CASKS_FILE" ]]; then
                fail_line=$(grep -F "${pkg_brew_cask}|" "$FAILED_FETCH_CASKS_FILE" || true)
                if [[ -n "$fail_line" ]]; then
                    fail_url=$(echo "$fail_line" | cut -d'|' -f2-)
                    echo -e "❌  更新失败 [cask]    : $pkg_brew_cask (下载失败：$fail_url)" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    updated_list+=("failure|cask|$pkg_brew_cask|fetch_failed:$fail_url")
                   #echo -e "--------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    continue
                fi
            fi

            # 新增：为 cask 升级输出创建临时文件，避免变量未定义导致 tee 报错
            brew_cask_tmpfile=$(mktemp)

            # 初始化每个 cask 应用的状态变量
            brew_cask_app_name=""
            brew_cask_exec_name=""
            brew_cask_process_name=""
            brew_cask_app_id=""
            brew_cask_was_running=false

            # ------- 判断当前用户权限：Root 或 普通用户 -------
            if [[ $(id -u) -eq 0 ]]; then
                # 1) 如果是 root，降权至目标普通用户执行 brew info
                targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
               #echo -e "✓  Root权限降权至普通权限 ($targetUser) 后，查询 cask 信息  ( brew info --cask $pkg_brew_cask )  ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                # 使用 run_as_normal_user 保留 PATH/HOMEBREW_CASK_OPTS 环境并降权执行 brew info
                brew_cask_info_output=$(run_as_normal_user brew info --cask "$pkg_brew_cask")
            else
                # 2) 如果已是普通用户，直接执行 brew info
               #echo -e "✓  当前用户 '$USER' 为普通权限，直接查询 cask 信息  ( brew info --cask $pkg_brew_cask )  ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                brew_cask_info_output=$(brew info --cask "$pkg_brew_cask")
            fi


            #exit 1                                                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"          # 用于调试 ！！

            # ---------- 升级 cask 应用 ----------   

            # 第一次尝试升级：通过 brew upgrade 升级 APP
            # 调用 brew upgrade，并捕获其输出以供后续检测，同时仍输出到日志。
            # 为确保能够准确检测 SHA 校验错误，将 brew upgrade 的输出保存在变量 upgrade_output 中，
            # 结束后再写入临时文件供 run_fsinstaller_if_needed 查找 FSInstaller。
            {
                if [ "$(id -u)" -eq 0 ]; then
                    # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
                    targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
                    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_cask 升级 ( brew upgrade --cask --greedy $pkg_brew_cask --verbose --debug ) ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    upgrade_output=$( run_as_normal_user brew upgrade --cask --greedy "$pkg_brew_cask" 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" /dev/stderr )
                    brew_cask_upgrade_exit=${PIPESTATUS[0]}
                else
                    echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 $pkg_brew_cask 升级 ( brew upgrade --cask --greedy $pkg_brew_cask --verbose --debug ) ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    upgrade_output=$( brew upgrade --cask --greedy "$pkg_brew_cask" 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" /dev/stderr )
                    brew_cask_upgrade_exit=${PIPESTATUS[0]}
                fi
            }  # end capture subshell

            brew_cask_final_exit=$brew_cask_upgrade_exit
            # 将捕获到的输出写入临时文件，用于 run_fsinstaller_if_needed 分析。
            echo "$upgrade_output" > "$brew_cask_tmpfile"

            # 调试输出：打印 brew upgrade 的临时输出文件内容，帮助定位校验码检测失败的原因
            if [ "${DEBUG_SCRIPT:-false}" = true ]; then
                # 输出临时文件路径和权限以确认其正确创建
                echo -e "[DEBUG] Temp file for $pkg_brew_cask: $brew_cask_tmpfile" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                ls -l "$brew_cask_tmpfile" 2>/dev/null | sed -e 's/^/>> /' | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                echo -e "[DEBUG] Captured output for upgrade of $pkg_brew_cask (exit $brew_cask_upgrade_exit):" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                # 显示前几十行内容，防止日志过长
                head -n 40 "$brew_cask_tmpfile" 2>/dev/null | sed -e 's/^/>> /' | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            fi

            # ---------- 新增：SHA-256 校验失败检测 ----------
            # 当首次升级失败且输出包含 SHA-256 mismatch 时，直接记录失败并跳过后续重装
            if [ "$brew_cask_upgrade_exit" -ne 0 ]; then
                # 检测常见的校验失败提示，若匹配则直接记录失败并跳过后续尝试。
                # 为避免 ANSI 颜色编码影响匹配结果，先移除输出中的转义序列。
                # 使用 sed 删除 ESC[ 开头的终端控制序列，再用 grep 进行匹配。
                if [[ -f "$brew_cask_tmpfile" ]] && sed -E 's/\x1B\[[0-9;]*[A-Za-z]//g' "$brew_cask_tmpfile" | \
                   grep -qiE 'sha[ -]*256[^[:alnum:]]*mismatch|checksum[^[:alnum:]]*mismatch|wrong checksum'; then
                    sha_expected=$(sed -E 's/\x1B\[[0-9;]*[A-Za-z]//g' "$brew_cask_tmpfile" | grep -i 'Expected:' | head -n1 | sed -E 's/.*Expected:[[:space:]]*//I' || true)
                    sha_actual=$(sed -E 's/\x1B\[[0-9;]*[A-Za-z]//g' "$brew_cask_tmpfile" | grep -i 'Actual:' | head -n1 | sed -E 's/.*Actual:[[:space:]]*//I' || true)
                    echo -e "⚠️  检测到校验码不匹配 [cask]   $pkg_brew_cask ，停止后续尝试。实际校验码: ${sha_actual:-未知} ，期望校验码: ${sha_expected:-未知}" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    updated_list+=("failure|cask|$pkg_brew_cask|sha256_mismatch:${sha_actual:-unknown}:${sha_expected:-unknown}")
                   #echo -e "--------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    # 调试输出：发生校验不匹配，跳过当前 cask
                    if [ "${DEBUG_SCRIPT:-false}" = true ]; then
                        echo -e "[DEBUG] Checksum mismatch detected for $pkg_brew_cask, skipping further install attempts" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    fi
                    rm -f "$brew_cask_tmpfile"
                    continue   # 跳过后续重装
                fi
            fi

            # ---------- 若升级失败则尝试重装 ----------
            if [ $brew_cask_upgrade_exit -ne 0 ] ; then

                # 注意：若首次升级失败且未检测到校验码不匹配，则继续执行后续 reinstall 逻辑。
                # 这里不再根据是否属于 MANUAL_INSTALL_CASKS 来决定是否跳过，
                # 因为 reinstall / reinstall --force 可以解决因占用进程导致的升级失败。

                # 额外检测：brew upgrade 输出中若包含显式的 "SHA-256 mismatch" 文本，则认为校验码错误并跳过后续安装。
                # 某些情况下 ANSI 颜色影响前面的正则匹配，这里直接匹配关键字以增强鲁棒性。
                if [[ -f "$brew_cask_tmpfile" ]] && grep -qi 'SHA-256 mismatch' "$brew_cask_tmpfile"; then
                    # 初始化默认值，避免在文件不存在时引用未定义变量
                    sha_expected=""
                    sha_actual=""
                    # 在提取期望和实际校验码之前，再次确认临时文件存在
                    if [[ -f "$brew_cask_tmpfile" ]]; then
                        sha_expected=$(grep -i 'Expected:' "$brew_cask_tmpfile" | head -n1 | sed -E 's/.*Expected:[[:space:]]*//I' || true)
                        sha_actual=$(grep -i 'Actual:' "$brew_cask_tmpfile" | head -n1 | sed -E 's/.*Actual:[[:space:]]*//I' || true)
                    fi
                    echo -e "⚠️  检测到校验码不匹配 [cask]   $pkg_brew_cask ，停止后续尝试。实际校验码: ${sha_actual:-未知} ，期望校验码: ${sha_expected:-未知}" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    updated_list+=("failure|cask|$pkg_brew_cask|sha256_mismatch:${sha_actual:-unknown}:${sha_expected:-unknown}")
                   #echo -e "--------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    if [ "${DEBUG_SCRIPT:-false}" = true ]; then
                        echo -e "[DEBUG] SHA-256 mismatch detected for $pkg_brew_cask via fallback check, skipping further install attempts" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    fi
                    rm -f "$brew_cask_tmpfile"
                    continue
                fi

                # 注意：⚠️ cask不需要 重新链接 ！

                # 第二次尝试升级：通过 brew reinstall 升级 APP  
                echo -e "⚠️ upgrade 失败，尝试重装 ( brew reinstall --cask $pkg_brew_cask --verbose --debug ) ... "                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                # 检查是否以 root 身份运行
                if [ "$(id -u)" -eq 0 ]; then
                    # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
                    targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
                    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_cask 重装 ( brew reinstall --cask $pkg_brew_cask --verbose --debug ) ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    # 使用辅助函数 run_as_normal_user 保留环境并执行 brew reinstall
                    run_as_normal_user brew reinstall --cask  "$pkg_brew_cask" 2>&1       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                else
                    echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 $pkg_brew_cask 重装 ( brew reinstall --cask $pkg_brew_cask --verbose --debug ) ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
                    brew reinstall --cask "$pkg_brew_cask" 2>&1                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                fi
   
                brew_cask_reinstall_exit=${PIPESTATUS[0]}    # 获取 brew reinstall 的退出码  
                brew_cask_final_exit=$brew_cask_reinstall_exit       # 将最终状态更新为 reinstall 的状态  



                # 如果第二次尝试仍然失败。尝试关闭线程，然后开始尝试 第三次更升级，通过 brew reinstall --force 强制升级 APP。  
                if [ $brew_cask_reinstall_exit -ne 0 ]; then

                    # 尝试从输出中提取应用的 .app 行（如果存在）
                    brew_cask_app_line=$(echo "$brew_cask_info_output" | grep -m1 '\.app (App)')
                    if [[ -n "$brew_cask_app_line" ]]; then
                        # 提取应用程序包名（去掉“.app (App)”标记和多余空格）
                        brew_cask_app_name=$(echo "$brew_cask_app_line" | sed -e 's/\.app (App)//' -e 's/^[[:space:]]*//')
                    fi

                    if [[ -n "$brew_cask_app_name" ]]; then
                            echo -e "✓  检测到应用名称 = '$brew_cask_app_name.app' ，通过命令 ( brew info $pkg_brew_cask ) 输出的 Artifacts 字段。应用名称用来，关闭进程。已防止阻碍后续更新 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    fi

                    # 如果未找到 .app 信息且检测到 .pkg 安装包，则解析 .pkg 获取应用名称和进程名
                    if [[ -z "$brew_cask_app_line" && $(echo "$brew_cask_info_output" | grep -c '\.pkg (Pkg)') -gt 0 ]]; then

                        echo -e "✘  未能从 brew info $pkg_brew_cask 中，提取到安装后的 应用名称（*.app） ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

                        # 提取即将安装的版本号（优先从 brew info 第一行获取）
                        brew_cask_new_version="$(echo "$brew_cask_info_output" | awk -F'[: ]+' 'NR==1{print $3}')"
                        if [[ -z "$brew_cask_new_version" ]]; then
                            brew_cask_new_version="$(brew info --cask --json=v2 "$pkg_brew_cask" 2>/dev/null | grep -m1 '"version"' | sed -E 's/.*"version": *"([^"]+)".*/\1/')"
                        fi
                        # 构造 .pkg 文件路径（HomeBrew Cask 默认安装路径）
                        brew_cask_pkg_line="$(echo "$brew_cask_info_output" | grep -m1 '\.pkg (Pkg)')"
                        brew_cask_pkg_file_name="$(echo "$brew_cask_pkg_line" | awk '{print $1}')"
                        brew_cask_pkg_path="/opt/homebrew/Caskroom/$pkg_brew_cask/$brew_cask_new_version/$brew_cask_pkg_file_name"

                        echo -e "✓  准备通过 解压缩 $brew_cask_pkg_file_name.pkg 安装包，寻找安装包内的 *.app 文件（安装后的的APP名称） ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        echo -e "✓  解析到 pkg 安装包 的 本地路径：$brew_cask_pkg_path ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

                        if [[ -f "$brew_cask_pkg_path" ]]; then
                            # 创建临时目录并展开 .pkg 文件
                            brew_cask_tmp_dir="$("/usr/bin/mktemp" -d)"
                            /usr/sbin/pkgutil --expand "$brew_cask_pkg_path" "$brew_cask_tmp_dir"
                            # 利用 lsbom 列出安装清单中的 .app 路径列表
                            brew_cask_app_paths="$(find "$brew_cask_tmp_dir" -name '*.bom' -exec /usr/bin/lsbom -f {} \; | sed -n 's#^\(.*\.app\)/Contents/.*#\1#p' | sort -u)"
                            # 遍历 .pkg 安装包含的应用路径（使用 while 逐行读取，支持路径中含空格）
                            while IFS= read -r app_rel_path; do
                                full_app_path="/$app_rel_path"   # .pkg 安装路径是系统根目录起始
                                if [[ -d "$full_app_path" ]]; then
                                    # 读取应用的 Info.plist 获取可执行文件名和 Bundle ID
                                    brew_cask_exec_name="$(/usr/bin/defaults read "$full_app_path/Contents/Info.plist" CFBundleExecutable 2>/dev/null)"
                                    brew_cask_bundle_id="$(/usr/bin/defaults read "$full_app_path/Contents/Info.plist" CFBundleIdentifier 2>/dev/null)"
                                    if [[ -n "$brew_cask_exec_name" ]]; then
                                        brew_cask_app_name="$full_app_path"    # 保存应用程序路径
                                        brew_cask_process_name="$brew_cask_exec_name"    # 对应进程名（用于 pkill/killall）
                                        brew_cask_app_id="$brew_cask_bundle_id"          # 应用 Bundle ID（用于 AppleScript 定位）
                                        echo -e "✓  检测到 .pkg 将安装应用：$full_app_path，进程名：$brew_cask_process_name" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                                        # 如检测到该进程正在运行则尝试关闭
                                        #if pgrep -ix "$brew_cask_process_name" > /dev/null; then
                                        #    echo -e "✓  检测到 $brew_cask_process_name 正在运行，正在尝试退出 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                                        #    ( /usr/bin/osascript -e "tell application id \"$brew_cask_app_id\" to quit" || /usr/bin/pkill -x "$brew_cask_process_name" ) 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                                        #    sleep 5   # 等待进程退出完成
                                        #    brew_cask_was_running=true
                                        #fi
                                        # 检测到目标应用正在运行则尝试关闭（优雅退出 + 超时强杀）
                                        if pgrep -ix "$brew_cask_process_name" > /dev/null; then
                                            echo -e "✓  检测到 '$brew_cask_process_name' (pkg) 正在运行，正在尝试退出 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                                            attempt_quit_app "$brew_cask_app_id" "$brew_cask_process_name" 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                                            brew_cask_was_running=true   # 标记应用本来是运行状态（供后续决定是否重启）
                                        fi

                                        break   # 已找到目标应用，退出循环
                                    fi
                                fi
                            done <<< "$brew_cask_app_paths"
                            # 清理临时文件
                            /bin/rm -rf "$brew_cask_tmp_dir"
                        fi
                        # 有的时候，由于pkg内部还会套多个pkg，故对pkg第一次解压缩后，可能拿不到.app文件名。此时就会获取不到应用名称。
                        # 对于这种情况，建议直接使用 brew info 的 Name 字段作为候选
                        # 如果仍未从 .pkg 中提取到应用名，则使用 brew info 的 Name 字段作为候选
                        if [[ -z "$brew_cask_exec_name" ]]; then
                            echo -e "✘  未能从 $pkg_brew_cask 的 pkg 安装包 $brew_cask_pkg_line 中，提取到安装后的 应用名称（*.app）..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                            echo -e "✘  由于 pkg 内嵌套多个 pkg 。此时就会 获取不到 应用名称 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                            brew_cask_name_line="$(echo "$brew_cask_info_output" | awk '/^==> Name$/{getline; print}')"
                            echo -e "✓  使用 brew info $pkg_brew_cask 的 Name 字段 $brew_cask_name_line ，作为安装后的 应用名称（$brew_cask_name_line.app），查询并关闭 相应进程 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                            brew_cask_app_name="$brew_cask_name_line"
                            [[ "$brew_cask_app_name" =~ Pro\ DC$ ]] && brew_cask_app_name="${brew_cask_app_name// Pro DC/}"   # 去除特殊后缀（如 "Pro DC"）
                            brew_cask_process_name="$brew_cask_app_name"
                        fi
                    fi

                    # 根据提取的应用名/进程名，尝试关闭正在运行的应用以便升级

                    # 如 brew_cask_app_id 为空（非 .pkg 安装），尝试查找已安装的 .app 路径并读取 Info.plist 获取 Bundle ID 和 可执行文件名
                    if [[ -n "$brew_cask_app_name" && -z "$brew_cask_app_id" ]]; then
                        # 搜索常见安装路径 /Applications 和 ~/Applications 下的 .app
                        if [[ -d "/Applications/$brew_cask_app_name.app" ]]; then
                            full_app_path="/Applications/$brew_cask_app_name.app"
                        elif [[ -d "$HOME/Applications/$brew_cask_app_name.app" ]]; then
                            full_app_path="$HOME/Applications/$brew_cask_app_name.app"
                        else
                            # 若上述路径未找到，检查 HomeBrew Caskroom 目录
                            if [[ -d "/opt/homebrew/Caskroom/$pkg_brew_cask" ]]; then
                                full_app_path=$(find "/opt/homebrew/Caskroom/$pkg_brew_cask" -maxdepth 4 -type d -name "$brew_cask_app_name.app" -print -quit)
                            fi
                            if [[ -z "$full_app_path" && -d "/usr/local/Caskroom/$pkg_brew_cask" ]]; then
                                full_app_path=$(find "/usr/local/Caskroom/$pkg_brew_cask" -maxdepth 4 -type d -name "$brew_cask_app_name.app" -print -quit)
                            fi
                        fi

                        # 如果找到已安装的 .app，读取其 Info.plist 获取进程名和 Bundle ID
                        if [[ -n "$full_app_path" && -d "$full_app_path" ]]; then
                            brew_cask_exec_name=$(/usr/bin/defaults read "$full_app_path/Contents/Info.plist" CFBundleExecutable 2>/dev/null)
                            brew_cask_bundle_id=$(/usr/bin/defaults read "$full_app_path/Contents/Info.plist" CFBundleIdentifier 2>/dev/null)
                            if [[ -n "$brew_cask_exec_name" ]]; then
                                brew_cask_process_name="$brew_cask_exec_name"
                                brew_cask_app_id="$brew_cask_bundle_id"
                                echo -e "✓  当前APP的，应用名：'$brew_cask_app_name' ; 路径名：'$full_app_path' ; 进程名：'$brew_cask_process_name' " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                            fi
                        fi
                    fi

                    # 如仍未设置进程名（非 .pkg 安装且未找到 Info），则使用应用名称作为进程名
                    [[ -z "$brew_cask_process_name" ]] && brew_cask_process_name="$brew_cask_app_name"

                    if pgrep -ix "$brew_cask_process_name" > /dev/null; then
                        echo -e "✓  检测到 $brew_cask_process_name (app) 正在运行。开始尝试退出 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        attempt_quit_app "$brew_cask_app_id" "$brew_cask_process_name" 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                        brew_cask_was_running=true   # 标记应用原本处于运行状态（更新后需重启）
                        echo -e "✓  退出 '$brew_cask_process_name' 进程 已完成 ... " 
                    else
                        echo -e "✓  直接升级！！！ $brew_cask_app_name 未运行" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    fi

                fi


                # 第三次尝试升级：再次尝试关闭阻碍更新的进程，并通过 brew reinstall --force 升级 APP
                if [ $brew_cask_reinstall_exit -ne 0 ]; then
                      # 若重装失败且检测到应用仍在运行，强制关闭后再重试一次
                      if pgrep -ix "$brew_cask_app_name" > /dev/null; then
                          brew_cask_pid=$(pgrep -f "$brew_cask_app_name")
                          echo -e "⚠️ 检测到 $brew_cask_app_name ( PID = $brew_cask_pid ) 仍在运行，尝试强制关闭，然后再次尝试 reinstall 覆盖安装 ... "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                          if [ -n "$brew_cask_pid" ]; then
                              kill -9 "$brew_cask_pid"
                          fi
                      else
                          echo -e "✓  $brew_cask_app_name 未发现其运行，准备尝试 reinstall --force 强制覆盖安装 !!! "          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                      fi
       
                      # 检查是否以 root 身份运行
                      if [ "$(id -u)" -eq 0 ]; then
                          echo -e "⚠️ upgrade 失败，尝试 强制覆盖安装 ( brew reinstall --cask --force $pkg_brew_cask --verbose --debug ) ... "                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                          # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
                          targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
                          echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 $pkg_brew_cask 强制覆盖安装 ( brew reinstall --cask --force $pkg_brew_cask --verbose --debug ) ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                          # 使用辅助函数 run_as_normal_user 保留环境并执行 brew reinstall --force
                          run_as_normal_user brew reinstall --cask --force "$pkg_brew_cask" 2>&1       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                      else
                          echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 $pkg_brew_cask 强制覆盖安装 ( brew reinstall --cask --force $pkg_brew_cask --verbose --debug ) ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
                          brew reinstall --cask --force "$pkg_brew_cask" 2>&1                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                      fi
       
                      #brew reinstall --cask --force "$pkg_brew_cask" 2>&1                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
       
                      brew_cask_reinstall_force_exit=${PIPESTATUS[0]}
                      brew_cask_final_exit=$brew_cask_reinstall_force_exit       # 将最终状态更新为 reinstall 的状态  
                fi


                # 第四次尝试升级 ：对于需要手动更新的app，单独处理 （ 如：paragon-ntfs、paragon-extfs ）
                if [[ " ${MANUAL_INSTALL_CASKS[*]} " == *" $pkg_brew_cask "* ]]; then
                  echo -e "⚠️  $pkg_brew_cask 需要手动安装，尝试运行其安装器..."

                  # 根据 HomeBrew 前缀确定 Caskroom 路径（Intel 在 /usr/local/Caskroom）
                  caskroom_base=$(brew --prefix)/Caskroom

                  # 查找 FSInstaller.app 的最新版本路径
                  manual_installer_app=$(find "$caskroom_base/$pkg_brew_cask" -maxdepth 3 -type d -name "FSInstaller.app" | sort -r | head -n 1)

                  if [[ -n "$manual_installer_app" ]]; then
                    # 为避免 Gatekeeper 静默阻止，先移除隔离标记
                    if [[ $(id -u) -eq 0 ]]; then
                      targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
                      # 使用非交互模式的 sudo 调用，避免在后台运行时等待密码
                      sudo -n -u "$targetUser" xattr -dr com.apple.quarantine "$manual_installer_app"
                      # 以图形界面方式启动安装器，后台运行不阻塞
                      sudo -n -u "$targetUser" open -n "$manual_installer_app" >/dev/null 2>&1 &
                    else
                      xattr -dr com.apple.quarantine "$manual_installer_app"
                      # 启动安装器，后台运行不阻塞
                      open -n "$manual_installer_app" >/dev/null 2>&1 &
                    fi
                  else
                    echo -e "❌ 未找到 $pkg_brew_cask 的安装器，请手动在 Finder 中运行 FSInstaller.app"
                  fi

                  # 安装器执行完后，系统会提示“来自 Paragon Software 的系统软件已被阻止”时
                  # 需要用户前往系统设置 → 隐私与安全性 → 允许，并根据提示重启。
                fi

            fi  

            # ---------- 重新启动 APP（如果在本次升级中被关闭） ----------   

            # 如果之前关闭了应用，更新完成后重新打开 
            if [[ "$brew_cask_was_running" = true && -n "$brew_cask_app_name" ]]; then  
              echo -e "✓  重新启动此前关闭的应用：$brew_cask_app_name ... "                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
              open -a "$brew_cask_app_name.app" 2>&1                                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            fi

            # ---------- 本APP 的 升级结果 ----------  
            if [ $brew_cask_final_exit -eq 0 ]; then
                echo -e "✅  更新成功 [cask]   : $pkg_brew_cask "                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            else
                echo -e "❌  更新失败 [cask]   : $pkg_brew_cask "                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            fi

            #brew_cask_method=$([ $brew_cask_upgrade_exit -ne 0 ] && echo "reinstall" || echo "upgrade")
            if [ $brew_cask_upgrade_exit -ne 0 ]; then
                if [ $brew_cask_reinstall_exit -eq 0 ]; then
                    brew_cask_method="reinstall"
                    brew_cask_reinstall_exit=0
                elif [ $brew_cask_reinstall_force_exit -eq 0 ]; then
                    brew_cask_method="reinstall_force"
                    brew_cask_reinstall_exit=0
                fi
            else
                brew_cask_method="upgrade"
            fi                

            #updated_list+=("success|cask|$pkg_brew_cask|$brew_cask_method")
            if [ $brew_cask_final_exit -eq 0 ] ; then
                updated_list+=("success|cask|$pkg_brew_cask|$brew_cask_method")
            else
                updated_list+=("failure|cask|$pkg_brew_cask|$brew_cask_method")
            fi

           #echo -e "--------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

            # 在记录完结果后，检查是否需要后台启动手动安装器。
            # 仅当该 cask 不在手动安装列表中时执行，并在后台运行
            if [[ " ${MANUAL_INSTALL_CASKS[*]} " != *" $pkg_brew_cask "* ]]; then
                # 同步执行 run_fsinstaller_if_needed，确保在删除临时文件前完成解析
                run_fsinstaller_if_needed "$pkg_brew_cask" "$brew_cask_tmpfile" "$LOG_FULL_LAST"
            fi

            # 调试输出：删除临时文件前打印其路径，帮助定位潜在的文件访问问题
            if [ "${DEBUG_SCRIPT:-false}" = true ]; then
                echo -e "[DEBUG] Removing brew_cask_tmpfile: $brew_cask_tmpfile" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            fi
            rm -f "$brew_cask_tmpfile"  # 清理临时文件

            # 调试输出：完成当前 cask 处理
            if [ "${DEBUG_SCRIPT:-false}" = true ]; then
                echo -e "[DEBUG] Finished processing cask: $pkg_brew_cask (final_exit=$brew_cask_final_exit)" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            fi

        done

        echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    else  

        echo -e ""                                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        printf  "\033[1;34m[Install]\033[0m "   
        printf  "[Install] "                                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  > /dev/null
        echo -e "无需更新：HomeBrew Cask ... "                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    fi    




 #  brew upgrade --greedy --debug --force                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE""  ###### 仅作为Debug使用！！！

else    

    echo -e "✓  未检测到新版本 ：HomeBrew Formula ... "                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    echo -e "✓  未检测到新版本 ：HomeBrew Cask ... "                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    echo -e ""                                                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    printf  "\033[1;34m[Download & Install]\033[0m "    
    printf  "[Download & Install] "                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "HomeBrew 下载安装 ... "                                         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    echo -e "✓  所有APP已经是 最新版本 ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    echo -e ""                                                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

fi


# 第 5 步： 清洁
printf  "\033[1;34m[Clean]\033[0m "
printf  "[Clean] "                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "HomeBrew 清理残留 ... "                                                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"


# 检查是否以 root 身份运行
if [ "$(id -u)" -eq 0 ]; then
    # 获取目标普通用户（优先用SUDO_USER，否则尝试控制台登录用户）
    targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"
    # 使用辅助函数 run_as_normal_user 保留环境并执行 brew cleanup 
    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 brew cleanup ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    run_as_normal_user brew cleanup -s --prune=all 2>&1       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 自动移除不再依赖的“孤儿”包
    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 brew autoremove ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    run_as_normal_user brew autoremove 2>&1                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 列出缺失依赖，仅提示，不影响退出码
    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 brew missing ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    run_as_normal_user brew missing || true                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
else
    # 执行清理
    echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 brew cleanup ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    brew cleanup -s --prune=all 2>&1                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 自动移除不再依赖的“孤儿”包
    echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 brew autoremove ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    brew autoremove 2>&1                                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 列出缺失依赖，仅提示，不影响退出码
    echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 brew missing ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    brew missing || true                                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
fi


echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"


# 第 6 步： 显示结果
printf "\033[1;34m[Final]\033[0m "
printf "[Final] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "HomeBrew 更新结果 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

if [ ${#packages_brew[@]} -eq 0 ]; then
    # 没有任何软件需要更新的情况
    echo -e "✓  没有APP被更新 !!! " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
else
    # 逐条输出更新结果
    for entry in "${updated_list[@]}"; do
        IFS='|' read -r status type name brew_method <<< "$entry"
        # 每次循环重置，避免上一条的 reinstall 提示“串味”
        brew_warning_cmd=""
        # 根据状态选择符号和文字
        if [ "$status" = "success" ]; then
            symbol="✅"
            status_text="成功"
        else
            symbol="❌"
            status_text="失败"
        fi
        # 根据类型调整对齐格式
        if [ "$type" = "cask" ]; then
            type_display="[cask]"
            spacing="   "      # cask 比 formula 短3个字母，补3个空格对齐
        else
            type_display="[formula]"
            spacing=""
        fi
        # 构造基础输出行（符号、结果、类型、名称）
        line="$symbol  更新$status_text $type_display$spacing : $name"
        # 如果是失败且 brew_method 为 fetch_failed:<URL>，则追加下载失败原因
        # 处理 SHA-256 校验失败的情况
        if [ "$status" = "failure" ] && [[ "$brew_method" == sha256_mismatch:* ]]; then
            # brew_method 格式: sha256_mismatch:actual:expected
            tmp="${brew_method#sha256_mismatch:}"
            sha_actual="${tmp%%:*}"
            sha_expected="${tmp#*:}"
            line="$symbol  更新$status_text $type_display$spacing : $name (SHA-256校验失败：实际: $sha_actual, 期望: $sha_expected)"
        # 如果是失败且 brew_method 为 fetch_failed:<URL>，则追加下载失败原因
        elif [ "$status" = "failure" ] && [[ "$brew_method" == fetch_failed:* ]]; then
            fail_url="${brew_method#fetch_failed:}"
            line="$symbol  更新$status_text $type_display$spacing : $name (下载失败：$fail_url)"
        fi
        # 若通过重装更新，则附加警告标记和具体命令
        if [ "$status" = "success" ]; then
            if [ "$brew_method" = "reinstall_force" ]; then
                # 强制重装成功的情况
                brew_warning_cmd="brew reinstall --cask --force $name"
                [ "$type" != "cask" ] && brew_warning_cmd="brew reinstall --force $name"
            elif [ "$brew_method" = "reinstall" ]; then
                # 普通重装成功的情况
                brew_warning_cmd="brew reinstall --cask $name"
                [ "$type" != "cask" ] && brew_warning_cmd="brew reinstall $name"
            fi
            [ -n "$brew_warning_cmd" ] && line="$line   ( ⚠️ 更新方式 ：$brew_warning_cmd )"
        fi
        # 输出该行到屏幕和日志
        echo -e "$line" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    done
fi


echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"


# 检查是否以 root 身份运行
#if [ "$(id -u)" -eq 0 ]; then
#else
#fi

echo -e "\033[1;32m[OK] HomeBrew Upgrade  运行已完成  ✅ \033[1;32m"   
echo -e "[OK]  HomeBrew Upgrade  运行已完成  ✅ "                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

#exit 1                                                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"          # 用于调试 ！！









# ----------------------------------
# 开始执行：Sparkle
# ----------------------------------

if [ "${sparkle_available:-false}" != "true" ]; then
    # 如果 Sparkle 工具不可用，则直接打印提示并跳过
    echo -e "\033[1;32m-----------------------------------------------\033[0m"
    echo -e "\033[1;32m 运行 Sparkle                                \033[0m"
    echo -e "\033[1;32m-----------------------------------------------\033[0m"

    echo -e "-------------------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "运行 Sparkle" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "-------------------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

    echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    printf  "\033[1;34m[ERROR]\033[0m "
    printf  "[ERROR] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "未找到 Sparkle CLI，可执行文件缺失。跳过 Sparkle 更新。 ❌" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
else
    # Sparkle 可用，开始执行应用扫描与更新
    echo -e "\033[1;32m-----------------------------------------------\033[0m"
    echo -e "\033[1;32m 运行 Sparkle                                \033[0m"
    echo -e "\033[1;32m-----------------------------------------------\033[0m"

    echo -e "-------------------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "运行 Sparkle" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "-------------------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

    # 调用检查时间范围函数
    check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

    echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 确定 Sparkle CLI 路径
    SPARKLE_CLI="$(command -v sparkle 2>/dev/null || true)"
    if [ -z "$SPARKLE_CLI" ] && [ -x "/Applications/sparkle.app/Contents/MacOS/sparkle" ]; then
        SPARKLE_CLI="/Applications/sparkle.app/Contents/MacOS/sparkle"
    elif [ -z "$SPARKLE_CLI" ] && [ -x "/Applications/Sparkle.app/Contents/MacOS/sparkle" ]; then
        SPARKLE_CLI="/Applications/Sparkle.app/Contents/MacOS/sparkle"
    fi

    # [List] 阶段：列出支持 Sparkle 的应用
    printf  "\033[1;34m[List]\033[0m "
    printf  "[List] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "Sparkle 应用列表 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    sparkle_app_paths=""
    if [ "$(id -u)" -eq 0 ]; then
        targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 Sparkle 应用扫描 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        sparkle_app_paths=$(sudo -n -H -u "$targetUser" bash -lc 'find /Applications "$HOME"/Applications -maxdepth 2 -type d -name "*.app" -print0 | while IFS= read -r -d "" app; do
            if [[ -d "$app/Contents/Frameworks/Sparkle.framework" ]] || [[ -d "$app/Contents/SharedFrameworks/Sparkle.framework" ]] || /usr/libexec/PlistBuddy -c "Print :SUFeedURL" "$app/Contents/Info.plist" >/dev/null 2>&1; then
              echo "$app"
            fi
          done')
    else
        echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 Sparkle 应用扫描 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        sparkle_app_paths=$(find /Applications "$HOME"/Applications -maxdepth 2 -type d -name "*.app" -print0 | while IFS= read -r -d '' app; do
            if [[ -d "$app/Contents/Frameworks/Sparkle.framework" ]] || [[ -d "$app/Contents/SharedFrameworks/Sparkle.framework" ]] || /usr/libexec/PlistBuddy -c "Print :SUFeedURL" "$app/Contents/Info.plist" >/dev/null 2>&1; then
              echo "$app"
            fi
          done)
    fi

    # 计算 Sparkle 应用数量
    sparkle_app_count=$(echo "$sparkle_app_paths" | sed '/^\s*$/d' | wc -l | tr -d ' ')

    # 统计无法通过 Homebrew 升级的 Sparkle 应用数量（基于应用名称匹配）
    sparkle_non_brew_count=0
    # 获取已安装的 Homebrew Cask 名单
    if [ "$(id -u)" -eq 0 ]; then
        tmp_target="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        brew_tokens=$(sudo -n -H -u "$tmp_target" bash -lc 'brew list --cask -1 2>/dev/null' || true)
    else
        brew_tokens=$(brew list --cask -1 2>/dev/null || true)
    fi
    if [ -n "$sparkle_app_paths" ]; then
        # 构建归一化后的 HomeBrew cask 名称列表（含去尾数字和最后一段）
        brew_tokens_norm=""
        if [ -n "$brew_tokens" ]; then
            while IFS= read -r token; do
                # 全部小写、去除非字母数字字符
                norm=$(echo "$token" | tr 'A-Z' 'a-z' | tr -dc '[:alnum:]')
                [ -n "$norm" ] && brew_tokens_norm="${brew_tokens_norm}"$'\n'"$norm"
                # 去除尾部数字形成第二个变体
                norm_nd=$(echo "$norm" | sed -E 's/[0-9]+$//')
                [ -n "$norm_nd" ] && brew_tokens_norm="${brew_tokens_norm}"$'\n'"$norm_nd"
                # 取 token 的最后一段（以 - 分割）并归一化
                last_seg=$(echo "$token" | awk -F'-' '{print $NF}')
                last_norm=$(echo "$last_seg" | tr 'A-Z' 'a-z' | tr -dc '[:alnum:]')
                [ -n "$last_norm" ] && brew_tokens_norm="${brew_tokens_norm}"$'\n'"$last_norm"
                # 将 token 按 "-" 分段，并添加每个部分的归一化变体
                for part in $(echo "$token" | tr '-' ' '); do
                    part_norm=$(echo "$part" | tr 'A-Z' 'a-z' | tr -dc '[:alnum:]')
                    [ -n "$part_norm" ] && brew_tokens_norm="${brew_tokens_norm}"$'\n'"$part_norm"
                    part_norm_nd=$(echo "$part_norm" | sed -E 's/[0-9]+$//')
                    [ -n "$part_norm_nd" ] && brew_tokens_norm="${brew_tokens_norm}"$'\n'"$part_norm_nd"
                done
            done <<< "$brew_tokens"
        fi
        # 构建归一化后的 MAS 名称列表（含去尾数字）
        mas_tokens_norm=""
        # 如果 mas 命令存在，则尝试获取当前登录用户的 MAS 应用
        if command -v mas >/dev/null 2>&1; then
            mas_output=""
            if [ "$(id -u)" -eq 0 ]; then
                # root 情况：使用 SUDO_USER 或控制台用户执行 mas list
                targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
                if [ -n "$targetUser" ]; then
                    # 使用绝对路径调用 mas list，避免在 sudo 环境下 PATH 被清空导致命令无法找到，同时保留环境变量
                    mas_output=$(sudo -E -n -H -u "$targetUser" bash -lc '/opt/homebrew/bin/mas list' 2>/dev/null || true)
                fi
            else
                mas_output=$(mas list 2>/dev/null || true)
            fi
            if [ -n "$mas_output" ]; then
                echo "$mas_output" | while read -r line; do
                    # mas list 的输出格式: <app_id> <app_name> (<version>)
                    # 取应用名列（忽略第一个字段）
                    name=$(echo "$line" | awk '{$1=""; sub(/^  */, ""); print}')
                    # 去除括号和内部内容，去除非字母数字
                    name_clean=$(echo "$name" | sed -E 's/ \([^)]+\)$//' | sed -E 's/[^[:alnum:]]+//g')
                    norm=$(echo "$name_clean" | tr 'A-Z' 'a-z' | tr -dc '[:alnum:]')
                    [ -n "$norm" ] && mas_tokens_norm="${mas_tokens_norm}"$'\n'"$norm"
                    norm_nd=$(echo "$norm" | sed -E 's/[0-9]+$//')
                    [ -n "$norm_nd" ] && mas_tokens_norm="${mas_tokens_norm}"$'\n'"$norm_nd"
                done
            fi
        fi

        while IFS= read -r app_path; do
            base="$(basename "$app_path")"
            # 检查是否为 MAS 安装（存在收据）
            if [ -e "$app_path/Contents/_MASReceipt/receipt" ]; then
                continue
            fi
            # 归一化应用名称，生成两个变体（含数字和去尾数字）
            base_no_ext="${base%.app}"
            base_norm=$(echo "$base_no_ext" | tr 'A-Z' 'a-z' | tr -dc '[:alnum:]')
            base_norm_nd=$(echo "$base_norm" | sed -E 's/[0-9]+$//')
            # 如果在 MAS 名单中，跳过
            if [ -n "$mas_tokens_norm" ]; then
                if echo "$mas_tokens_norm" | grep -qw "$base_norm" || echo "$mas_tokens_norm" | grep -qw "$base_norm_nd"; then
                    continue
                fi
            fi
            # 如果在 HomeBrew 名单中，跳过
            skip_brew=false
            if [ -n "$brew_tokens_norm" ]; then
                if echo "$brew_tokens_norm" | grep -qw "$base_norm" || echo "$brew_tokens_norm" | grep -qw "$base_norm_nd"; then
                    skip_brew=true
                fi
            fi
            # 如果 app_path 是符号链接且指向 Caskroom，也认为是 HomeBrew 管理
            if [ "$skip_brew" = false ] && [ -L "$app_path" ]; then
                resolved=$(readlink "$app_path")
                case "$resolved" in
                    *Caskroom*|*caskroom*) skip_brew=true ;;
                esac
            fi
            if [ "$skip_brew" = false ]; then
                sparkle_non_brew_count=$((sparkle_non_brew_count+1))
                # 新增：打印每个不在 HomeBrew 或 MAS 管理中的 Sparkle 应用名称
               #echo -e "✅  Sparkle 应用不在 HomeBrew 或 MAS 中：$base"
            fi
        done <<< "$sparkle_app_paths"
    fi

    # 新增打印：提示当前用户权限下如何获取 HomeBrew 应用列表
    echo -e "✅  APP 数量（ Sparkle              ） ：$sparkle_app_count  " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    echo -e "✅  APP 数量（ Sparkle_Non_Homebrew ） ：$sparkle_non_brew_count  " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # [Scan] 阶段：检测可更新的应用
    printf  "\033[1;34m[Scan]\033[0m "
    printf  "[Scan] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "Sparkle 扫描更新 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    sparkle_updates_list=()
    if [ "$sparkle_app_count" -gt 0 ] && [ -n "$SPARKLE_CLI" ]; then
        if [ "$(id -u)" -eq 0 ]; then
            targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
            echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 Sparkle 更新检查 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            while IFS= read -r app; do
                app_name="$(basename "$app")"
                sudo -n -H -u "$targetUser" bash -lc "\"$SPARKLE_CLI\" --check-immediately --probe \"$app\"" >/dev/null 2>&1
                rc=$?
                if [ "$rc" -eq 0 ]; then
                    sparkle_updates_list+=("$app")
                    echo -e "✔︎  检测到新版本 : $app_name " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                fi
            done <<< "$sparkle_app_paths"
        else
            echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 Sparkle 更新检查 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            while IFS= read -r app; do
                app_name="$(basename "$app")"
                "$SPARKLE_CLI" --check-immediately --probe "$app" >/dev/null 2>&1
                rc=$?
                if [ "$rc" -eq 0 ]; then
                    sparkle_updates_list+=("$app")
                    echo -e "✔︎  检测到新版本 : $app_name " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                fi
            done <<< "$sparkle_app_paths"
        fi
    fi

    # 如果没有检测到更新
    if [ ${#sparkle_updates_list[@]} -eq 0 ]; then
        echo -e "✓  未检测到新版本 ：Sparkle 应用 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    fi

    echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # [Install] 阶段：下载安装更新
    printf  "\033[1;34m[Install]\033[0m "
    printf  "[Install] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "Sparkle 下载安装 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    if [ ${#sparkle_updates_list[@]} -gt 0 ] && [ -n "$SPARKLE_CLI" ]; then
        # 初始化 Sparkle 更新结果列表
        sparkle_result_list=()
        for update_path in "${sparkle_updates_list[@]}"; do
            app_name="$(basename "$update_path")"
            if [ "$(id -u)" -eq 0 ]; then
                targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
                echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 Sparkle 更新 : $app_name" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                sudo -n -H -u "$targetUser" bash -lc "\"$SPARKLE_CLI\" --check-immediately --allow-major-upgrades \"$update_path\"" 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                rc=${PIPESTATUS[0]}
            else
                echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 Sparkle 更新 : $app_name" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                "$SPARKLE_CLI" --check-immediately --allow-major-upgrades "$update_path" 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                rc=${PIPESTATUS[0]}
            fi
            # 根据退出状态记录结果
            if [ "$rc" -eq 0 ]; then
                sparkle_result_list+=("success|$app_name")
            else
                sparkle_result_list+=("failure|$app_name")
            fi
        done
    else
        # 如果没有任何应用需要更新
        echo -e "✓  所有APP已经是 最新版本 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 同样初始化为空列表，方便后续判断
        sparkle_result_list=()
    fi

    echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 输出 Sparkle 更新结果，使用类似 HomeBrew/MAS 的风格
    printf "\033[1;34m[Final]\033[0m "
    printf "[Final] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "Sparkle 更新结果 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    if [ ${#sparkle_result_list[@]} -eq 0 ]; then
        echo -e "✓  没有APP被更新 !!! " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    else
        for __entry in "${sparkle_result_list[@]}"; do
            IFS='|' read -r __status __name <<< "$__entry"
            if [ "$__status" = "success" ]; then
                __symbol="✅"
                __status_text="成功"
            else
                __symbol="❌"
                __status_text="失败"
            fi
            echo -e "$__symbol  更新$__status_text [sparkle]   : $__name" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        done
    fi
    echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    echo -e "\033[1;32m[OK] Sparkle 运行已完成  ✅ \033[0m"
    echo -e "[OK]   Sparkle 运行已完成  ✅ " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

    echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
fi

# ----------------------------------
# 开始执行：MAS
# ----------------------------------

export MAS_NO_INTERACTIVE=1

# 配置 MAS 最大重试次数和重试间隔（可根据需要调整或通过环境变量设置）
MAS_MAX_RETRIES=3                                                                       # 最多重试3次（超时重试次数，可配置）
MAS_RETRY_DELAY=5                                                                       # 每次重试之间等待5秒

echo -e "\033[1;32m-----------------------------------------------\033[0m" 
echo -e "\033[1;32m 运行 MAS                                   \033[0m"
echo -e "\033[1;32m-----------------------------------------------\033[0m" 

echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "运行 MAS"                                                                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
  

# 等待3秒，开始执行
#sleep 3  

# 调用检查时间范围函数（假设此函数已定义）
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"


# 尝试扫描 Mac App Store 更新，显示未更新APP列表，带重试机制

mas_attempt=1
mas_success=false
# 标记 MAS 扫描是否失败（无有效更新且发生网络错误）
mas_scan_failed=false

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

printf  "\033[1;34m[List] \033[0m"
printf  "[List] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "MAS 应用列表 ... "                                                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

# 自动获取当前登录用户
currentUser=$(stat -f%Su /dev/console)

# 如无用户登录则跳过 MAS 更新，但不终止整个脚本
if [ -z "$currentUser" ] || [ "$currentUser" = "loginwindow" ]; then
    echo -e "未检测到登录用户，跳过 MAS 更新。"       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
else

# 如果是 root 运行，则切换到登录用户运行 mas list
if [ "$(id -u)" -eq 0 ]; then
    targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 mas list... "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    uid=$(id -u "$currentUser")
    # 使用非交互模式的 sudo 以避免在后台运行时等待密码
    mas_installed_apps=$(launchctl asuser "$uid" sudo -n -u "$currentUser" /opt/homebrew/bin/mas list)
    #mas_app_count=$(launchctl asuser "$uid" sudo -u "$currentUser" /opt/homebrew/bin/mas list | wc -l)
else
    echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 mas list ... "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 非 root 直接运行 mas list
    mas_installed_apps=$(/opt/homebrew/bin/mas list)
    #mas_app_count=$(/opt/homebrew/bin/mas list | wc -l)
fi

if [ -z "$mas_installed_apps" ]; then
    mas_app_count=0
else
    mas_app_count=$(echo "$mas_installed_apps" | wc -l)
fi

# 统计 App 数量并输出结果
mas_app_count=$((mas_app_count+0))
echo -e "✅  APP 数量（ Mac App Store ） ：$mas_app_count  "                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"


echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"



printf  "\033[1;34m[Scan] \033[0m"
printf  "[Scan] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "MAS 扫描更新 ... "                                                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

# ---------------------------------------------------------------------------------------
# 新增：MAS outdated 完成后，重启 App Store 代理进程和安装守护进程，以避免后续流程因
# 大量 MAS 请求导致系统安装服务卡死。根据当前权限分别处理，确保日志打印风格一致。
if [[ "$(id -u)" -eq 0 ]]; then
    # 当前为 root 权限，直接重启代理进程和安装守护进程
    echo -e "✓  Root权限, MAS 准备扫描，正在重启 App Store 代理进程(appstoreagent) 和 installd ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 结束 App Store 代理进程（忽略不存在的错误）
    killall appstoreagent 2>/dev/null || true
    # 重启安装守护进程
    killall installd 2>/dev/null || true
else
    # 当前为普通用户，需要使用 sudo 重启安装守护进程
    echo -e "✓  当前用户 '$USER', MAS 准备扫描，正在重启 App Store 代理进程(appstoreagent) 和 installd ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    killall appstoreagent 2>/dev/null || true
    sudo $SUDO_N_FLAG killall installd 2>/dev/null || true
fi


# 根据已安装应用列表，提取 ID 列用于后续并行检查过时应用。
# 使用 awk 取第一列（应用ID），并筛选出纯数字的 ID。
mas_app_ids_list=$(echo "$mas_installed_apps" | awk '{print $1}' | grep -E '^[0-9]+$')

while [ $mas_attempt -le $MAS_MAX_RETRIES ]; do
    # 如果选择非并行扫描模式，则仅运行一次 mas outdated（不传入参数），并直接跳出循环。
    if [ "$MAS_OUTDATED_MODE" != "parallel" ]; then
        # 根据当前权限运行 mas outdated
        if [[ $(id -u) -eq 0 ]]; then
            echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 执行 mas outdated ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
            # 当通过 sudo 调用时，SUDO_USER 可能为 root（表示父进程为 root），此时尝试
            # 从控制台设备中获取真正的登录用户，确保降权到正确的用户以执行 mas 命令
            if [[ "$targetUser" == "root" ]]; then
                targetUser=$(stat -f '%Su' /dev/console)
            fi
            mas_output=$(sudo -n -H -u "$targetUser" gtimeout 300s /opt/homebrew/bin/mas outdated --accurate-ignore-unknown-apps --verbose 2>&1)
            mas_status=$?
        else
            echo -e "✓  当前用户 '$USER' 为普通权限，直接执行 mas outdated ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            mas_output=$(gtimeout 300s /opt/homebrew/bin/mas outdated --accurate-ignore-unknown-apps --verbose 2>&1)
            mas_status=$?
        fi
        # 如果输出中包含 NSURLErrorDomain，则认为是网络错误。即便退出码不为0，也让后续逻辑按成功解析，避免打印大量错误详情
        # 如果输出中包含 NSURLErrorDomain，则认为是网络错误。即便退出码不为0，也让后续逻辑按成功解析，避免打印大量错误详情
        if [[ "$mas_output" == *NSURLErrorDomain* ]]; then
            mas_status=0
        fi
        # 解析输出，分别处理有效行和错误行
        # 有效行以数字 ID 开头，允许前面有空格
        valid_lines=$(echo "$mas_output" | grep -E '^[[:space:]]*[0-9]+[[:space:]]' || true)
        # 统计错误行：以 Error: 开头的为错误组
        total_error_count=$(echo "$mas_output" | grep -c '^Error:' || true)
        # 其中包含 NSURLErrorDomain 的错误行视为网络错误
        network_error_count=$(echo "$mas_output" | grep -c '^Error:.*NSURLErrorDomain' || true)
        # 剩余的错误行则为其他类型错误
        other_error_count=$(( total_error_count - network_error_count ))
        # 使用 awk 移除错误组的后续行（以空格或制表符开头的行被视为错误详情），保留其他非错误信息
        other_errors=$(echo "$mas_output" | awk '
            BEGIN {inside_err=0}
            /^Error:/ { inside_err=1; next }
            inside_err==1 {
                # 跳过以空格或制表符开头的行，这些是错误详情
                if ($0 ~ /^[[:space:]]/) { next }
                # 非缩进行标志错误组结束
                inside_err=0
            }
            # 输出所有不以数字 ID 开头的非错误行（允许行首有空格）
            ! /^[[:space:]]*[0-9]+[[:space:]]/ { print }
        ' || true)

        # 进一步过滤错误详情中的冗余信息，如 NSURL 相关字段和 LocalizedDescription 行等
        other_errors=$(echo "$other_errors" | grep -v -E '(NSLocalizedDescription=|NSErrorFailingURLStringKey=|NSErrorFailingURLKey=|NSUnderlyingError=|_NSURLErrorRelatedURLSessionTaskErrorKey=|_NSURLErrorFailingURLSessionTaskErrorKey=|_kCFStreamErrorDomainKey=|_kCFStreamErrorCodeKey=|\)\,)' || true)

        # 保存仅包含有效更新信息的列表供后续安装使用
        outdated_mas_apps="$valid_lines"

        if [ $mas_status -eq 0 ]; then
            # 如果存在有效的更新行，则输出这些行
            if [ -n "$valid_lines" ]; then
                echo -e "$valid_lines" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                # 提取应用名称（去除 ID 和版本信息）
                mas_app_names=$(echo "$valid_lines" \
                    | sed -E 's/^[[:space:]]*[0-9]+[[:space:]]+//; s/ *\([^)]*\)//g; s/ *->.*//g')
                while IFS= read -r app_line; do
                    [[ -n "$app_line" ]] && echo -e "✔︎  检测到新版本 : $app_line" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                done <<< "$mas_app_names"
                mas_success=true
            fi
            # 如存在网络错误组，输出摘要而不是详细错误
            if [ "$network_error_count" -gt 0 ]; then
                echo -e "⚠️  MAS 更新接口出现网络错误 ${network_error_count} 次，已忽略错误详情！" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            fi
            # 输出其他类型的错误组摘要
            if [ "$other_error_count" -gt 0 ]; then
                echo -e "⚠️  MAS 更新过程中出现 ${other_error_count} 个错误，请检查日志或稍后重试。" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            fi
            # 输出其他非错误信息
            if [ -n "$other_errors" ]; then
                echo -e "$other_errors" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            fi
            # 如果没有任何有效更新且存在网络错误组，则标记扫描失败
            if [ -z "$valid_lines" ] && [ "$network_error_count" -gt 0 ]; then
                mas_scan_failed=true
                mas_success=false
            fi
        else
            # 失败处理：超时重试或其他错误
            if echo -e "$mas_output" | grep -q "The request timed out"; then
                echo -e "⚠️ 第${mas_attempt}次 MAS 扫描超时，重试中 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            else
                # 如果输出包含网络错误则统计并汇总
                if [[ "$mas_output" == *NSURLErrorDomain* ]]; then
                    # 使用 Error: 行计数作为网络错误次数
                    net_count=$(printf '%s' "$mas_output" | grep -c '^Error:' || true)
                    echo -e "⚠️  MAS 更新接口出现网络错误 ${net_count} 次，已忽略错误详情！" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                    # 标记扫描失败
                    mas_scan_failed=true
                    mas_success=false
                else
                    echo -e "❌ mas 扫描更新失败：$mas_output" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                fi
            fi
        fi
        break
    fi
   #mas_output=$(mas outdated 2>&1)                                                     # 执行 mas 查询更新（捕获输出和错误）
    if [[ $(id -u) -eq 0 ]]; then
        echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 并行运行 mas outdated 检查各个应用 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        # 在 root 情况下，使用目标用户执行 mas outdated 针对每个应用 ID。
        # 为了避免 mas 弹窗阻塞，针对每个 ID 单独运行 gtimeout 120s mas outdated "id"。
        # 超时退出码为124时尝试关闭 App Store，并继续后续检查。使用 xargs 并发 16 个进程。
        mas_output=$(printf '%s\n' $mas_app_ids_list | xargs -P "$MAS_OUTDATED_PARALLEL_JOBS" -I{} sudo -E -n -H -u "$targetUser" sh -lc 'if gtimeout 120s /opt/homebrew/bin/mas outdated --accurate-ignore-unknown-apps --verbose "{}"; then exit 0; fi; ec=$?; if [ $ec -eq 60 ] || [ $ec -eq 124 ]; then osascript -e "tell application \"App Store\" to quit" >/dev/null 2>&1 || true; sleep 1; fi; exit $ec' 2>/dev/null )
        # 由于并行执行会返回最后一个子进程的退出码，此处统一标记为 0，表示我们总是收集并解析输出。
        mas_status=0
    else
        echo -e "✓  当前用户 '$USER' 为普通权限，直接并行运行 mas outdated 检查各个应用 ... "                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  
        # 当前用户为普通权限，直接并行运行 mas outdated 针对每个应用 ID。
        mas_output=$(printf '%s\n' $mas_app_ids_list | xargs -P "$MAS_OUTDATED_PARALLEL_JOBS" -I{} sh -lc 'if gtimeout 120s /opt/homebrew/bin/mas outdated --accurate-ignore-unknown-apps --verbose "{}"; then exit 0; fi; ec=$?; if [ $ec -eq 60 ] || [ $ec -eq 124 ]; then osascript -e "tell application \"App Store\" to quit" >/dev/null 2>&1 || true; sleep 1; fi; exit $ec' 2>/dev/null )
        mas_status=0
    fi
        # mas_status 已在并行命令中设置，不使用上一条命令的退出码

        # -------------------------------------------------------------------------
        # 新增：并行扫描后检查输出有效性。
        # 如果并行扫描输出中没有任何有效的应用 ID 行（即以数字开头的行），
        # 或者输出中包含 NSURLErrorDomain 等错误提示，则认为扫描无效。
        # 这种情况下，降级为串行扫描 (mas outdated) 获取更新列表。
        if [[ -n "$mas_output" ]]; then
            # 使用 grep 判断是否存在以数字 ID 开头的行
            # 如果并行扫描结果中不包含有效的更新行（允许行首有空格），或包含网络错误，则尝试顺序扫描
            if ! echo "$mas_output" | grep -q -E '^[[:space:]]*[0-9]+[[:space:]]' || echo "$mas_output" | grep -q "NSURLErrorDomain"; then
                echo -e "⚠️  mas outdated 并行扫描未返回有效结果，尝试串行扫描 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                if [[ $(id -u) -eq 0 ]]; then
                    targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
                    mas_output=$(sudo -E -n -H -u "$targetUser" /opt/homebrew/bin/mas outdated --accurate-ignore-unknown-apps --verbose 2>&1 || true)
                else
                    mas_output=$(/opt/homebrew/bin/mas outdated --accurate-ignore-unknown-apps --verbose 2>&1 || true)
                fi
                # 重置 mas_status 为 0，以便后续逻辑继续处理
                mas_status=0
            fi
        fi

    # 如并行扫描未返回结果，尝试单次执行 mas outdated 作为回退方案
    if [ -z "$mas_output" ]; then
        echo -e "⚠️  mas outdated 并行扫描未返回结果，尝试串行扫描 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        if [[ $(id -u) -eq 0 ]]; then
            # 在 root 权限下，降权执行一次 mas outdated，并保留环境变量，捕获输出
            targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
            mas_output=$(sudo -E -n -H -u "$targetUser" /opt/homebrew/bin/mas outdated --accurate-ignore-unknown-apps --verbose 2>&1 || true)
        else
            # 普通用户直接执行 mas outdated
            mas_output=$(/opt/homebrew/bin/mas outdated --accurate-ignore-unknown-apps --verbose 2>&1 || true)
        fi
    fi

    # 解析并行扫描后的结果并写入日志
    # 提取以数字 ID 开头的有效行
    valid_lines=$(echo "$mas_output" | grep -E '^[[:space:]]*[0-9]+[[:space:]]' || true)
            # 统计错误组次数：每个以 Error: 开头的行为一个错误组
            total_error_count=$(echo "$mas_output" | grep -c '^Error:' || true)
            # 其中包含 NSURLErrorDomain 的错误组视为网络错误
            network_error_count=$(echo "$mas_output" | grep -c '^Error:.*NSURLErrorDomain' || true)
            # 剩余的错误组视为其他类型错误
            other_error_count=$(( total_error_count - network_error_count ))
            # 其他错误行：排除有效行和 Error: 开头的错误行
            other_errors=$(echo "$mas_output" | grep -v -E '^[[:space:]]*[0-9]+[[:space:]]' | grep -v '^Error:' || true)
            # 进一步过滤错误详情中的冗余信息，如 NSURL 相关字段和 LocalizedDescription 行等
            other_errors=$(echo "$other_errors" | grep -v -E '(NSLocalizedDescription=|NSErrorFailingURLStringKey=|NSErrorFailingURLKey=|NSUnderlyingError=|_NSURLErrorRelatedURLSessionTaskErrorKey=|_NSURLErrorFailingURLSessionTaskErrorKey=|_kCFStreamErrorDomainKey=|_kCFStreamErrorCodeKey=|\)\,)' || true)

    # 仅保存有效更新信息供后续安装使用
    outdated_mas_apps="$valid_lines"

    if [ $mas_status -eq 0 ]; then
        # 若存在有效的更新行，则输出这些行
        if [ -n "$valid_lines" ]; then
            echo -e "$valid_lines" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            # 提取应用名称（去除 ID 和版本信息）
            mas_app_names=$(echo "$valid_lines" \
                | sed -E 's/^[[:space:]]*[0-9]+[[:space:]]+//; s/ *\([^)]*\)//g; s/ *->.*//g')
            while IFS= read -r app_line; do
                [[ -n "$app_line" ]] && echo -e "✔︎  检测到新版本 : $app_line" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            done <<< "$mas_app_names"
            mas_success=true
        fi
            # 根据错误统计输出摘要信息
            if [ "$network_error_count" -gt 0 ]; then
                echo -e "⚠️  MAS 更新接口出现网络错误 ${network_error_count} 次，已忽略错误详情！" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            fi
            if [ "$other_error_count" -gt 0 ]; then
                echo -e "⚠️  MAS 更新过程中出现 ${other_error_count} 个错误，请检查日志或稍后重试。" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            fi
            # 输出其他非错误信息（如果有）
            if [ -n "$other_errors" ]; then
                echo -e "$other_errors" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            fi
            break
    else
        # 扫描失败，检查是否超时错误
        if echo -e "$mas_output" | grep -q "The request timed out"; then
            echo -e "⚠️ 第${mas_attempt}次 MAS 扫描超时，重试中 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        else
            echo -e "❌ mas 扫描更新失败：$mas_output" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            break   # 遇到非超时错误，跳出循环不再重试
        fi
        mas_attempt=$((mas_attempt+1))
        sleep $MAS_RETRY_DELAY 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  # 等待一段时间再重试
    fi
done

    # 如果扫描标记为失败（无有效更新且发生网络错误），在扫描阶段结束时输出失败提示
    if [ "$mas_scan_failed" = true ]; then
        echo -e "❌ 扫描更新失败" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    fi

    # 如果扫描成功但没有发现任何可更新的应用，则提示扫描已完成且无新版本
    # 仅当未标记为扫描失败且未检测到任何需要更新的应用时输出此信息
    if [ "$mas_scan_failed" != true ] && [ "$mas_success" != true ]; then
        echo -e "✓  已完成所有软件扫描，没有发现新版本" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    fi


echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 


printf  "\033[1;34m[Download & Install]\033[0m "
printf  "[Download & Install] "                                                         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "MAS 下载安装 ... "                                                           | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"


# 根据扫描结果决定是否进行安装更新
if [ "$mas_scan_failed" = true ]; then
    echo -e "❌ 由于 MAS 扫描更新失败，已跳过下载和安装步骤。" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
elif [ "$mas_success" = true ]; then
    # 开始执行：MAS 更新（并捕获输出）
    # 获取过时应用程序的ID，并转换为以空格分隔的列表以供 mas upgrade 使用
    mas_app_ids=$(echo -e "$outdated_mas_apps" | awk '{print $1}' | grep -E '^[0-9]+$')
    # 用空格连接 ID 以便于传递给 mas upgrade；如果没有需要更新的 ID，则该变量为空
    mas_app_ids_joined=$(echo "$mas_app_ids" | tr '\n' ' ' | sed 's/[[:space:]]*$//')
    
    echo -e "✓  开始扫描，待更新的APP，是否正在运行 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    #echo -e "mas_app_ids = $mas_app_ids "      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"  # 测试！

    # 存储需要关闭和重启的应用程序
    mas_apps_to_restart=()

    # 检查并关闭正在运行的应用程序
    for mas_id in $mas_app_ids; do
        # 从已安装应用列表中提取应用名称，去掉ID和可能的版本号
        mas_app_name=$(echo -e "$mas_installed_apps" | grep "^$mas_id" | awk '{$1=""; print substr($0,2)}' | sed 's/ ([0-9].*)$//')
        #echo -e "mas_app_name = $mas_app_name "     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" # 测试！
        
        # 检测进程正在运行，如果运行则尝试关闭
        if [ -n "$mas_app_name" ]; then
            # 使用 osascript 检查应用是否正在运行
            if osascript -e "tell application \"System Events\" to (name of processes) contains \"$mas_app_name\"" | grep -q "true"; then
                echo -e "✓  检测到 $mas_app_name 正在运行，正在尝试关闭 ... "                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
                # 安全关闭应用程序
                osascript -e "tell application \"$mas_app_name\" to quit"
                # 等待应用完全关闭（最多10秒）
                for i in {1..10}; do
                    if ! osascript -e "tell application \"System Events\" to (name of processes) contains \"$mas_app_name\"" | grep -q "true"; then
                        break
                    fi
                    sleep 1
                done
                # 如果应用仍未关闭，尝试强制关闭
                if osascript -e "tell application \"System Events\" to (name of processes) contains \"$mas_app_name\"" | grep -q "true"; then
                    echo -e "✘  无法正常关闭 $mas_app_name ，正在尝试强制关闭 ... "                      | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
                    # 获取应用程序的PID
                    mas_pid=$(pgrep -f "$mas_app_name")
                    if [ -n "$mas_pid" ]; then
                        kill -9 $mas_pid
                        echo -e "✓  已强制关闭 $mas_app_name (PID: $mas_pid)"                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
                    else
                        echo -e "✘  无法获取 $mas_app_name 的PID，跳过强制关闭"                         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
                    fi
                fi
                # 再次检查应用是否已关闭成功
                if osascript -e "tell application \"System Events\" to (name of processes) contains \"$mas_app_name\"" | grep -q "true"; then
                    echo -e "✘  无法关闭 $mas_app_name ，稍后 将跳过重启该应用。"                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                else
                    # 已成功关闭的应用加入重启列表
                    mas_apps_to_restart+=("$mas_app_name")
                    echo -e "✓  已关闭 $mas_app_name ，稍后 将重新启动该应用。"                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
                fi
            fi
        fi
    done
    
    echo -e "✓  所有 待更新的 MAS APP ，均已停止运行 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # ---------------------------------------------------------------------------------------
    # 新增：MAS outdated 完成后，重启 App Store 代理进程和安装守护进程，以避免后续流程因
    # 大量 MAS 请求导致系统安装服务卡死。根据当前权限分别处理，确保日志打印风格一致。
    if [[ "$(id -u)" -eq 0 ]]; then
        # 当前为 root 权限，直接重启代理进程和安装守护进程
        echo -e "✓  Root权限, MAS 准备下载安装，正在重启 App Store 代理进程(appstoreagent) 和 installd ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 结束 App Store 代理进程（忽略不存在的错误）
        killall appstoreagent 2>/dev/null || true
        # 重启安装守护进程
        killall installd 2>/dev/null || true
    else
        # 当前为普通用户，需要使用 sudo 重启安装守护进程
        echo -e "✓  当前用户 '$USER', MAS 准备下载安装，正在重启 App Store 代理进程(appstoreagent) 和 installd ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        killall appstoreagent 2>/dev/null || true
        sudo $SUDO_N_FLAG killall installd 2>/dev/null || true
    fi

    # -------------------------------------------------------------------------
    # 调整：串行运行 mas upgrade 更新每个应用，确保输出与并行 Homebrew 风格一致。
    # 这里不再使用并行 xargs，而是逐个 ID 处理并实时打印结果。
    #
    # 初始化结果列表
    mas_result_list=()
    # 根据当前身份选择执行方式
    if [[ $(id -u) -eq 0 ]]; then
        targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
        # 若通过 sudo 调用链时 SUDO_USER 为 root，则尝试从控制台获取真实登录用户
        if [[ "$targetUser" == "root" ]]; then
            targetUser=$(stat -f '%Su' /dev/console)
        fi
        # 打印串行升级提示
        echo -e "✓  使用Root权限 直接串行运行 mas upgrade 指定应用 ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 逐个应用执行 mas upgrade
        for mas_id in $mas_app_ids; do
            # 从已安装应用列表中提取应用名称，去掉 ID 和可能的版本号
            mas_app_name=$(printf '%s\n' "$mas_installed_apps" | awk -v id="$mas_id" '($1==id){$1=""; sub(/^ +/, ""); print; exit}' | sed 's/ ([0-9].*)$//')
            # 如果没有找到名称，则使用 ID 作为名称（防止打印出空白）
            [ -n "$mas_app_name" ] || mas_app_name="$mas_id"
            # 提示正在升级
            echo -e "✓  正在升级 MAS APP：$mas_app_name ( sudo mas upgrade $mas_id ) ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            # 执行升级并捕获输出
            upgrade_output=$(sudo -E -n -H -u "$targetUser" /bin/bash -lc "sudo /opt/homebrew/bin/mas upgrade $mas_id 2>&1")
            upgrade_status=$?
            # 实时打印升级输出
            echo -e "$upgrade_output" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            # 根据返回码判定结果
            if [ $upgrade_status -eq 0 ]; then
                mas_result_list+=("success|$mas_app_name")
            else
                mas_result_list+=("failure|$mas_app_name")
            fi
        done
    else
        # 非 root 用户直接执行 mas upgrade
        echo -e "✓  当前用户 '$USER' 为普通权限，直接串行运行 mas upgrade 指定应用 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        for mas_id in $mas_app_ids; do
            mas_app_name=$(printf '%s\n' "$mas_installed_apps" | awk -v id="$mas_id" '($1==id){$1=""; sub(/^ +/, ""); print; exit}' | sed 's/ ([0-9].*)$//')
            [ -n "$mas_app_name" ] || mas_app_name="$mas_id"
            echo -e "✓  正在升级 MAS APP：$mas_app_name ( sudo mas upgrade $mas_id ) ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            upgrade_output=$(/bin/bash -lc "sudo /opt/homebrew/bin/mas upgrade $mas_id 2>&1")
            upgrade_status=$?
            echo -e "$upgrade_output" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            if [ $upgrade_status -eq 0 ]; then
                mas_result_list+=("success|$mas_app_name")
            else
                mas_result_list+=("failure|$mas_app_name")
            fi
        done
    fi
    # 清空 mas_output 以避免后续解析覆盖结果（mas_result_list 已经构建）
    mas_output=""

    # 如果未产生任何结果（mas_result_list 为空），则保留原有解析逻辑作为后备方案
    if [ ${#mas_result_list[@]} -eq 0 ]; then
        # （3）解析升级结果，构建结果列表（不立即输出）
        mas_result_list=()
        # 提取已更新的应用名称
        # 尝试解析 mas upgrade 输出中的已更新应用名称。
        updated_mas_app_names=""
        # 如果输出中包含 “Installed”、“Upgraded” 或 “Upgrading” 等关键字，认为这些行表示更新成功。
        if echo "$mas_output" | grep -Eq "Installed|Upgraded|Upgrading"; then
            updated_mas_app_names=$(echo "$mas_output"  | grep -E "Installed|Upgraded|Upgrading"  | sed -E 's/^==> (Installed|Upgraded|Upgrading) //; s/ *\([^)]*\)//g; s/ *->.*//g')
        fi
        # 提取需要更新的应用名称
        outdated_mas_app_names=""
        if [ -n "$outdated_mas_apps" ]; then
            # 仅解析以数字 ID 开头的行，确保排除错误信息或其他无关输出
            outdated_mas_app_names=$(echo "$outdated_mas_apps" | grep -E '^[[:space:]]*[0-9]+[[:space:]]' | sed -E 's/^[[:space:]]*[0-9]+[[:space:]]+//; s/ *\([^)]*\)//g; s/ *->.*//g')
        fi
        # 根据旧列表和新列表构建更新结果
        if [ -n "$outdated_mas_app_names" ]; then
            while IFS= read -r __mas_name; do
                [ -n "$__mas_name" ] || continue
                # 判断更新成功：仅当 updated_mas_app_names 中存在完整匹配的应用名称时才认为升级成功；
                # 如果未匹配，则直接判定为失败，避免因名称出现在 “Downloading” 或错误输出中而误判。
                if [ -n "$updated_mas_app_names" ] && grep -Fxq "$__mas_name" <<< "$updated_mas_app_names"; then
                    mas_result_list+=("success|$__mas_name")
                else
                    mas_result_list+=("failure|$__mas_name")
                fi
            done <<< "$outdated_mas_app_names"
        fi
    fi

    # 重新启动之前关闭的应用程序
    for mas_app in "${mas_apps_to_restart[@]}"; do
        echo -e "✓ 正在重新启动 $mas_app ... "                                                  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        open -a "$mas_app"  2>&1                                                                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
        sleep 1  # 短暂延迟以确保应用启动
    done

    # 输出 MAS 更新结果，使用类似 HomeBrew 的风格
    echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    printf "\033[1;34m[Final]\033[0m "
    printf "[Final] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "MAS 更新结果 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    
    # ---------------------------------------------------------------------------------------
    # 新增：MAS upgrade 完成后，重启 App Store 代理进程和安装守护进程，以防止大量更新请求可能导致系统安装服务卡死。
    # 根据当前执行身份区分处理，并保证输出风格与其它日志一致。
    if [[ "$(id -u)" -eq 0 ]]; then
        echo -e "✓  Root权限, MAS 升级过程结束，正在重启 App Store 代理进程(appstoreagent) 和 installd ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        killall appstoreagent 2>/dev/null || true
        killall installd 2>/dev/null || true
    else
        echo -e "✓  当前用户 '$USER', MAS 升级过程结束，正在重启 App Store 代理进程(appstoreagent) 和 installd ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        killall appstoreagent 2>/dev/null || true
        sudo $SUDO_N_FLAG killall installd 2>/dev/null || true
    fi

    if [ ${#mas_result_list[@]} -eq 0 ]; then
        echo -e "✓  没有APP被更新 !!! " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    else
        for __entry in "${mas_result_list[@]}"; do
            IFS='|' read -r __status __name <<< "$__entry"
            if [ "$__status" = "success" ]; then
                __symbol="✅"
                __status_text="成功"
            else
                __symbol="❌"
                __status_text="失败"
            fi
            # MAS 更新结果不区分类型，统一对齐空格
            echo -e "$__symbol  更新$__status_text       : $__name" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        done
    fi
    echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 完成提示
    echo -e "\033[1;32m[OK] Mac App Store Upgrade  运行已完成已完成 ，APP 已重启 ✅ \033[1;32m"
    echo -e "[OK]  Mac App Store Upgrade  运行已完成已完成 ，APP 已重启 ✅ "                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null



else

    # 如果扫描成功但没有应用需要更新，则输出友好的提示，表示无需更新
    echo -e "✅  Mac App Store （MAS）无需更新软件，所有软件无新版本。" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 打印空行以保持输出风格一致
    echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 输出完成提示，与其他任务模块保持一致，表明 MAS 更新任务已完成
    # 打印带颜色的提示到终端，但不写入日志文件
    echo -e "\033[1;32m[OK] Mac App Store Upgrade  运行已完成已完成  ✅ \033[1;32m"
    # 将无颜色的提示写入日志文件中
    echo -e "[OK] Mac App Store Upgrade  运行已完成已完成  ✅ " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

fi


fi
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"     





# ----------------------------------
# 开始执行：MacPorts
# ----------------------------------

export MacPorts_NO_INTERACTIVE=1


echo -e "\033[1;32m-----------------------------------------------\033[0m"
echo -e "\033[1;32m 运行 MacPorts                              \033[0m"
echo -e "\033[1;32m-----------------------------------------------\033[0m"

echo -e "-------------------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "运行 MacPorts"                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 拒绝执行时间窗口
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

# （1）仅在确实发生“重大变化”时执行一次 migrate
# 若 CLT 未就绪，跳过

if ! ensure_clt_or_skip_macports; then
    echo -e "⏭️  MacPorts 步骤被跳过（缺少 CLT）" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
else
    printf "\033[1;34m[Migrate]\033[0m "
    printf "[Migrate] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null 
    echo "MacPorts 扫描迁移 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    MIGRATE_LOG="$(__get_migrate_log_file)"
    /bin/mkdir -p "${MIGRATE_LOG%/*}" 2>/dev/null || true
    # 在写入之前先清空迁移日志，确保每次执行使用新的日志内容
    : > "$MIGRATE_LOG"

    if macports_should_migrate; then
        echo -e "✓  使用Root权限(sudo命令), 运行 port migrate ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

        # 执行迁移并捕获各阶段的退出码。使用子 shell 保存各个子进程退出状态
        {
            # 使用 -d -v -N 以便生成详细日志到 MIGRATE_LOG。只写入 MIGRATE_LOG，避免普通日志膨胀
           #yes | sudo $SUDO_N_FLAG /opt/local/bin/port -d -v -N migrate 2>&1  | /usr/bin/tee -a "$MIGRATE_LOG" > /dev/null
            yes | sudo $SUDO_N_FLAG /opt/local/bin/port -N migrate 2>&1  | /usr/bin/tee -a "$MIGRATE_LOG" > /dev/null
            # 捕获每个子进程的退出码，使用默认值防止未定义导致 unbound variable
            __yes_rc=${PIPESTATUS[0]-}
            __port_rc=${PIPESTATUS[1]-}
            __tee_rc=${PIPESTATUS[2]-}
        } || true
        # 调试迁移管道返回值，可设置环境变量 DEBUG_MIGRATE=1
        if [ -n "${DEBUG_MIGRATE:-}" ]; then
            echo "    [DEBUG] yes_rc=${__yes_rc} port_rc=${__port_rc} tee_rc=${__tee_rc}" \
                | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        fi
        # 若 port 命令返回 0 或 1，则视为迁移成功（非零但无明显错误）
        if [ "${__port_rc}" = "0" ] || [ "${__port_rc}" = "1" ]; then
            macports_mark_migrated
            echo -e "✓ 迁移完成" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        else
            # 若日志中含有 Migration finished，则视为成功
            if grep -q "Migration finished" "$MIGRATE_LOG" 2>/dev/null; then
                macports_mark_migrated
                echo -e "✓ 迁移完成（日志标识完成）" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
            else
                # 其他退出码视为失败，提示用户查看日志；MIGRATE_LOG 已保证存在
                log_path="${MIGRATE_LOG:-$(__get_migrate_log_file)}"
                echo -e "❌ 迁移失败 ｜ 请检查日志：${log_path}" \
                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_ERROR_FILE"
            fi
        fi
    else
        echo -e "✓ 无需迁移（已处于当前 Darwin/架构/base）" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    fi

    echo "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    printf "\033[1;34m[Scan]\033[0m "
    printf "[Scan] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null 
    echo "MacPorts 扫描更新 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    echo -e "✓  使用Root权限(sudo命令), 运行 port outdated ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    outdated_list="$(sudo $SUDO_N_FLAG /opt/local/bin/port -q outdated -N 2>/dev/null || true)"

    if [ -z "$outdated_list" ]; then
        echo -e "✓  无需升级任何端口 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        echo "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    else
        echo -e "【过期端口】" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        echo "$outdated_list" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        echo "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

        # （3）升级：终端只打印摘要…完整构建日志写文件
        macports_upgrade_outdated_quiet

        # （4）清理（不依赖当前目录）
        printf "\033[1;34m[Clean]\033[0m "
        printf "[Clean] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo "MacPorts 清理残留 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        echo -e "✓  使用Root权限(sudo命令), 运行 port reclaim ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        # 官方 reclaim 命令会删除日志、旧档和 distfiles，并尝试卸载非活动版本
        sudo $SUDO_N_FLAG /opt/local/bin/port -q reclaim
        
        # 卸载仍然处于非活动状态的端口（如果 reclaim 未能完全删除）
        printf "\033[1;34m[Uninstall]\033[0m "
        printf "[Uninstall] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo "MacPorts 卸载非活动旧版本 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        echo -e "✓  使用Root权限(sudo命令), 运行 port uninstall inactive ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        sudo $SUDO_N_FLAG /opt/local/bin/port uninstall inactive
        
        # 删除无人依赖的叶子端口
        printf "\033[1;34m[Leaves]\033[0m "
        printf "[Leaves] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
        echo "MacPorts 移除无人依赖的叶子端口 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        echo -e "✓  使用Root权限(sudo命令), 运行 port uninstall leaves ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        sudo $SUDO_N_FLAG /opt/local/bin/port echo leaves | xargs sudo $SUDO_N_FLAG /opt/local/bin/port uninstall

        echo "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    fi

    # （5）链接自检（摘要）
    printf "\033[1;34m[Verify]\033[0m "
    printf "[Verify] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo "MacPorts 验证结果 ..." | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    echo -e "✓  使用Root权限(sudo命令), 运行 port rev-upgrade ... "   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    macports_rev_upgrade_quiet

    echo -e ""                                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
    echo -e "\033[1;32m[OK] MacPorts Upgrade  运行已完成  ✅\033[0m"
    echo -e "[OK]  MacPorts Upgrade  运行已完成  ✅"                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
fi


echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                                   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 




# ----------------------------------
# 开始执行：TopGrade
# ----------------------------------

export TopGrade_NO_INTERACTIVE=1


echo -e "\033[1;32m-----------------------------------------------\033[0m"  
echo -e "\033[1;32m 运行 TopGrade                              \033[0m"  
echo -e "\033[1;32m-----------------------------------------------\033[0m"  

echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "运行 TopGrade"                                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 等待3秒，开始执行
#sleep 3  

# 调用检查时间范围函数
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

targetUser="${SUDO_USER:-$(stat -f '%Su' /dev/console)}"
if [[ $(id -u) -eq 0 ]]; then
    #—— root 环境：切换到桌面用户执行 ——#
    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 topgrade 进行升级 ... "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
   #echo -e "✓  不参与更新的模块 ：brew_formula \ brew_cask \ sparkle \ mas \ macports \ system \ node \ pnpm \ tldr \ tlmgr \ ruby_gems \ gem \ powershell \ containers ... "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
   #topgrade_output=$(sudo -n -H -u "$targetUser"  /bin/bash -c 'topgrade --disable brew_formula --disable brew_cask --disable sparkle --disable mas --disable macports --disable system --disable node --disable pnpm --disable powershell --disable tldr --disable tlmgr --disable ruby_gems --disable gem --disable containers --cleanup' 2>&1)
    echo -e "✓  不参与更新的模块 ：brew_formula \ brew_cask \ sparkle \ mas \ macports \ system \ tlmgr \ ruby_gems \ gem \ containers ... "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    topgrade_output=$(sudo -n -H -u "$targetUser"  /bin/bash -c 'topgrade --disable brew_formula --disable brew_cask --disable sparkle --disable mas --disable macports --disable system --disable tlmgr --disable ruby_gems --disable gem --disable containers --cleanup' 2>&1)
    printf "%s\n" "$topgrade_output"        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
else
    #—— 非 root 环境：直接执行 ——#
    echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 topgrade 进行升级 ... "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
   #echo -e "✓  不参与更新的模块 ：brew_formula \ brew_cask \ sparkle \ mas \ macports \ system \ node \ pnpm \ tldr \ tlmgr \ ruby_gems \ gem \ powershell \ containers ... "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
   #topgrade --disable brew_formula --disable brew_cask --disable sparkle --disable mas --disable macports --disable system --disable node --disable pnpm --disable powershell --disable tldr --disable tlmgr --disable ruby_gems --disable gem --disable containers --cleanup 2>&1   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    echo -e "✓  不参与更新的模块 ：brew_formula \ brew_cask \ sparkle \ mas \ macports \ system \ tlmgr \ ruby_gems \ gem \ containers ... "  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    topgrade --disable brew_formula --disable brew_cask --disable sparkle --disable mas --disable macports --disable system --disable tlmgr --disable ruby_gems --disable gem --disable containers --cleanup 2>&1   | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
fi



echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

echo -e "\033[1;32m[OK] TopGrade Upgrade  运行已完成  ✅ \033[1;32m"   
echo -e "[OK]  TopGrade Upgrade  运行已完成  ✅ "                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 



# ----------------------------------
# 开始执行： MacUpdater
# ----------------------------------

MacUpdater_ENABLE="true"
export MacUpdater_NO_INTERACTIVE=1

echo -e "\033[1;32m-----------------------------------------------\033[0m" 
echo -e "\033[1;32m 运行 MacUpdater                            \033[0m"
echo -e "\033[1;32m-----------------------------------------------\033[0m" 

echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "运行 MacUpdater"                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

# 等待3秒，开始执行
#sleep 3  

# 调用检查时间范围函数
check_time_range "$STOP_TIME" "$DURATION_MINUTES" "$LOG_ERROR_FILE"

# echo -e "应用列表 ... " | tee -a "$LOG_FULL_FILE"
# TOTAL_APPS=$("/Applications/MacUpdater.app/Contents/Resources/macupdater_client" list | wc -l)
# echo -e "APP 数量（全部总计）: $TOTAL_APPS" | tee -a "$LOG_FULL_FILE"
# run_command_with_show_progress "\"$MACUPDATER_CLIENT\" scan" "SCAN"  "$LOG_MACUPDATER_FILE"

# -------- 获取已安装应用的总数 （扫描 -------- 
printf  "\033[1;34m[List]\033[0m "
printf  "[List] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "MacUpdater 应用列表 ... "                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 


# 检查是否以 root 身份运行
if [ "$(id -u)" -eq 0 ]; then

    targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"

    # 获取目标普通用户（优先使用 SUDO_USER，其次获取当前登录控制台用户）
    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 MacUpdater scan ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    #sudo -H -u "$targetUser" bash -c  'macupdater_app_count=$("/Applications/MacUpdater.app/Contents/Resources/macupdater_client" list | wc -l) '
    macupdater_app_count=$(sudo -n -H -u "$targetUser" /Applications/MacUpdater.app/Contents/Resources/macupdater_client list | wc -l)

else

    echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 MacUpdater list ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    macupdater_app_count=$("/Applications/MacUpdater.app/Contents/Resources/macupdater_client" list | wc -l)

fi

# 去除前导空格
macupdater_app_count="${macupdater_app_count#"${macupdater_app_count%%[![:space:]]*}"}"
# 去除后置空格
macupdater_app_count="${macupdater_app_count%"${macupdater_app_count##*[![:space:]]}"}"
# 可选：强制算术求值以确保它是整数（加 0，如果非数字则出错）
macupdater_app_count=$((macupdater_app_count + 0))
# 进度条所需
TOTAL_APPS=$((macupdater_app_count + 0))
# 显示MacUpdater监控的所有APP数量
echo -e "✓  APP 数量（ MacUpdater ）: $macupdater_app_count （ $TOTAL_APPS ）"                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 

#exit 1          # 测试！

# -------- 获取已安装应用的总数 （扫描 -------- 
printf  "\033[1;34m[Scan]\033[0m "
printf  "[Scan] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "MacUpdater 扫描更新 ... "                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 


# 检查是否以 root 身份运行
if [ "$(id -u)" -eq 0 ]; then

    targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"

    # 获取目标普通用户（优先使用 SUDO_USER，其次获取当前登录控制台用户）
    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 MacUpdater scan ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    MACUPDATER_COMMAND="sudo -n -H -u $targetUser /Applications/MacUpdater.app/Contents/Resources/macupdater_client scan"
        
    #  开始执行 MacUpdater 扫描 
    #### sudo -H -u "$targetUser" bash -c '"/Applications/MacUpdater.app/Contents/Resources/macupdater_client" scan'
    #sudo -H -u "$targetUser" bash -c  'macupdater_app_scanlist=$("/Applications/MacUpdater.app/Contents/Resources/macupdater_client" scan | wc -l) '
    #echo -e "✓  macupdater_app_scanlist : $macupdater_app_scanlist"                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
else

    echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 MacUpdater scan ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    MACUPDATER_COMMAND="/Applications/MacUpdater.app/Contents/Resources/macupdater_client scan"
    
fi

#  开始执行 MacUpdater 扫描 
run_command_with_show_progress "$MACUPDATER_COMMAND" "SCAN"  "$LOG_MACUPDATER_FILE"

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 


#  -------- 更新安装过期应用 （安装） -------- 

printf  "\033[1;34m[Install]\033[0m "
printf  "[Install] "                                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "MacUpdater 开始更新 ... "                                                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 


# 检查是否以 root 身份运行
if [ "$(id -u)" -eq 0 ]; then

    # 自动获取当前登录用户
    currentUser=$(stat -f%Su /dev/console)
    targetUser="${SUDO_USER:-$(stat -f "%Su" /dev/console)}"

    # 获取目标普通用户（优先使用 SUDO_USER，其次获取当前登录控制台用户）
    echo -e "✓  Root权限 降权至 普通权限 ( $targetUser ) 后 , 再运行 MacUpdater update ...（当前用户是 root）" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 以目标用户身份执行更新命令，捕获输出和退出状态
    macupdater_output=$(sudo -n -H -u "$targetUser" bash -c "\"/Applications/MacUpdater.app/Contents/Resources/macupdater_client\" update --force-quit-running-apps --force-major-version-update" 2>&1)
    rc=$?
    echo -e "$macupdater_output" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

else

    echo -e "✓  当前用户 '$USER' 为普通权限，直接运行 MacUpdater update ... "          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
   #"/Applications/MacUpdater.app/Contents/Resources/macupdater_client" update --force-quit-running-apps --force-major-version-update 2>&1 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 直接执行更新命令，捕获输出和退出状态
    macupdater_output=$(/Applications/MacUpdater.app/Contents/Resources/macupdater_client update --force-quit-running-apps --force-major-version-update 2>&1)
    rc=$?
    echo -e "$macupdater_output" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

fi

echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

    # 解析更新输出，构建结果列表
    macupdater_result_list=()
    current_app=""
    app_name=""
    while IFS= read -r line; do
        if [[ "$line" =~ ^Updating[[:space:]]\'(.+)\' ]]; then
            current_app="${BASH_REMATCH[1]}"
            app_name="$(basename "$current_app")"
        elif [[ "$line" =~ [Uu]pdate[[:space:]]success ]]; then
            if [ -n "$app_name" ]; then
                macupdater_result_list+=("success|$app_name")
                app_name=""
            fi
        elif [[ "$line" =~ [Ff]ailed ]] || [[ "$line" =~ [Ee]rror ]]; then
            if [ -n "$app_name" ]; then
                macupdater_result_list+=("failure|$app_name")
                app_name=""
            fi
        fi
    done <<< "$macupdater_output"
    if [ ${#macupdater_result_list[@]} -eq 0 ]; then
        if [ "$rc" -ne 0 ]; then
            macupdater_result_list+=("failure|MacUpdater")
        fi
    fi
    # 输出 MacUpdater 更新结果
    printf "\033[1;34m[Final]\033[0m "
    printf "[Final] " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "MacUpdater 更新结果 ... " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    if [ ${#macupdater_result_list[@]} -eq 0 ]; then
        echo -e "✓  没有APP被更新 !!! " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    else
        for __entry in "${macupdater_result_list[@]}"; do
            IFS='|' read -r __status __name <<< "$__entry"
            if [ "$__status" = "success" ]; then
                __symbol="✅"
                __status_text="成功"
            else
                __symbol="❌"
                __status_text="失败"
            fi
            echo -e "$__symbol  更新$__status_text [macupdater]   : $__name" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
        done
    fi
    echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    # 完成提示
    echo -e "\033[1;32m[OK] MacUpdater 运行已完成  ✅ \033[1;32m"
    echo -e "[OK]  MacUpdater 运行已完成  ✅ " | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    echo -e "" | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"





# ----------------------------------
# 恢复 启动台布局（LaunchPad）
# ----------------------------------

# 在所有更新操作完成后，调用启动台布局（LaunchPad）恢复脚本，恢复之前保存的布局

#trap - EXIT  # 取消先前设置的 trap，避免重复恢复

echo -e "\033[1;32m-----------------------------------------------\033[0m" 
echo -e "\033[1;32m 恢复 启动台布局（LaunchPad）                    \033[0m"
echo -e "\033[1;32m-----------------------------------------------\033[0m" 

echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "恢复 启动台布局（LaunchPad）"                                                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
output=$(restore_desktop_layout 2>&1)   
status=$?   
echo -e "$output"                                  
    
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
if [ $status -ne 0 ]; then  

    printf  "\033[1;34m[Info]\033[0m "
    printf  "[Info] "                                                                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "启动台布局 恢复路径: '$PATH_DesktopLayout_db_SOURCE'"                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    printf  "\033[1;34m[Info]\033[0m "
    printf  "[Info] "                                                                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    echo -e "启动台布局 备份路径：'$PATH_DesktopLayout_BACKUP'"                             | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
    printf  "\033[1;34m[ERROR] 启动台布局 恢复失败，请手动恢复 ❌❌❌❌❌\033[0m "   
    printf  "[ERROR]  启动台布局 恢复失败，请手动恢复 ❌❌❌❌❌"                         | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

else    

    echo -e "\033[1;32m[OK] 恢复 启动台布局  运行已完成 ✅ \033[1;32m"   
    echo -e "[OK]   恢复 启动台布局  运行已完成 ✅ "                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null

fi  
    
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"



# ----------------------------------
# 记录：完成时间 
# ----------------------------------

# 最后打印执行完成的时间

echo -e "\033[1;32m-----------------------------------------------\033[0m" 
echo -e "\033[1;32m 已完成 所有更新                            \033[0m"
echo -e "\033[1;32m-----------------------------------------------\033[0m" 

echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "已完成 所有更新"                                                               | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "-------------------------------------------"                                            | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
    
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
gui_app_count=$(($brew_cask_count+$mas_app_count+$sparkle_non_brew_count))
echo -e "✅  APP 数量（ HomeBrew Formula              ） ：$brew_formula_count  "                    | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e "✅  APP 数量（ HomeBrew Cask                 ） ：$brew_cask_count  "                       | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e "✅  APP 数量（ Mac App Store                 ） ：$mas_app_count   "                        | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
echo -e "✅  APP 数量（ Sparkle                       ） ：$sparkle_app_count  "                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"

if [ "${MacUpdater_ENABLE:-false}" != "true" ]; then  
    echo -e "✅  APP 数量（ MAS + Sparkle + HomeBrew Cask ） ：$gui_app_count "                  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
else
    echo -e "✅  APP 数量（ MacUpdater                    ） ：$macupdater_app_count  （ $gui_app_count = MAS + Sparkle + HomeBrew Cask ）"                  | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE"
fi

echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
printf  "\033[1;34m[Info]\033[0m "
printf  "[Info] "                                                                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" > /dev/null
echo -e "日志路径 ... "                                                                     | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e "'$LOG_PATH'"                                                                 | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
    
echo -e "\033[1;32mFinished at: $(date) \033[0m"    
echo -e "Finished at: $(date)"                                                          | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" "$LOG_FILE" > /dev/null
    
# 打开Log日志文件夹 
open "$LOG_PATH"    
    
    
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
echo -e ""                                                                              | tee -a "$LOG_FULL_LAST" "$LOG_FULL_FILE" 
